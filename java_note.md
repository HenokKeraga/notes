
Dt : 17/3/2023(Day-1)(Friday)

Course : Full Stack Java Developer




Modules:

1.Programming Module

(CoreJava,AdvJava,Spring)

2.UI Module

(HTML/CSS/JS - Anguler)

3.Database Module

(Oracle)

4.Testing Module

(Testing Basics - Selenium)

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM

(ii)Project

------------------------------------------------------------

Language:

(i)Alphabets

(ii)Grammer

(iii)Construction Rules




Note:

=>Every language will have its own Alphabets,Grammer and

Contruction Rules.

==================================================================

Java:

Part-1 : CoreJava

Part-2 : AdvJava




Part-1 : CoreJava

1.Programming Components(Java Alphabets)

2.Programming Concepts

3.Object Oriented Programming features




1.Programming Components(Java Alphabets)

(a)Variables

(b)Methods

(c)Blocks

(d)Constructors

(e)Classes

(f)Interfaces

(g)AbstractClasses




2.Programming Concepts

(a)Object Oriented Programming

(b)Exception handling

(c)Java Collection Framework(JCF)

(Data Structures in Java)

(d)Multi-Threading

(e)IO Streams and Files

(f)Networking in Java




3.Object Oriented Programming features

(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism

(f)Inheritance

------------------------------------------------------------------

Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava

=>AdvJava provides the following technologies to construct

WebApplications:

(a)JDBC

(b)Servlet

(c)JSP

faq:

define Web Applications?

=>The applications which are executed in Web-Environment or Internet

Environment are known as Web Applications.




Architecture of Web Application:




(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to

establish communication to DB-Product




(b)Servlet:

=>Servlet means "server program" and which accepts request from the

User.





(c)JSP:

=>JSP stands for "Java Server Page" and which is response from

WebApplications

===================================================================

Dt : 23/3/2023(day-3)

faq:

wt is the diff b/w

(i)Language

(ii)Technology

(iii)Framework




(i)Language:

=>Language will provide Components and Concepts used in

contructing programs.

Ex:

CoreJava




(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.

Ex:

AdvJava

(iii)Framework:

=>The structure which is ready for application development

is known as Framework.

Ex:

Spring,WebServices

================================================================

Summary:

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-2 : AdvJava ------------->WebApplications

Level-3 : Frameworks----------->Enterprise Applications

(Spring,WebServices)

==================================================================

faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs

actions in the same computer are known as Stand-Alone applications

or DeskTop Applications or Windows Applications.

=>Stand-Alone applications means,

No html input

No Server Environment

No Database storage

===============================================================

faq:

define Enterprise Applications?

=>The applications which are executing in distributed environment

and depending on the features like "Security","Load Balancing"

and "Clustering" are known as Enterprise applications or Enterprise

Distributed applications.

================================================================

Dt:27/3/2023

faq:

wt is the diff b/w

1.JDK

2.JRE

3.JVM




1.JDK:

=>JDK stands for "Java Development Kit" and which is collection

of the following:

(i)Java Compiler

(ii)Java Library

(iii)JVM




Diagram:































(i)Java Compiler:

=>Java Compiler will compile the source code and if the

compilation Process is successfull then Byte code is generated.

(Java Compiler will compile the Source code and generate Byte code)




(ii)Java Library:

=>Java Library will provide pre-defined ready constructed

components which are used in application development.




(iii)JVM:

=>JVM stands for "Java Virtual Machine" and which is used to

execute Java Byte Code.

---------------------------------------------------------

2.JRE:

=>JRE stands for "Java Runtime Environment" and which is collection

of JavaLib and JVM.

=>JRE is internal partition of JDK.

------------------------------------------------------------

3.JVM:

=>JVM will execute Java Byte Code.

========================================================

faq:

define Virtual Machine?

=>The s/w component which internally having the behaviour like

machine is knonw as Virtual Machine.

=========================================================

Dt : 17/3/2023(Day-1)(Friday)

Course : Full Stack Java Developer




Modules:

1.Programming Module

(CoreJava,AdvJava,Spring)

2.UI Module

(HTML/CSS/JS - Anguler)

3.Database Module

(Oracle)

4.Testing Module

(Testing Basics - Selenium)

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM

(ii)Project

------------------------------------------------------------

Language:

(i)Alphabets

(ii)Grammer

(iii)Construction Rules




Note:

=>Every language will have its own Alphabets,Grammer and

Contruction Rules.

==================================================================

Java:

Part-1 : CoreJava

Part-2 : AdvJava




Part-1 : CoreJava

1.Programming Components(Java Alphabets)

2.Programming Concepts

3.Object Oriented Programming features




1.Programming Components(Java Alphabets)

(a)Variables

(b)Methods

(c)Blocks

(d)Constructors

(e)Classes

(f)Interfaces

(g)AbstractClasses




2.Programming Concepts

(a)Object Oriented Programming

(b)Exception handling

(c)Java Collection Framework(JCF)

(Data Structures in Java)

(d)Multi-Threading

(e)IO Streams and Files

(f)Networking in Java




3.Object Oriented Programming features

(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism

(f)Inheritance

------------------------------------------------------------------

Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava

=>AdvJava provides the following technologies to construct

WebApplications:

(a)JDBC

(b)Servlet

(c)JSP

faq:

define Web Applications?

=>The applications which are executed in Web-Environment or Internet

Environment are known as Web Applications.




Architecture of Web Application:




(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to

establish communication to DB-Product




(b)Servlet:

=>Servlet means "server program" and which accepts request from the

User.





(c)JSP:

=>JSP stands for "Java Server Page" and which is response from

WebApplications

===================================================================

Dt : 23/3/2023(day-3)

faq:

wt is the diff b/w

(i)Language

(ii)Technology

(iii)Framework




(i)Language:

=>Language will provide Components and Concepts used in

contructing programs.

Ex:

CoreJava




(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.

Ex:

AdvJava

(iii)Framework:

=>The structure which is ready for application development

is known as Framework.

Ex:

Spring,WebServices

================================================================

Summary:

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-2 : AdvJava ------------->WebApplications

Level-3 : Frameworks----------->Enterprise Applications

(Spring,WebServices)

==================================================================

faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs

actions in the same computer are known as Stand-Alone applications

or DeskTop Applications or Windows Applications.

=>Stand-Alone applications means,

No html input

No Server Environment

No Database storage

===============================================================

faq:

define Enterprise Applications?

=>The applications which are executing in distributed environment

and depending on the features like "Security","Load Balancing"

and "Clustering" are known as Enterprise applications or Enterprise

Distributed applications.

================================================================
5/20/23, 9:32 AM	6 PM CoreJava145-Dia1.png












































































https://classroom.google.com/c/NTE3NTIyNTA2MzQ4/m/NjAxMDI5NzgxNTk4/details	1/1

dt : 24/3/2023(Day-4)(Syllabus)

*imp

define Program?

=>Program is a set-of-Instructions




define Programming?

=>The process of constructing programs is known as Programming.




Note:

=>After writing programs,we save the programs with language

extentions

Test.c

Test.cpp

Test.java

=>After writing and saving the programs,the programs will have

the following two stages:

1.Compilation

2.Execution





1.Compilation:

=>The process of checking the program constructed according to

the rules of language or not,is known as Compilation process.

=>If the Compilation process is successfull,then sourceCode is

converted into Compiled code.

=>c and c++ languages generate "Objective Code" and JavaLang

generate "Byte Code",after Compilation process.




2.Execution:

=>The process of running compiled codes and checking the required

output is generated or not,is known as Execution process.

=>In C and c++ languages,the Objective Code is converted into

Executable code after loading and linking process,and generate

result.

=>In JavaLang,the ByteCode is executed on JVM(Java Virtual Machine)




Diagram:

=================================================

faq:

define Loading process?

=>The process of loading the required components into current

running program is known as "Loading process".

=>This loding process is performed using internal Loaders.





faq:

define Linking process?

=>The process of linking the loaded components into current running

program where they are needed,is known as "Linking Process".

=>This Linking process is performed using internal Linkers.

===========================================================

faq:

wt is the diff b/w

(a)Objective Code

(b)Byte Code




(a)Objective Code:

=>The Compiled code generated from c and c++ programs is known

as Objective Code.

=>while Objective Code generation,OperatingSystem is participated

and,because if this reason Objective code is PlatForm dependent

code.




DisAdvantage:

=>The Objective Code which is generated from one PlatForm cannot

be executed on other PlatForms.





Note:

=>C and c++ languages which are generating Objective Code are

Platform dependent languages.




(b)Byte Code:

=>The Compiled code generated from JavaPrograms is known as

ByteCode.

=>While ByteCode generation,OperatingSystem is not participated

and,because of this reason ByteCode is PlatForm independent code




Advantage:

=>The ByteCode which is generated from one PlatForm can be

executed on all PlatForms based on JVM.




Note:

=>The JavaLang which is generating ByteCode is PlatForm

independent language.




Diagram:

=============================================================
5/20/23, 9:33 AM	6 PM CoreJava146-Dia2.png












































































https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all	1/1

Dt : 25/3/2023(Day-5)

faq:

define High Level Languages?

=>The language programs which are constructed from the format

which is understandable by the users,are known as High Level

languages

Ex:

C,C++,Java




faq:

define Low Level Languages?

=>The Language programs which are constructed from the format

which is not understandable by the users,are known as Low Level

Languages.

Ex:

Machine Languages




faq:

define Translators?

=>Translators are used to translate High Level Language formats

into Low Level Language formats and Low Level Language formats into

High Level Language formats

=>These Translators are categorized into two types:

(i)Compilers	- translates the total program at-a-time

(ii)Interpreters - translates the program line-by-line














































==============================================================

*imp

History of Java:

"James Gosling" - Sun Micro Systems - 1991 - Code Writer(Programmer)


WORA - Write Once and Run Anywhere

Virtual Machine




Test.gt (Green Talk)




OAK




"SILK" "DNA" ... "JAVA"




1995

--------------------------------------------------

Java Versions:



2011 - Java7

2014 - Java8

2017 - Java9

2018 - Java10,Java11

2019 - Java12,Java13

2020 - Java14,Java15

2021 - Java16,Java17

2022 - Java18,Java19

2023 - Java20(March 21st)

=====================================================

LTS(Long Term Support) products:

Java8

Java11

Java17

======================================================

Dt : 28/3/2023

*imp

Installing Java s/w and Setting path:




step-1 : Download Java s/w(JDK) from Oracle WebSite




https://www.oracle.com/in/java/technologies/downloads/







step-2 : Install JDK(Java s/w)




Note:

=>After installation process is successfull,we can find one

folder with name "java" in "programfiles"

C:\Program Files\Java




step-3 : Set Java path in "Environment Variables"




RightClick on MyComputer->Properties->Advanced System Settings->

Environment Variables->Click "new" from System Variables,





Variable name	: path

Variable value  : C:\Program Files\Java\jdk-17.0.4.1\bin;




step-4 : Click "ok" for three times

===========================================================

Note:

=>Open CommandPrompt and check the following commands are working



=============================================================

Note:

=>Use the following syntax in CommandPrompt to know the Version

available in ComputerSystem:

java -version

============================================================

*imp

Writing,Saving,Compiling and Executing Java program:

=>In Java language writing program means constructing "class".





define "class"?

=>class in Java is a "Structured layout" generating "Objects".

=>Class in Java is a Collection of Variables,Methods,Blocks,

Constructors and main()

=>we use "class" keyword in Java to construct Classes




structure of "class" in Java:




class Class_name

{

Variables

Methods

Blocks

Constructors

main()

}




=>main() in Java will have the following pre-defined built-in

format:




public static void main(String args[])

--------------------------------------------------------

Ex-program :

Wap to display the msg as "Welcome to Java"?

class Display

{

public static void main(String args[])

{

System.out.print("Welcome to Java");

}

}

=======================================================


Dt : 29/3/2023

Executing Java Program:




step-1 : Create one folder in any drive

D:\Demo146




step-2 : Open notepad and type the program




step-3 : Save the program in folder with language extention

syntax:

Class_name.java

Ex:

Display.java




To save the program,click on File->Save->Browse the folder->

name the file as "Display.java"->save as type must be "All files"->

click "Save".




Note:

=>Open CommandPrompt to perform Compilation and execution process

=>To open CommandPrompt->goto folder->type "cmd" in AddressBar and

press enter.


step-4 : Compile the program as follows

syntax:

javac Class_name.java

Ex:

javac Display.java




step-5 : Execute the program as follows

syntax:

java Class_name

Ex:

java Display

================================================================

Ex-2 :

wap to add two numbers and display the result?




class Addition

{

public static void main(String args[])

{


int a=11,b=12;

int c = a+b;

System.out.println("a value="+a);

System.out.println("b value="+b);

System.out.print("c value="+c);

}

}




o/p:

value=11 b value=12 c value=23

=======================================================

Assignment-1:

wap to display the following: int empId

int empPhNo int empSal

float totSal = empSal+(0.93F*empSal)+(0.63F*empSal);




Assignment-2:

wap to display the following:

int s1

int s2

...

int s6

int totMarks =

float per =

========================================================

Dt : 30/3/2023

faq:

define Environment Variables?

=>The variables part of OperatingSystem holding information about softwares

installed in ComputerSystem are known as "Environment Variables"

=>These Environment Variables are categorized into two types:

(i)User Variables

(ii)System Variables




(i)User Variables:

=>The variables which are related to individual users of ComputerSystem

are known as User Variables.

=>The information available in User variables can be used by only the

indvidual User.




(ii)System Variables:

=>The variables which are related to ComputerSystem are known as System

Variables.

=>The information available in System Variables can be used by all users

of ComputerSystem.

===================================================================

===

faq:

wt is the advantage of having JavaPath in Environment Variables?

=>When we have JavaPath in Environment Variables,then we can Compile and

Execute Java Programs from any location of ComputerSystem.

===================================================================

====

Diagram:




























===================================================================

====

Flow of Syllabus Content:

1.Naming Conventions in Java

2.Datatypes in Java

3.Variables in Java

4.Methods in Java

5.JVM Architecture with internals

6.Constructors in Java

7.Blocks in Java

8.Packages in Java

9.Creating Java Project using IDE

10.Relations in Java(Introduction)

11.References in Java

12.Inheritance in Java

13.Interfaces in Java

14.AbstractClasses in Java

15.InnerClasses in Java

16.PolyMorphism in Java

17.Conclusion of Object Oriented features

(Abstraction and Encapsulation)

18.Exception Handling in Java

19.String in Java

20.WrapperClasses in Java

21.Arrays in Java

22.Java Collection Framework

(Data structures in Java)

23.Enum in Java

24.MultiThreading in Java

25.IO Streams and Files in Java

26.Networking in Java

27.Introduction GUI Programming

28.Object Class(Object Cloning)

29.Conclusion

======================================================

*imp

Naming Conventions in Java:

=>The rules followed by the programmer in writing Java Programs are

known as Naming Conventions in Java.




packages :

def : packages are collection of "Classes and Interfaces".

rule : packages must be in LowerCase.




Classes and Interfaces:

def : Classes and Interfaces are collection of "Variables and Methods"

rule : In Classes and Interfaces the starting letter of every word must

be Capital letter or UpperCase.


Ex:

InputStream

InputStreamReader




Variables and Methods:

def : Variables are data holders and Methods are actions

rule : In Variables and Methods the first word must be lowercase and

from second word onwards the starting letter must be capital

Ex-Variables:

panCardNo

rollNo

Ex-Methods:

getSalary()

calculateTot()




Keywords :

def : Pre-defined Built-in words are known as Keywords

rule : Keywords must be LowerCase

Ex:

static

void

public

class

...

===================================================================

==

faq:

define Identifiers?

=>The names which are used to identify the programming components are

known as Identifiers.

===================================================================

=

Dt : 31/3/2023

*imp

DataTypes in Java:

=>The types of data which we are expecting as input to

JavaPrograms are known as Datatypes in Java.

=>Datatypes in Java are categorized into two types:

1.Primitive datatypes

2.NonPrimitive datatypes




1.Primitive datatypes:

=>The "Single valued data formats" are known as Primitive

datatypes.

=>Primitive datatypes are categorized into four types:

(a)Integer datatypes

(b)Float datatypes

(c)Character datatype

(d)Boolean datatype




(a)Integer datatypes:

=>The numeric data without decimal point representation are

known as Integer datatypes.

=>Integer datatypes are categorized into four types:

(i)byte  - 1 byte(8 bits)

(ii)short - 2 bytes

(iii)int - 4 bytes

(iv)long - 8 bytes

=>"byte" and "short" datatypes are used for stream-data or

Multi-media data.

=>"int" datatype is used in normal programming.

=>"long" datatype is used to hold lagest numeric value without

decimal point,which means holding PhoneNO,CardNo,...

=>In the process of assigning long-data-value we must use "L"

(or) "l" in the RHS of declaration.

Ex:

long p = 9898981234L;




(b)Float datatypes:

=>The numeric data with decimal point representation are known

as Float datatypes.

=>Float datatypes are categorized into two types:

(i)float  - 4 bytes

(ii)double - 8 bytes

=>"float" datatype is used in normal programming.

=>"double" datatype is used to hold lagest scientic calculated

values

=>In the process of assigning float-data-value we must use "F"

(or) "f" in the RHS of declaration.

Ex:

float k = 123.56F;




(c)Character datatype:

=>The "single valued character" which is represented in single

quotes is known as Character datatype.

Ex:

'h','y','k',...

=>Types:

char - 2 bytes




(d)Boolean datatype:

=>The datatype which is represented in the form of true or false

is known as Boolean datatype.

=>Types:

boolean - 1 bit

---------------------------------------------

Ex-program:

DataTypes1.java

class DataTypes1

{

public static void main(String args[])

{

byte b = 127;

short s = 32767;

int i = 45673467;

long p = 9898981234L;

float k = 123.56F;

double z = 2345.67;

char ch = 'h';

boolean bl = true;

System.out.println("byte value="+b);

System.out.println("short value="+s);

System.out.println("int value="+i);

System.out.println("long value="+p);

System.out.println("float value="+k);

System.out.println("double value="+z);

System.out.println("char value="+ch);

System.out.println("boolean value="+bl);


}

}

o/p:

byte value=127

short value=32767

int value=45673467

long value=9898981234

float value=123.56

double value=2345.67

char value=h

boolean value=true

========================================================

*imp

2.NonPrimitive datatypes:

=>The "Group valued data formats" are known as NonPrimitive

datatypes or Referential datatypes.

=>These NonPrimitive datatypes are categorized into four types:

(a)Class

(b)Interface

(c)Array

(d)Enum

==========================================================

faq:

define "String" datatype?

=>In Java,"String" is a Pre-defined class from JavaLib and which

is NonPrimitive datatype or Referential data type.




Note:

=>The string-data is represented in double quotes

Ex:

String city = "hyd";

String branch = "CSE";

String name = "Alex";

============================================================

Assignment:

wap to display UserDetails?

userName

passWord

firstName

lastName

hNo

sName

city

state

pinCode

mailId

phNo




=============================================================

Dt : 1/4/2023

Assignment:(Solution)

wap to display UserDetails?




Prog : UserDetails.java

class UserDetails

{

public static void main(String args[])

{

String userName="nit.v";

String passWord="mzu672";

String firstName="Raj";

String lastName="Kumar";

String hNo="12-34/h";

String sName="SR-Nagar";

String city="Hyd";

String state="TS";

int pinCode=612345;

String mailId="raj@gmail.com";

long phNo=9898981234L;

System.out.println("****UserDetails****");

System.out.println("UName="+userName);

System.out.println("PWord="+passWord);

System.out.println("FName="+firstName);

System.out.println("LName="+lastName);

System.out.println("HNO="+hNo);

System.out.println("StreetName="+sName);

System.out.println("City="+city);

System.out.println("State="+state);

System.out.println("PinCode="+pinCode);

System.out.println("MailId="+mailId);

System.out.println("PhoneNO="+phNo);

}

}

o/p:

****UserDetails****

UName=nit.v

PWord=mzu672

FName=Raj

LName=Kumar

HNO=12-34/h

StreetName=SR-Nagar

City=Hyd


State=TS

PinCode=612345

MailId=raj@gmail.com

PhoneNO=9898981234

=============================================================

faq:

wt is the diff b/w

(i)print()

(ii)println()




(i)print():

=>print() method will display the data and the cursor waits in

the same line.

(ii)println():

=>println() method also display the data,but the cursor moved

to the new line or next line.

=========================================================

Note:

=>"+" symbol in print() method will specify concatenating msg with

result.

=========================================================

Assignment:

wap to display CustomerDetails?

custId

accNo

custName

balance

accType

hNo

sName

city

state

pinCode

mailId

phNo

==========================================================

Dt : 3/4/2023

*imp

Object Oriented Programming:

=>The process of constructing programs using Class-Object concept

is known as Object Oriented Programming.

=>In Object Oriented programming we work with NonPrimitive

datatypes or Referential datatypes.

=>The following are the levels in Object Oriented Programming:

1.Object definition

2.Object creation

3.Object location

4.Object components

5.Object types

(a)User defined class objects

(b)String object

(c)WrapperClass objects

(d)Array Objects

(e)Collection<E> objects

(f)Map<K,V> objects

(g)Enum<E> Objects

6.Object Locking

7.Object Collection(Objects grouping)

8.Object Sorting

9.Object Serializable

10.Object Cloning

-----------------------------------------------------------

faq:

define Object?

=>Object is a storage related to a class holding members of class.

=>we use "new" keyword in Java to create objects.

syntax:

Class_name object_name = new Class_name();

========================================================

*imp

(a)Class:

=>Class is a "Structured Layout" generating Objects.

=>Classes in Java are categorized into two types:

(i)Pre-defined classes

(ii)User defined classes




(i)Pre-defined classes:

=>The classes which are ready constructed and available from

JavaLib are known as Pre-defined classes or Built-in classes.

Ex:

String

System




(ii)User defined classes:

=>The classes which are defined by the programmer are known as

User defined classes

Ex:

Display

Addition

DataTypes1

UserDetails

===============================================================

Note:

=>Classes are collection Variables,Methods,Blocks and

Constructors

===============================================================

*imp

Variables in Java:

=>Variables are the data holders in the program.

=>Based on datatypes in Java,the variables are categorized into

two types:

1.Primitive datatype variables

2.NonPrimitive datatype variables




1.Primitive datatype variables:

=>The variables which are declared with primitive datatypes like

byte,short,int,long,float,double,char,boolean are known as Primitive

datatype variables.

=>These primitive datatype variables will hold values.




2.NonPrimitive datatype variables:

=>The variables which are declared with NonPrimitive datatypes

like class,interface,array,enum are known as NonPrimitive datatype

variables or referential datatype variables.

=>These NonPrimitive datatype variables will hold Object

references or Object addresses.

---------------------------------------------------------

*imp

define "static" keyword?

=>"static" keyword in Java will decide the location of memory

for Programming Components.

static  - means memory in class

NonStatic - means memory in Object

===============================================================

*imp

=>Based on "static" keyword the variables in Java are categorized

into two types:

1.static variables

2.NonStatic variables




1.static variables:

=>The Variables which are declared with "static" keyword are

known as "static variables" or "Class variables".

=>These static variables will get the memory within the class

while class loading and can be accessed with class name.





2.NonStatic variables:

=>The variables which are declared without "static" keyword are

known as NonStatic variables.

=>These NonStatic variables are categorized into two types:

(a)Instance variables

(b)Local variables





(a)Instance variables:

=>The NonStatic variables which are declared outside the methods

are known as Instance variables or Object Variables.

=>These Instance variables will get the memory within the Object

while Object creatin process and can be accessed with Object_name.




(b)Local variables:

=>The NonStatic variables which are declared inside the methods

are known as Local variables.

=>These Local variables will get the memory within the method

while method execution.

=>These Local variables can be accessed directly inside the

methods.




Ex : DemoVariables.java

class DemoVariables

{

static int a=10;

int b=20;

public static void main(String args[])

{

int c=30;

System.out.println("a value="+DemoVariables.a);

DemoVariables ob = new DemoVariables();

System.out.println("b value="+ob.b);

System.out.println("c value="+c);

}

}

o/p:

value=10 b value=20 c value=30

==========================================================
5/20/23, 9:37 AM	6 PM CoreJava146-Dia8.png












































































https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all	1/1

Dt : 4/4/2023

*imp

Methods in Java:

=>Methods are the actions which are executed to generate results.

=>Based on "static" keyword the methods are categorized into

two types:

1.static methods

2.NonStatic methods




1.static methods:

=>The methods which are declared with "static" keyword are known

as static methods.

=>These static methods will get the memory within the class

while class loading and can be accessed with Class_name.




structure of "static" method:

static return type method name(para_list)


{

//method_body

}





Coding Rule:

=>Static methods can access static variables from the same class

directly,but cannot access Instance variables directly.

-------------------------------------

=>These static methods are categorized into two types:

(i)pre-defined static methods

(ii)User defined static methods




(i)pre-defined static methods:

=>The static methods which are ready constructed and available

from JavaLib are known as pre-defined static methods or Built-in

static methods.




(ii)User defined static methods:

=>The static methods which are defined by the programmer are

known as User defined static methods.

====================================================

2.NonStatic methods:

=>The methods which are declared without "static" keyword are

known as NonStatic methods.

=>These NonStatic methods are known as Instance methods,because

there are no Local methods.

=>These Instance methods will get the memory within the object

while Object creation process and can be accessed with Object_name.




structure of instance methods:




return_type method_name(para_list)

{

//method_body

}




Coding Rule:

=>Instance methods can access both "Instance variables and Static

variables" directly.

(Object generated from the class,which means object belongs to

class and members of Object can access members of class directly)

------------------------------------------------------

=>These Instance methods are categorized into two types:

(i)Pre-defined Instance methods

(ii)User defined Instance methods





(i)Pre-defined Instance methods:

=>The Instance methods which are ready constructed and available

from JavaLib are known as Pre-defined Instance methods or Built-in

Instance methods




(ii)User defined Instance methods:

=>The Instance methods which are defined by the programmer are

known as User defined Instance methods.

=========================================================

EX : DemoMethods1.java

class DemoMethods1

{

static int x=10;

int y=20;

static void dis1()

{

int z = 200;

System.out.println("****dis1()****");

System.out.println("x value="+x);

System.out.println("z value="+z);

}

void dis2()

{


int z=300;

System.out.println("****dis2()****");

System.out.println("x value="+x);

System.out.println("y value="+y);

System.out.println("z value="+z);

}

public static void main(String args[])

{

int z = 100;

DemoMethods1.dis1();

DemoMethods1 ob = new DemoMethods1();

ob.dis2();

System.out.println("****main()***");

System.out.println("z value="+z);

}

}




o/p:




****dis1()****

value=10 z value=200

****dis2()****

value=10

value=20 z value=300

****main()***

z value=100




=====================================================

Diagram:





































======================================================

Dt : 5/4/2023

Note:

=>Based on memory location the variables are categorized into

three types:

1.Class variables

2.Object variables

3.Method variables




1.Class variables:

=>static variables are known as Class variables,because the

variables will get the memory within the class.




2.Object variables:

=>Instance variables are known as Object variables,because the

variables will get the memory within the Object.




3.Method variables:

=>Local variables are known as Method variables,because the

variables will get the memory within the methods while method

execution.

==========================================================

faq:

define Global Variables?

=>There is no concept of Global variables in Java,because we

cannot declare variables outside the class.

============================================================

faq:

define Static local variables?

=>There is no concept of static local variables in Java,because

static variables means memory in class and cannot be a local

variables.(Compiler ambiguity)

============================================================

faq:

wt is the advantage of having static programming components memory

in Class?

=>The static programming components can be shared by multiple

objects generated from the class.

==============================================================

Assignment:

Construct the program for the following Layout:





===============================================================

*imp

define parameters?

=>parameters are the variables which are used to transfer the

data from one method to another method.

=>Based on parameters the methods are categorized into two types:

(i)Methods without parameters

(ii)Methods with parameters




(i)Methods without parameters:

=>The methods which are declared without parameters are known as

0-parameter methods or Methods without parameters.




(ii)Methods with parameters:

=>The methods which are declared with parameters are known as

parameterized methods or Methods with parameters.

==============================================================

*imp

define return type?


=>return type specify the methods will return the value after


method execution.

=>Based on return_type methods are categorized into two types:

(i)Non-return_type methods

(ii)return_type methods

(i)Non-return_type methods:

=>The methods which will not return any value after method

execution are known as Non-return_type methods.

=>The methods which are declared with "void" are known as

Non-return_type methods.




(ii)return_type methods :

=>The methods which return the value after method execution are

known as return_type methods.

=>The methods which are declared without "void" are known as

return_type methods.

=>we use "return" statement to return the value after method

execution

==============================================================
5/20/23, 9:39 AM	Methods2.png












































































https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all	1/1

Dt : 17/3/2023(Day-1)(Friday)

Course : Full Stack Java Developer




Modules:

1.Programming Module

(CoreJava,AdvJava,Spring)

2.UI Module

(HTML/CSS/JS - Anguler)

3.Database Module

(Oracle)

4.Testing Module

(Testing Basics - Selenium)

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM

(ii)Project

------------------------------------------------------------

Language:

(i)Alphabets

(ii)Grammer

(iii)Construction Rules




Note:

=>Every language will have its own Alphabets,Grammer and

Contruction Rules.

==================================================================

Java:

Part-1 : CoreJava

Part-2 : AdvJava




Part-1 : CoreJava

1.Programming Components(Java Alphabets)

2.Programming Concepts

3.Object Oriented Programming features




1.Programming Components(Java Alphabets)

(a)Variables

(b)Methods

(c)Blocks

(d)Constructors

(e)Classes

(f)Interfaces

(g)AbstractClasses




2.Programming Concepts

(a)Object Oriented Programming

(b)Exception handling

(c)Java Collection Framework(JCF)

(Data Structures in Java)

(d)Multi-Threading

(e)IO Streams and Files

(f)Networking in Java




3.Object Oriented Programming features

(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism

(f)Inheritance

------------------------------------------------------------------

Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava

=>AdvJava provides the following technologies to construct

WebApplications:

(a)JDBC

(b)Servlet

(c)JSP

faq:

define Web Applications?

=>The applications which are executed in Web-Environment or Internet

Environment are known as Web Applications.




Architecture of Web Application:




(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to

establish communication to DB-Product




(b)Servlet:

=>Servlet means "server program" and which accepts request from the

User.





(c)JSP:

=>JSP stands for "Java Server Page" and which is response from

WebApplications

===================================================================

Dt : 23/3/2023(day-3)

faq:

wt is the diff b/w

(i)Language

(ii)Technology

(iii)Framework




(i)Language:

=>Language will provide Components and Concepts used in

contructing programs.

Ex:

CoreJava




(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.

Ex:

AdvJava

(iii)Framework:

=>The structure which is ready for application development

is known as Framework.

Ex:

Spring,WebServices

================================================================

Summary:

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-2 : AdvJava ------------->WebApplications

Level-3 : Frameworks----------->Enterprise Applications

(Spring,WebServices)

==================================================================

faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs

actions in the same computer are known as Stand-Alone applications

or DeskTop Applications or Windows Applications.

=>Stand-Alone applications means,

No html input

No Server Environment

No Database storage

===============================================================

faq:

define Enterprise Applications?

=>The applications which are executing in distributed environment

and depending on the features like "Security","Load Balancing"

and "Clustering" are known as Enterprise applications or Enterprise

Distributed applications.

================================================================

Dt : 3/4/2023

*imp

Object Oriented Programming:

=>The process of constructing programs using Class-Object concept

is known as Object Oriented Programming.

=>In Object Oriented programming we work with NonPrimitive

datatypes or Referential datatypes.

=>The following are the levels in Object Oriented Programming:

1.Object definition

2.Object creation

3.Object location

4.Object components

5.Object types

(a)User defined class objects

(b)String object

(c)WrapperClass objects

(d)Array Objects

(e)Collection<E> objects

(f)Map<K,V> objects

(g)Enum<E> Objects

6.Object Locking

7.Object Collection(Objects grouping)

8.Object Sorting

9.Object Serializable

10.Object Cloning

-----------------------------------------------------------

faq:

define Object?

=>Object is a storage related to a class holding members of class.

=>we use "new" keyword in Java to create objects.

syntax:

Class_name object_name = new Class_name();

========================================================

*imp

(a)Class:

=>Class is a "Structured Layout" generating Objects.

=>Classes in Java are categorized into two types:

(i)Pre-defined classes

(ii)User defined classes




(i)Pre-defined classes:

=>The classes which are ready constructed and available from

JavaLib are known as Pre-defined classes or Built-in classes.

Ex:

String

System




(ii)User defined classes:

=>The classes which are defined by the programmer are known as

User defined classes

Ex:

Display

Addition

DataTypes1

UserDetails

===============================================================

Note:

=>Classes are collection Variables,Methods,Blocks and

Constructors

===============================================================

*imp

Variables in Java:

=>Variables are the data holders in the program.

=>Based on datatypes in Java,the variables are categorized into

two types:

1.Primitive datatype variables

2.NonPrimitive datatype variables




1.Primitive datatype variables:

=>The variables which are declared with primitive datatypes like

byte,short,int,long,float,double,char,boolean are known as Primitive

datatype variables.

=>These primitive datatype variables will hold values.




2.NonPrimitive datatype variables:

=>The variables which are declared with NonPrimitive datatypes

like class,interface,array,enum are known as NonPrimitive datatype

variables or referential datatype variables.

=>These NonPrimitive datatype variables will hold Object

references or Object addresses.

---------------------------------------------------------

*imp

define "static" keyword?

=>"static" keyword in Java will decide the location of memory

for Programming Components.

static  - means memory in class

NonStatic - means memory in Object

===============================================================

*imp

=>Based on "static" keyword the variables in Java are categorized

into two types:

1.static variables

2.NonStatic variables




1.static variables:

=>The Variables which are declared with "static" keyword are

known as "static variables" or "Class variables".

=>These static variables will get the memory within the class

while class loading and can be accessed with class name.





2.NonStatic variables:

=>The variables which are declared without "static" keyword are

known as NonStatic variables.

=>These NonStatic variables are categorized into two types:

(a)Instance variables

(b)Local variables





(a)Instance variables:

=>The NonStatic variables which are declared outside the methods

are known as Instance variables or Object Variables.

=>These Instance variables will get the memory within the Object

while Object creatin process and can be accessed with Object_name.




(b)Local variables:

=>The NonStatic variables which are declared inside the methods

are known as Local variables.

=>These Local variables will get the memory within the method

while method execution.

=>These Local variables can be accessed directly inside the

methods.




Ex : DemoVariables.java

class DemoVariables

{

static int a=10;

int b=20;

public static void main(String args[])

{

int c=30;

System.out.println("a value="+DemoVariables.a);

DemoVariables ob = new DemoVariables();

System.out.println("b value="+ob.b);

System.out.println("c value="+c);

}

}

o/p:

value=10 b value=20 c value=30

==========================================================

Dt : 5/4/2023

Note:

=>Based on memory location the variables are categorized into

three types:

1.Class variables

2.Object variables

3.Method variables




1.Class variables:

=>static variables are known as Class variables,because the

variables will get the memory within the class.




2.Object variables:

=>Instance variables are known as Object variables,because the

variables will get the memory within the Object.




3.Method variables:

=>Local variables are known as Method variables,because the

variables will get the memory within the methods while method

execution.

==========================================================

faq:

define Global Variables?

=>There is no concept of Global variables in Java,because we

cannot declare variables outside the class.

============================================================

faq:

define Static local variables?

=>There is no concept of static local variables in Java,because

static variables means memory in class and cannot be a local

variables.(Compiler ambiguity)

============================================================

faq:

wt is the advantage of having static programming components memory

in Class?

=>The static programming components can be shared by multiple

objects generated from the class.

==============================================================

Assignment:

Construct the program for the following Layout:





===============================================================

*imp

define parameters?

=>parameters are the variables which are used to transfer the

data from one method to another method.

=>Based on parameters the methods are categorized into two types:

(i)Methods without parameters

(ii)Methods with parameters




(i)Methods without parameters:

=>The methods which are declared without parameters are known as

0-parameter methods or Methods without parameters.




(ii)Methods with parameters:

=>The methods which are declared with parameters are known as

parameterized methods or Methods with parameters.

==============================================================

*imp

define return type?


=>return type specify the methods will return the value after


method execution.

=>Based on return_type methods are categorized into two types:

(i)Non-return_type methods

(ii)return_type methods

(i)Non-return_type methods:

=>The methods which will not return any value after method

execution are known as Non-return_type methods.

=>The methods which are declared with "void" are known as

Non-return_type methods.




(ii)return_type methods :

=>The methods which return the value after method execution are

known as return_type methods.

=>The methods which are declared without "void" are known as

return_type methods.

=>we use "return" statement to return the value after method

execution

==============================================================

dt : 24/3/2023(Day-4)(Syllabus)

*imp

define Program?

=>Program is a set-of-Instructions




define Programming?

=>The process of constructing programs is known as Programming.




Note:

=>After writing programs,we save the programs with language

extentions

Test.c

Test.cpp

Test.java

=>After writing and saving the programs,the programs will have

the following two stages:

1.Compilation

2.Execution





1.Compilation:

=>The process of checking the program constructed according to

the rules of language or not,is known as Compilation process.

=>If the Compilation process is successfull,then sourceCode is

converted into Compiled code.

=>c and c++ languages generate "Objective Code" and JavaLang

generate "Byte Code",after Compilation process.




2.Execution:

=>The process of running compiled codes and checking the required

output is generated or not,is known as Execution process.

=>In C and c++ languages,the Objective Code is converted into

Executable code after loading and linking process,and generate

result.

=>In JavaLang,the ByteCode is executed on JVM(Java Virtual Machine)




Diagram:

=================================================

faq:

define Loading process?

=>The process of loading the required components into current

running program is known as "Loading process".

=>This loding process is performed using internal Loaders.





faq:

define Linking process?

=>The process of linking the loaded components into current running

program where they are needed,is known as "Linking Process".

=>This Linking process is performed using internal Linkers.

===========================================================

faq:

wt is the diff b/w

(a)Objective Code

(b)Byte Code




(a)Objective Code:

=>The Compiled code generated from c and c++ programs is known

as Objective Code.

=>while Objective Code generation,OperatingSystem is participated

and,because if this reason Objective code is PlatForm dependent

code.




DisAdvantage:

=>The Objective Code which is generated from one PlatForm cannot

be executed on other PlatForms.





Note:

=>C and c++ languages which are generating Objective Code are

Platform dependent languages.




(b)Byte Code:

=>The Compiled code generated from JavaPrograms is known as

ByteCode.

=>While ByteCode generation,OperatingSystem is not participated

and,because of this reason ByteCode is PlatForm independent code




Advantage:

=>The ByteCode which is generated from one PlatForm can be

executed on all PlatForms based on JVM.




Note:

=>The JavaLang which is generating ByteCode is PlatForm

independent language.




Diagram:

=============================================================

Dt:27/3/2023

faq:

wt is the diff b/w

1.JDK

2.JRE

3.JVM




1.JDK:

=>JDK stands for "Java Development Kit" and which is collection

of the following:

(i)Java Compiler

(ii)Java Library

(iii)JVM




Diagram:































(i)Java Compiler:

=>Java Compiler will compile the source code and if the

compilation Process is successfull then Byte code is generated.

(Java Compiler will compile the Source code and generate Byte code)




(ii)Java Library:

=>Java Library will provide pre-defined ready constructed

components which are used in application development.




(iii)JVM:

=>JVM stands for "Java Virtual Machine" and which is used to

execute Java Byte Code.

---------------------------------------------------------

2.JRE:

=>JRE stands for "Java Runtime Environment" and which is collection

of JavaLib and JVM.

=>JRE is internal partition of JDK.

------------------------------------------------------------

3.JVM:

=>JVM will execute Java Byte Code.

========================================================

faq:

define Virtual Machine?

=>The s/w component which internally having the behaviour like

machine is knonw as Virtual Machine.

=========================================================

Dt : 29/3/2023

Executing Java Program:




step-1 : Create one folder in any drive

D:\Demo146




step-2 : Open notepad and type the program




step-3 : Save the program in folder with language extention

syntax:

Class_name.java

Ex:

Display.java




To save the program,click on File->Save->Browse the folder->

name the file as "Display.java"->save as type must be "All files"->

click "Save".




Note:

=>Open CommandPrompt to perform Compilation and execution process

=>To open CommandPrompt->goto folder->type "cmd" in AddressBar and

press enter.


step-4 : Compile the program as follows

syntax:

javac Class_name.java

Ex:

javac Display.java




step-5 : Execute the program as follows

syntax:

java Class_name

Ex:

java Display

================================================================

Ex-2 :

wap to add two numbers and display the result?




class Addition

{

public static void main(String args[])

{


int a=11,b=12;

int c = a+b;

System.out.println("a value="+a);

System.out.println("b value="+b);

System.out.print("c value="+c);

}

}




o/p:

value=11 b value=12 c value=23

=======================================================

Assignment-1:

wap to display the following: int empId

int empPhNo int empSal

float totSal = empSal+(0.93F*empSal)+(0.63F*empSal);




Assignment-2:

wap to display the following:

int s1

int s2

...

int s6

int totMarks =

float per =

========================================================

Dt : 31/3/2023

*imp

DataTypes in Java:

=>The types of data which we are expecting as input to

JavaPrograms are known as Datatypes in Java.

=>Datatypes in Java are categorized into two types:

1.Primitive datatypes

2.NonPrimitive datatypes




1.Primitive datatypes:

=>The "Single valued data formats" are known as Primitive

datatypes.

=>Primitive datatypes are categorized into four types:

(a)Integer datatypes

(b)Float datatypes

(c)Character datatype

(d)Boolean datatype




(a)Integer datatypes:

=>The numeric data without decimal point representation are

known as Integer datatypes.

=>Integer datatypes are categorized into four types:

(i)byte  - 1 byte(8 bits)

(ii)short - 2 bytes

(iii)int - 4 bytes

(iv)long - 8 bytes

=>"byte" and "short" datatypes are used for stream-data or

Multi-media data.

=>"int" datatype is used in normal programming.

=>"long" datatype is used to hold lagest numeric value without

decimal point,which means holding PhoneNO,CardNo,...

=>In the process of assigning long-data-value we must use "L"

(or) "l" in the RHS of declaration.

Ex:

long p = 9898981234L;




(b)Float datatypes:

=>The numeric data with decimal point representation are known

as Float datatypes.

=>Float datatypes are categorized into two types:

(i)float  - 4 bytes

(ii)double - 8 bytes

=>"float" datatype is used in normal programming.

=>"double" datatype is used to hold lagest scientic calculated

values

=>In the process of assigning float-data-value we must use "F"

(or) "f" in the RHS of declaration.

Ex:

float k = 123.56F;




(c)Character datatype:

=>The "single valued character" which is represented in single

quotes is known as Character datatype.

Ex:

'h','y','k',...

=>Types:

char - 2 bytes




(d)Boolean datatype:

=>The datatype which is represented in the form of true or false

is known as Boolean datatype.

=>Types:

boolean - 1 bit

---------------------------------------------

Ex-program:

DataTypes1.java

class DataTypes1

{

public static void main(String args[])

{

byte b = 127;

short s = 32767;

int i = 45673467;

long p = 9898981234L;

float k = 123.56F;

double z = 2345.67;

char ch = 'h';

boolean bl = true;

System.out.println("byte value="+b);

System.out.println("short value="+s);

System.out.println("int value="+i);

System.out.println("long value="+p);

System.out.println("float value="+k);

System.out.println("double value="+z);

System.out.println("char value="+ch);

System.out.println("boolean value="+bl);


}

}

o/p:

byte value=127

short value=32767

int value=45673467

long value=9898981234

float value=123.56

double value=2345.67

char value=h

boolean value=true

========================================================

*imp

2.NonPrimitive datatypes:

=>The "Group valued data formats" are known as NonPrimitive

datatypes or Referential datatypes.

=>These NonPrimitive datatypes are categorized into four types:

(a)Class

(b)Interface

(c)Array

(d)Enum

==========================================================

faq:

define "String" datatype?

=>In Java,"String" is a Pre-defined class from JavaLib and which

is NonPrimitive datatype or Referential data type.




Note:

=>The string-data is represented in double quotes

Ex:

String city = "hyd";

String branch = "CSE";

String name = "Alex";

============================================================

Assignment:

wap to display UserDetails?

userName

passWord

firstName

lastName

hNo

sName

city

state

pinCode

mailId

phNo




=============================================================

Dt : 1/4/2023

Assignment:(Solution)

wap to display UserDetails?




Prog : UserDetails.java

class UserDetails

{

public static void main(String args[])

{

String userName="nit.v";

String passWord="mzu672";

String firstName="Raj";

String lastName="Kumar";

String hNo="12-34/h";

String sName="SR-Nagar";

String city="Hyd";

String state="TS";

int pinCode=612345;

String mailId="raj@gmail.com";

long phNo=9898981234L;

System.out.println("****UserDetails****");

System.out.println("UName="+userName);

System.out.println("PWord="+passWord);

System.out.println("FName="+firstName);

System.out.println("LName="+lastName);

System.out.println("HNO="+hNo);

System.out.println("StreetName="+sName);

System.out.println("City="+city);

System.out.println("State="+state);

System.out.println("PinCode="+pinCode);

System.out.println("MailId="+mailId);

System.out.println("PhoneNO="+phNo);

}

}

o/p:

****UserDetails****

UName=nit.v

PWord=mzu672

FName=Raj

LName=Kumar

HNO=12-34/h

StreetName=SR-Nagar

City=Hyd


State=TS

PinCode=612345

MailId=raj@gmail.com

PhoneNO=9898981234

=============================================================

faq:

wt is the diff b/w

(i)print()

(ii)println()




(i)print():

=>print() method will display the data and the cursor waits in

the same line.

(ii)println():

=>println() method also display the data,but the cursor moved

to the new line or next line.

=========================================================

Note:

=>"+" symbol in print() method will specify concatenating msg with

result.

=========================================================

Assignment:

wap to display CustomerDetails?

custId

accNo

custName

balance

accType

hNo

sName

city

state

pinCode

mailId

phNo

==========================================================

Dt : 4/4/2023

*imp

Methods in Java:

=>Methods are the actions which are executed to generate results.

=>Based on "static" keyword the methods are categorized into

two types:

1.static methods

2.NonStatic methods




1.static methods:

=>The methods which are declared with "static" keyword are known

as static methods.

=>These static methods will get the memory within the class

while class loading and can be accessed with Class_name.




structure of "static" method:

static return type method name(para_list)


{

//method_body

}





Coding Rule:

=>Static methods can access static variables from the same class

directly,but cannot access Instance variables directly.

-------------------------------------

=>These static methods are categorized into two types:

(i)pre-defined static methods

(ii)User defined static methods




(i)pre-defined static methods:

=>The static methods which are ready constructed and available

from JavaLib are known as pre-defined static methods or Built-in

static methods.




(ii)User defined static methods:

=>The static methods which are defined by the programmer are

known as User defined static methods.

====================================================

2.NonStatic methods:

=>The methods which are declared without "static" keyword are

known as NonStatic methods.

=>These NonStatic methods are known as Instance methods,because

there are no Local methods.

=>These Instance methods will get the memory within the object

while Object creation process and can be accessed with Object_name.




structure of instance methods:




return_type method_name(para_list)

{

//method_body

}




Coding Rule:

=>Instance methods can access both "Instance variables and Static

variables" directly.

(Object generated from the class,which means object belongs to

class and members of Object can access members of class directly)

------------------------------------------------------

=>These Instance methods are categorized into two types:

(i)Pre-defined Instance methods

(ii)User defined Instance methods





(i)Pre-defined Instance methods:

=>The Instance methods which are ready constructed and available

from JavaLib are known as Pre-defined Instance methods or Built-in

Instance methods




(ii)User defined Instance methods:

=>The Instance methods which are defined by the programmer are

known as User defined Instance methods.

=========================================================

EX : DemoMethods1.java

class DemoMethods1

{

static int x=10;

int y=20;

static void dis1()

{

int z = 200;

System.out.println("****dis1()****");

System.out.println("x value="+x);

System.out.println("z value="+z);

}

void dis2()

{


int z=300;

System.out.println("****dis2()****");

System.out.println("x value="+x);

System.out.println("y value="+y);

System.out.println("z value="+z);

}

public static void main(String args[])

{

int z = 100;

DemoMethods1.dis1();

DemoMethods1 ob = new DemoMethods1();

ob.dis2();

System.out.println("****main()***");

System.out.println("z value="+z);

}

}




o/p:




****dis1()****

value=10 z value=200

****dis2()****

value=10

value=20 z value=300

****main()***

z value=100




=====================================================

Diagram:





































======================================================

Dt:6/4/2023

Assignment : (Solution)

EmployeeData.java

class EmployeeData

{

static String id="A121",name="Alex",desg="SE";

String mailId="alex@gmail.com";

long phNo=9898981234L;

static void dis1()

{

System.out.println("---details---- ");

System.out.println("EmpId="+id);

System.out.println("EmpName="+name);

System.out.println("EmpDesg="+desg);

}

void dis2()

{

System.out.println("----ContactDetails----");

System.out.println("EmpMailId="+mailId);

System.out.println("EmpPhoneNo="+phNo);


}

public static void main(String[] args)

{

EmployeeData.dis1();

EmployeeData ob = new EmployeeData();

ob.dis2();

}

}

o/p:

---details----

EmpId=A121

EmpName=Alex

EmpDesg=SE

----ContactDetails----

EmpMailId=alex@gmail.com

EmpPhoneNo=9898981234

==========================================================

Note:

=>In the process of costructing applications in Java,we write

SubClasses and MainClass

SubClasses - The classes which are declared in applications

other than MainClass are known as SubClases

Applications can be declared with any number of SubClasses

MainClass - The class in the application which is declared

with main() method is known as MainClass.

Application must be declared with only one MainClass













































=============================================================

*imp

"Scanner" class:

=>"Scanner" is a Pre-defined Built-in class from "util"(utility)

package of JavaLib.

=>"Scanner" class will provide pre-defined Built-in instance

methods to read data into JavaProgram.

=>The following are some important instance methods of "Scanner"

class:

nextByte()  - to read byte data

nextShort() - to read short data

nextInt()	- to read int data

nextLong()  - to read long data

nextFloat() - to read float data

nextDouble() - to read double data

nextBoolean()- to read boolean data

nextLine()  - to read String data

=>To access these instance methods,we must create object for

"Scanner" class.

syntax of Object creation for Scanner:

Scanner s = new Scanner(System.in);

=>"System.in" in java represent connecting Console-input to Scanner

class Object.

-----------------------------------------------------

Ex-program:

wap to read two integer values and display the average?




Prog : DemoMethods2.java(MainClass)

import java.util.Scanner;

class Average

{

float avg(int x,int y)

{

float z = (float)(x+y)/2;

return z;

}

}

class DemoMethods2

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

Average ob = new Average();

System.out.println("Enter the int value-1:");

int v1 = s.nextInt();

System.out.println("Enter the int value-2:");

int v2 = s.nextInt();

float res=ob.avg(v1,v2);

System.out.println("Average="+res);

}

}

o/p:

Enter the int value-1:

7

Enter the int value-2:

2

Average=4.5

======================================================


Dt : 25/3/2023(Day-5)

faq:

define High Level Languages?

=>The language programs which are constructed from the format

which is understandable by the users,are known as High Level

languages

Ex:

C,C++,Java




faq:

define Low Level Languages?

=>The Language programs which are constructed from the format

which is not understandable by the users,are known as Low Level

Languages.

Ex:

Machine Languages




faq:

define Translators?

=>Translators are used to translate High Level Language formats

into Low Level Language formats and Low Level Language formats into

High Level Language formats

=>These Translators are categorized into two types:

(i)Compilers	- translates the total program at-a-time

(ii)Interpreters - translates the program line-by-line














































==============================================================

*imp

History of Java:

"James Gosling" - Sun Micro Systems - 1991 - Code Writer(Programmer)


WORA - Write Once and Run Anywhere

Virtual Machine




Test.gt (Green Talk)




OAK




"SILK" "DNA" ... "JAVA"




1995

--------------------------------------------------

Java Versions:



2011 - Java7

2014 - Java8

2017 - Java9

2018 - Java10,Java11

2019 - Java12,Java13

2020 - Java14,Java15

2021 - Java16,Java17

2022 - Java18,Java19

2023 - Java20(March 21st)

=====================================================

LTS(Long Term Support) products:

Java8

Java11

Java17

======================================================

Dt : 28/3/2023

*imp

Installing Java s/w and Setting path:




step-1 : Download Java s/w(JDK) from Oracle WebSite




https://www.oracle.com/in/java/technologies/downloads/







step-2 : Install JDK(Java s/w)




Note:

=>After installation process is successfull,we can find one

folder with name "java" in "programfiles"

C:\Program Files\Java




step-3 : Set Java path in "Environment Variables"




RightClick on MyComputer->Properties->Advanced System Settings->

Environment Variables->Click "new" from System Variables,





Variable name	: path

Variable value  : C:\Program Files\Java\jdk-17.0.4.1\bin;




step-4 : Click "ok" for three times

===========================================================

Note:

=>Open CommandPrompt and check the following commands are working



=============================================================

Note:

=>Use the following syntax in CommandPrompt to know the Version

available in ComputerSystem:

java -version

============================================================

*imp

Writing,Saving,Compiling and Executing Java program:

=>In Java language writing program means constructing "class".





define "class"?

=>class in Java is a "Structured layout" generating "Objects".

=>Class in Java is a Collection of Variables,Methods,Blocks,

Constructors and main()

=>we use "class" keyword in Java to construct Classes




structure of "class" in Java:




class Class_name

{

Variables

Methods

Blocks

Constructors

main()

}




=>main() in Java will have the following pre-defined built-in

format:




public static void main(String args[])

--------------------------------------------------------

Ex-program :

Wap to display the msg as "Welcome to Java"?

class Display

{

public static void main(String args[])

{

System.out.print("Welcome to Java");

}

}

=======================================================


Dt : 30/3/2023

faq:

define Environment Variables?

=>The variables part of OperatingSystem holding information about softwares

installed in ComputerSystem are known as "Environment Variables"

=>These Environment Variables are categorized into two types:

(i)User Variables

(ii)System Variables




(i)User Variables:

=>The variables which are related to individual users of ComputerSystem

are known as User Variables.

=>The information available in User variables can be used by only the

indvidual User.




(ii)System Variables:

=>The variables which are related to ComputerSystem are known as System

Variables.

=>The information available in System Variables can be used by all users

of ComputerSystem.

===================================================================

===

faq:

wt is the advantage of having JavaPath in Environment Variables?

=>When we have JavaPath in Environment Variables,then we can Compile and

Execute Java Programs from any location of ComputerSystem.

===================================================================

====

Diagram:




























===================================================================

====

Flow of Syllabus Content:

1.Naming Conventions in Java

2.Datatypes in Java

3.Variables in Java

4.Methods in Java

5.JVM Architecture with internals

6.Constructors in Java

7.Blocks in Java

8.Packages in Java

9.Creating Java Project using IDE

10.Relations in Java(Introduction)

11.References in Java

12.Inheritance in Java

13.Interfaces in Java

14.AbstractClasses in Java

15.InnerClasses in Java

16.PolyMorphism in Java

17.Conclusion of Object Oriented features

(Abstraction and Encapsulation)

18.Exception Handling in Java

19.String in Java

20.WrapperClasses in Java

21.Arrays in Java

22.Java Collection Framework

(Data structures in Java)

23.Enum in Java

24.MultiThreading in Java

25.IO Streams and Files in Java

26.Networking in Java

27.Introduction GUI Programming

28.Object Class(Object Cloning)

29.Conclusion

======================================================

*imp

Naming Conventions in Java:

=>The rules followed by the programmer in writing Java Programs are

known as Naming Conventions in Java.




packages :

def : packages are collection of "Classes and Interfaces".

rule : packages must be in LowerCase.




Classes and Interfaces:

def : Classes and Interfaces are collection of "Variables and Methods"

rule : In Classes and Interfaces the starting letter of every word must

be Capital letter or UpperCase.


Ex:

InputStream

InputStreamReader




Variables and Methods:

def : Variables are data holders and Methods are actions

rule : In Variables and Methods the first word must be lowercase and

from second word onwards the starting letter must be capital

Ex-Variables:

panCardNo

rollNo

Ex-Methods:

getSalary()

calculateTot()




Keywords :

def : Pre-defined Built-in words are known as Keywords

rule : Keywords must be LowerCase

Ex:

static

void

public

class

...

===================================================================

==

faq:

define Identifiers?

=>The names which are used to identify the programming components are

known as Identifiers.

===================================================================

=
5/20/23, 9:44 AM	6 PM CoreJava145-Dia1.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:45 AM	6 PM CoreJava146-Dia3.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:46 AM	6 PM CoreJava146-Dia5.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:46 AM	6 PM CoreJava146-Dia7.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:47 AM	Methods1.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:47 AM	Methods3.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:48 AM	6 PM CoreJava146-Dia2.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:48 AM	6 PM CoreJava146-Dia4.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:49 AM	6 PM CoreJava146-Dia8.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1
5/20/23, 9:49 AM	Methods2.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details	1/1

Dt : 7/4/2023

*imp

JVM Architecture with Internals:

=>JVM stands for "Java Virtual Machine" and which is used to

execute Java Byte Code.

=>This JVM internally divided into the following partitions:

1.Class Loader SubSystem

2.Runtime DataArea

3.Execution Engine




Diagram:




















































1.Class Loader SubSystem:

=>The Class Loader SubSystem will load the Class-file onto

Runtime Data Area for execution.

2.Runtime DataArea:

=>This Runtime DataArea internally divided into the following

partitions:

(a)Method Area

(b)Heap Area

(c)Java Stack Area

(d)PC Register Area

(e)Native Method Area







(a)Method Area:

=>The partition of Runtime DataArea where classes are loaded

is known as Method Area.

=>Static members of class will get the memory within the class

while Class loading.

=>when MainClass is loaded,main() method will get the memory

within the class and automatically copied onto Java Stack

Area to start execution process.





(b)Heap Area:

=>The patition of Runtime DataArea where the Objects are created

is known as Heap Area.

=>while Object creation,Instance members of class will get the

memory within the object.




(c)Java Stack Area:

=>The partition of Runtime DataArea where the methods are

executed is known as Java Stack Area.

=>The main() method is copied onto Java Stack Area first and

starts the execution process,and this main() method will call

remaining methods for execution.




Execution flow of DemoMethods2.java:












































========================================================

Assignment:

wap to read two integer values and display greater value?




SubClass : Greater

=>int generate(int x,int y)

MainClass: DemoMethods3




Note:

=>Draw the execution flow

===================================================

Dt : 8/4/2023

faq:

wt is the diff b/w

(i)Object

(ii)Object reference

(iii)Object reference Variable




(i)Object:

=>The memory which is created part of HeapArea is known as

Object.




(ii)Object reference:

=>The address of object is known as Object reference.




(iii)Object reference Variable:

=>The variable which is holding Object reference is known as

Object reference variable or Object name.




Diagrams:





















======================================================

define Object?(revised)

=>Object is a storage related to a class created in Heap Area of

JVM holding instance members of class.

========================================================

faq:

define Method Frame?

=>The partition of Java Stack Area where method is copied for

execution is known as Method Frame.

=>After method execution completed,the method frame will be

destroyed automatically.

=======================================================

Note:

List of variables from the above application:

Primitive datatype variables	: v1,v2,res,x,y,z

NonPrimitive datatype variables : s,ob




All variables declared in the application are Local variables:

avg() - x,y,z

main() - s,ob,v1,v2,res




List of parameters : v1,v2,x,y




Types of parameters:

=>Parameters are categorized into two types:

(i)Actual Parameters

(ii)Formal Parameters




(i)Actual Parameters:

=>The variables which hold original input data and used in

method call are known as Actual Parameters.




(ii)Formal Parameters:

=>The variables which hold intermediate data and used in method

signatures are known as Formal parameters.

=>These Formal parameters are used in calculations.

Note:

=>we can take same names in Actual parameters and formal

parameters

=>All parameters are variables,but all variables are not

parameters

===========================================================

Assignment:

wap to read 6 sub marks and display the percentage?




SubClass : Percentage

=>float calculate(int totMarks)




MainClass : DemoMethods4

===========================================================

Dt : 10/4/2023

*imp

Operators in Java:

=>Operators are the special symbols which perform operations.

=>The following are some important operators in Java:

1.Arithmetic Operators

2.Relational Operator

3.Logical Operators

4.Increment-Decrement Operators




1.Arithmetic Operators:

=>The operators which perform basic operations are known as

Arithmetic Operators.




Operator Meaning

Addition

Subtraction

Multiplication / Division

%   ModDivision





Ex:

a=7 b=2

a+b = 7+2 = 9

a-b = 7-2 = 5

a*b = 7*2 = 14

a/b = 7/2 = 3

a%b = 7%2 = 1




2.Relational Operator:

=>The operators which are used to perform comparisions are known

as Reational Operators.




Operator  Meaning

Greater Than

>=	Greater Than or equal to

Less Than

<=	Less Than or equal to

Is equal to

!=	Not Equal to





3.Logical Operators:

=>The operators which are used to compare two comparisions are

known as Logical Operators.


Operator  Meaning

Logical AND

|| Logical OR ! Logical NoT


A  B  A&&B

T  T	T

F  T	F

T  F	F

F  F	F




A  B  A||B

T  T	T

F  T	T

T  F	T

F  F	F





!A

T F F T

4.Increment-Decrement Operators:

=>Increment Operators will increment the value by 1 and decrement

operators will decrement the value by 1.




Operator  Meaning

Increment -- Decrement

============================================================

*imp

Control Structures in Java:

=>The structures whih decide the execution-flow of program are

known as Control Structures.

=>These Control Structures are categorized into three types:

1.Selection statements

2.Iterative statements

3.Branching Statements




1.Selection statements:

=>The statements which are used to select one part of the program

for execution are known as Selection Statements or Conditional

Statements.

=>Types:

(a)Simple if

(b)if-else

(c)Nested if(Inner if)

(d)Ladder if-else

(e)switch-case




2.Iterative statements:

=>The statements which are used to execute some lines of program

repeatedly are known as Iterative Statements or Repeatitive

statements or looping Structures.

=>Types:

(a)while loop

(b)do-while loop

(c)for loop




3.Branching Statements:

=>The statements which are used to transfer the execution control

from one location to another location are known as Branching

Statements or Transfer Statements

=>Types:

(a)break

(b)continue

(c)return

(d)exit

Note:

=>"goto" not available in Java

================================================================

Assignment:(Solution)

wap to read two integer values and display greater value?

SubClass : Greater

=>int generate(int x,int y)

MainClass: DemoMethods3

import java.util.Scanner;

class Greater

{

int generate(int x,int y)

{

if(x>y)

{

return x;

}

else

{


return y;

}

}

}

class DemoMethods3

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter int value-1:");

int v1 = s.nextInt();

System.out.println("Enter int value-2:");

int v2 = s.nextInt();

Greater gt = new Greater();

int res = gt.generate(v1,v2);

System.out.println("GreaterValue:"+res);

}

}

o/p:

Enter int value-1:

123

Enter int value-2:

120

GreaterValue:123

===================================================

Ex-program:

wap to read two integer values and perform arithmetic operation

based on User Choice?

1.add

2.sub

3.mul

4.div

5.modDiv




Program : DemoMethods5.java

import java.util.Scanner;

class Addition

{

int add(int x,int y)

{

return x+y;

}


}

class Subtraction

{

int sub(int x,int y)

{

return x-y;

}

}

class Multiplication

{

int mul(int x,int y)

{

return x*y;

}

}

class Division

{

float div(int x,int y)

{

return (float)x/y;

}

}

class ModDivision

{


int modDiv(int x,int y)

{

return x%y;

}

}

class DemoMethods5

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter int value-1:");

int v1 = s.nextInt();

System.out.println("Enter int value-2:");

int v2 = s.nextInt();

System.out.println("*****Choice****");



System.out.println("\t1.add\n\t2.sub\n\t3.mul\n\t4.div\n\t5.modDiv");

System.out.println("Enter the Choice:");

int choice = s.nextInt();

switch(choice)

{


case 1:

Addition ad = new Addition();

int r1 = ad.add(v1,v2);

System.out.println("Sum:"+r1);

break;

case 2:

Subtraction sb = new Subtraction();

int r2 = sb.sub(v1,v2);

System.out.println("Sub:"+r2);

break;

case 3:

Multiplication ml = new Multiplication();

int r3 = ml.mul(v1,v2);

System.out.println("Mul:"+r3);

break;

case 4:

Division dv = new Division();

float r4 = dv.div(v1,v2);

System.out.println("Div:"+r4);

break;

case 5:

ModDivision md = new ModDivision();

int r5 = md.modDiv(v1,v2);

System.out.println("ModDiv:"+r5);

break;

default:

System.out.println("Invalid Choice...");

}//end of switch

}

}



















o/p:

Enter int value-1:

7

Enter int value-2:

2

*****Choice****

1.add

2.sub

3.mul

4.div

5.modDiv

Enter the Choice:

5

ModDiv:1

====================================================

ASSIGNMENT-1

Program-1
Define a method which returns the 1 if the given number is even, in other case return 0
Name of method: isEven() // which accepts an integer value as argument and return 1 if the
given number is even, else retrun 0.
Argument: int
Return type: an integer value
Example, if x = 22, return 1. if x = 35, return 0

Program-2
Define a method which returns the greatest number among two numbers.
Write the method with the following specifications:
Name of method: getGreatest() // which accepts two integer values as argument and return the greatest value.
Arguments: two argument of type integer
Return type: an integer value
Specifications: The value returned by the method getGreatest() is determined by the following rules:
If any of the given numbers are negative, return -1.
If any of the given numbers are zero, return -2.
If the given numbers are positive, return the greatest.

Program-3
Define a method which returns the least number among two numbers.
Write the method with the following specifications:
Name of method: getLeastNum() // which accepts two integer values as argument and return the least value.
Arguments: two argument of type integer
Return type: an integer value
Specifications: The value returned by the method getLeastNum() is determined by the following rules:

If any of the given numbers are negative, return -1.
If any of the given numbers are zero, return -2.
If the given numbers are positive, return the least number.

Program-4
Define a method which returns the number it if it is an even number, if the number is odd then return the next multiple of 10.
Write the method with the following specifications:
Name of method: oddRounder() // which accepts an integer value as argument and return
the same value if it is an even number, if the value is odd then return the next multiple of 10.
Arguments: one argument of type integer
Return Type: an integer value
Example if x = 24 then return 24, if x = 25 then return 30.
Specifications: The value returned by the method oddRounder() is determined by the following rules:

If any of the given number is negative, return -1.

If any of the given number is zero, return -2.
If the given number is even, return the same number.
If the given number is odd, return the next multiple of 10.


Program-5

Define a method which returns the 1 if the given number is positive, return -1 if the given
number is negative, return 0 if the given number is 0.
Name of method findSign()
Arguments: one argument of type integer
Return Type: an integer value
Test Cases
If any of the given number is positive, return 1.
If any of the given number is negative, return -1.
If any of the given number is zero, return 0.

Dt : 11/4/2023

faq:

define switch-case statement?

=>switch-case statement is used to select one from multiple

options or cases




syntax:

switch(value)

{

case 1 : statements;

break;

case 2 : statements;

break;

...

case n : statements;

break;

default : statements;

}





EXecution behaviour:

=>switch-value is compared with the available options or cases

and,if any case matched with switch-value then the statements are

executed.

=>After executing statements the switch-case execution is stopped

using "break".

============================================================

Assignment:

wap to read two integer values and perform the following based on

User-choice:

1.GreaterValue

2.SmallerValue




SubClasses : GreaterValue,SmallerValue

MainClass : DemoMethods

==============================================================

*imp

Iterative Statements:

(a)while loop

(b)do-while loop

(c)for loop





(a)while loop:

=>In while looping structure the condition is checked first and

if the condition is true then loop_body is executed,this process is

repeated until the condition is false.




syntax:

while(condition)

{

//loop_body

}




Flowchart:


Assignment:(Solution)

wap to read 6 sub marks and display the percentage?




SubClass : Percentage

=>float calculate(int totMarks)




MainClass : DemoMethods4

import java.util.Scanner;

class Percentage

{

float calculate(int totMarks)

{

return (float)totMarks/6;

}

}

class DemoMethods4

{

public static void main(String[] args)

{


Scanner s = new Scanner(System.in);

int i=1,totM=0;

while(i<=6)

{

System.out.println("Enter Marks of Subject-"+i);

int sub = s.nextInt();

if(sub<0 || sub>100)

{

System.out.println("Invalid Marks...");

continue;//skip the below lines from the iteration

}

totM = totM+sub;

System.out.println("subject:"+sub);

i++;

}//end of loop

System.out.println("TotalMarks:"+totM);

Percentage pr = new Percentage();

float per = pr.calculate(totM);

System.out.println("Percentage:"+per);

}

}








o/p:

Enter Marks of Subject-1

90

subject:90

Enter Marks of Subject-2

150

Invalid Marks...

Enter Marks of Subject-2

50

subject:50

Enter Marks of Subject-3

-12

Invalid Marks...

Enter Marks of Subject-3

67

subject:67

Enter Marks of Subject-4

53

subject:53

Enter Marks of Subject-5

89

subject:89

Enter Marks of Subject-6

90

subject:90

TotalMarks:439

Percentage:73.166664

===========================================================

Assignment:

Update above program by display the grade of an Student?




per=>

70 to 100 ---- Grade-A

60 to <70 ---- Grade-B

50 to <60 ---- Grade-C

35 to <50 ---- Grade-D

else ---- Fail

SubClass : Grade

=>String gr(float per)




Note:

=>If any Sub Marks enterted in b/w 0 to 34,then Grade must be

"Fail"

=============================================================

(b)do-while loop:

=>In do-while looping Structure,the loop_body is executed first

and then the Condition is checked,this process is repeated until

the condition is false.




syntax:

do

{

//loop_body

}

while(condition);




Flowchart:















































==========================================================

*imp

(c)for loop:

=>for-loop is more simple in representation when compared to

while and do-while loops,because Initialization,Condition and

Increment or Decrement declared in the same line.


syntax:

for(Initialization;Condition;Incre/Decre)

{

//Loop_body

}




Flowchart:







































============================================================


Dt : 12/4/2023

Assignment:(Solution)

wap to read two integer values and perform the following based on

User-choice:

1.GreaterValue

2.SmallerValue




SubClasses : GreaterValue,SmallerValue

MainClass : DemoMethods6

import java.util.Scanner;

class GreaterValue

{

int greater(int x,int y)

{

if(x>y)

{

return x;

}

else

{

return y;


}

}

}

class SmallerValue

{

int smaller(int x,int y)

{

if(x<y)

{

return x;

}

else

{

return y;

}

}

}

class DemoMethods6

{

public static void main(String[] args)

{


Scanner s = new Scanner(System.in);

System.out.println("Enter int value-1:");

int v1 = s.nextInt();

System.out.println("Enter int value-2:");

int v2 = s.nextInt();

System.out.println("****Choice****");

System.out.println("1.GreaterVlaue\n2.SmallerValue");

System.out.println("Enter the Choice:");

int choice = s.nextInt();

switch(choice)

{

case 1:

GreaterValue gv = new GreaterValue();

int r1 = gv.greater(v1,v2);

System.out.println("GreaterValue:"+r1);

break;

case 2:

SmallerValue sv = new SmallerValue();

int r2 = sv.smaller(v1,v2);

System.out.println("SmallerValue:"+r2);

break;

default:

System.out.println("Invalid Choice...");

}//end of switch

}

}




o/p:

Enter int value-1:

12

Enter int value-2:

123

****Choice****

1.GreaterVlaue

2.SmallerValue

Enter the Choice:

1

GreaterValue:123




==============================================================

Assignment:(Solution)

Update above program by display the grade of an Student?





per=>

70 to 100 ---- Grade-A

60 to <70 ---- Grade-B

50 to <60 ---- Grade-C

35 to <50 ---- Grade-D

else ---- Fail

SubClass : Grade

=>String gr(float per)




Note:

=>If any Sub Marks enterted in b/w 0 to 34,then Grade must be

"Fail"







Program : DemoMethods4.java(Modified)

import java.util.Scanner;

class Percentage

{

float calculate(int totMarks)

{

return (float)totMarks/6;

}


}

class Grade

{

String gr(float per)

{

if(per>=70 && per<=100)

{

return "Grade-A";

}

else if(per>=60 && per<70)

{

return "Grade-B";

}

else if(per>=50 && per<60)

{

return "Grade-C";

}

else if(per>=35 && per<50)

{

return "Grade-D";

}

else

{

return "Fail";


}

}

}

class DemoMethods4

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

int i=1,totM=0;

boolean k=false;

while(i<=6)

{

System.out.println("Enter Marks of Subject-"+i);

int sub = s.nextInt();

if(sub<0 || sub>100)

{

System.out.println("Invalid Marks...");

continue;//skip the below lines from the iteration

}

if(sub>=0 && sub<=34)

{

k=true;


}

totM = totM+sub;

System.out.println("subject:"+sub);

i++;

}//end of loop

System.out.println("TotalMarks:"+totM);

Percentage pr = new Percentage();

float per = pr.calculate(totM);

System.out.println("Percentage:"+per);

if(k)

{

System.out.println("Result-Garde:Fail");

}

else

{

Grade ob = new Grade();

String res = ob.gr(per);

System.out.println("Result-Garde:"+res);

}

}

}





o/p:

Enter Marks of Subject-1

78

subject:78

Enter Marks of Subject-2

76

subject:76

Enter Marks of Subject-3

67

subject:67

Enter Marks of Subject-4

64

subject:64

Enter Marks of Subject-5

56

subject:56

Enter Marks of Subject-6

9

subject:9

TotalMarks:350

Percentage:58.333332

Result-Garde:Fail

========================================================

Assignment:

wap to perform WithDraw process?




1.read pinNo

=>The pinNo must be 4 digits,else "Invalid pinNo"

=>If the pinNo entered wrongly for three times then display the

msg as "Transaction blocked".

2.If the pinNo validated successfully,then read amt to WithDraw

=>The amt must be greater than zero and multiples of 100,else

"Invalid amt"

3.If the amt is validated Successfully,then the amt must be less

than 2000/-,else "Insufficient Fund"

4.If the amt is less than 2000/- then perform the transaction

o/p:

Amt withdrawn :

Balance amt  :

Transaction Successfull




SubClass : WithDraw

=>void wDraw(int amt)

=========>o/p

MainClass : DemoMethods

=========================================================

Ex-program:

wap to display the sum of n numbers?

Condition : n>0




Program : DemoLoop1.java

import java.util.Scanner;

class Test1

{

int sum=0;

int add(int n)

{

for(int i=1;i<=n;i++)

{

sum=sum+i;

}

return sum;

}

}

class DemoLoop1

{


public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");

int n = s.nextInt();

if(n>0)

{

Test1 ob = new Test1();

int res = ob.add(n);

System.out.println("Sum:"+res);

}

else

{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:

5

Sum:15

===========================================================

Assignment:

wap to read a number and display the factorial?

Condition : number>0

==========================================================

Assignment:

wap to display the sum of even numbers from the given n value?

Condition : n>0

===========================================================

Assignment:

wap to read a number and display the sum of digits?




I/p: n=123

O/p: sum = 1+2+3 + 6




Condition : number>0

==========================================================

==========================================================

Dt : 13/4/2023

Assignment:(Solution)

wap to read a number and display the factorial?

Condition : number>0




Program : DemoLoop2.java

import java.util.Scanner;

class Test2

{

int fact=1;

int factorial(int n)

{

for(int i=n;i>=1;i--)

{

fact=fact*i;

}

return fact;

}


}

class DemoLoop2

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");

int n = s.nextInt();

if(n>0)

{

Test2 ob = new Test2();

int res = ob.factorial(n);

System.out.println("Factoral:"+res);

}

else

{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:

4

Factoral:24

==========================================================

Assignment:(Solution)

wap to display the sum of even numbers from the given n value?

Condition : n>0




Program : DemoLoop3.java

import java.util.Scanner;

class Test3

{

int sum=0;

int add(int n)

{

for(int i=1;i<=n;i++)

{

if(i%2 == 0)

{

sum=sum+i;

}

}

return sum;

}


}

class DemoLoop3

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");

int n = s.nextInt();

if(n>0)

{

Test3 ob = new Test3();

int res = ob.add(n);

System.out.println("Sum of even number:"+res);

}

else

{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:

10

Sum of even number:30


===========================================================

Assignment:(Solution)

wap to read a number and display the sum of digits?




I/p: n=123

O/p: sum = 1+2+3 + 6




Condition : number>0




Program : DemoLoop4.java

import java.util.Scanner;

class Test4

{

int sum=0;

int add(int n)

{

while(n>0)

{

int k=n%10;

sum=sum+k;


n=n/10;

}

return sum;

}

}

class DemoLoop4

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");

int n = s.nextInt();

if(n>0)

{

Test4 ob = new Test4();

int res = ob.add(n);

System.out.println("Sum of digits:"+res);

}

else

{

System.out.println("Invalid input...");

}


}

}

o/p:

Enter the value of n:

1234

Sum of digits:10

==========================================================

Assignment:

wap to read a number and display the reverse of given number?




i/p : n=123

o/p : res=321

==========================================================

Assignment:

wap to read a number and display the sum of cubes of given number?




i/p:n=123

o/p:res = 1+8+27 = 36

==========================================================

Ex-program:

wap to read a number and check the number is Prime number or not?





Program : DemoLoop5.java

import java.util.Scanner;

class Test5

{

int count=0;

int prime(int n)

{

for(int i=1;i<=n;i++)

{

if(n%i == 0)

{

count++;

}

}

return count;

}

}

class DemoLoop5

{

public static void main(String[] args)

{


Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");

int n = s.nextInt();

if(n>0)

{

Test5 ob = new Test5();

int count = ob.prime(n);

if(count==2)

{

System.out.println("Prime number...");

}

else

{

System.out.println("NotPrime...");

}

}

else

{

System.out.println("Invalid input...");

}

}


}

o/p:

Enter the value of n:

7

Prime number...

=======================================================

faq:

wt is the diff b/w

(i)while loop

(ii)do-while loop




(i)while loop:

=>In while-loop,when the condition is true then the loop body is


executed.

(ii)do-while loop:

=>In do-while-loop,the loop body is executed once for the false


condition,and which waste the execution time and degrades the

performance of an application.

======================================================

*imp

Constructors in Java:

=>Constructor is a special-method having the same name of the

class and executed while Object creation process,because the

constructor call is available in Object creation syntax attached

with "new" keyword.

=>while declaring constructors we must not use return_type

because the Constructor will have Class_return_type.




structure of Constructor:




Class_name(para_list)

{

//method_body

}

----------------------------------------------

=>Based on parameters the constructors are categorized into two

types:

1.Constructors without parameters

2.Constructors with parameters




1.Constructors without parameters:

=>The Constructors which are declared without parameters are

known as 0-parameter Constructors or Constructors without parameters





Ex-program : DemoCon1.java

class CTest1

{

int k=10;

CTest1()

{

System.out.println("****CTest1()****");

System.out.println("The value k:"+k);

}

void dis()

{

System.out.println("****dis()****");

System.out.println("The value k:"+k);

}

}

class DemoCon1

{

public static void main(String[] args)

{

CTest1 ob = new CTest1();//Con_call

ob.dis();//Method call


}


}

o/p:

****CTest1()****

The value k:10

****dis()****

The value k:10

=================================================

Dt : 14/4/2023

Execution flow of above program:(DemoCon1.java)

ClassFiles:

CTest1.class

DemoCon1.class(MainClass)











































================================================

faq:

wt is the diff b/w

(i)Constructor

(ii)Instance method




=>Constructor is executed while object creation,but Instance method

is executed after object creation.

=>Costructor is an one-time executable component while object

creation process,but Instance method can be executed any number of

times after object creation.

============================================================

faq:

define default Constructor?

=>The constructor without parameters,which is added by the

compiler at compilation stage is default constructor.




faq:

In wt situation default constructor is added?

=>when the compiler at compilation stage finds any class declared

without any constructors then default constructor is added.

===========================================================

faq:

define static Constructor?

=>There is no concept of static constructor in Java,because

constructor means executed while object creation process and which

cannot be Class_level_Component.(Compilation Error)

========================================================

Dt : 17/4/2023

2.Constructors with parameters:

=>The Constructors which are declared with parameters are known

as Parameterized Constructors or Constructors with parameters.




Ex : DemoCon3.java

import java.util.Scanner;

class User

{

//Instance variables memory in Object

String uName,mId;

long phNo;




//Constructor to initialize instance Variables

//a,b,c are Local variables of Constructor

User(String a,String b,long c)

{

uName=a;

mId=b;

phNo=c;


}

//Instance method memory in Object to display details

void getUser()

{

System.out.println("****UserDetails****");

System.out.println("UserName:"+uName);

System.out.println("MailId:"+mId);

System.out.println("PhoneNo:"+phNo);

}

}

class DemoCon3

{

public static void main(String[] args)

{

//s,uN,mId,pNo,ob are Local variables of main()

Scanner s = new Scanner(System.in);

System.out.println("Enter the UserName:");

String uN = s.nextLine();

System.out.println("Enter the MailId:");

String mId = s.nextLine();

System.out.println("Enter the PhoneNo:");

long pNo = s.nextLong();

User ob = new User(uN,mId,pNo);//Con_call

ob.getUser();//Method_call

}

}

o/p:

Enter the UserName:

nit.v

Enter the MailId:

v@gmail.com

Enter the PhoneNo:

9898981234

****UserDetails****

UserName:nit.v

MailId:v@gmail.com

PhoneNo:9898981234

--------------------------------------------------

Execution flow of above program:(Demonstrating parameterized Con)

ClassFiles:

User.class

DemoCon3.class(MainClass)








































============================================================

*imp

Advantage of Constructors:

=>Constructors are used to initialize instance variables while

Object creation process ,and which saves the execution time and

generate HighPerformance of an application.

=============================================================

*imp

Loading data to Objects:

=>Loading data to objects can be done in three ways:

1.Using Constructor

2.Using Object reference variable

3.Using "Setter" methods




1.Using Constructor:

=>Using Constructors we can load the data to objects while Object

creation process.

Ex:

above program : DemoCon3.java

-------------------------------------------------------

2.Using Object reference variable:

=>We can also load the data to objects using Object name or

Object reference variable after Object creation process.




Ex : DemoCon4.java

import java.util.Scanner;

class Product

{


//Instance Variables memory in Object

String pId,pName;


//Instance method memory in Object

void getProduct()

{

System.out.println("****ProductDetails****");

System.out.println("ProdId:"+pId);

System.out.println("ProdName:"+pName);

}

}

class DemoCon4

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

Product p = new Product();//Con call


System.out.println("Enter the ProdId:");

p.pId = s.nextLine();

System.out.println("Enter the ProdName:");

p.pName = s.nextLine();




p.getProduct();//method_call


}

}

o/p:

Enter the ProdId:

A121

Enter the ProdName:

Mouse

****ProductDetails****

ProdId:A121

ProdName:Mouse




Diagram:


































------------------------------------------

3.Using "Setter" methods:

=>We can also load the data to objects using "Setter methods"

after Object creation process.




faq:

define Setter methods?

=>The methods which are used to set the data to objects are known

as Setter methods.

faq:

define Getter methods?

=>The methods which are used to get the data from the objects are

known as Getter methods.




Coding Rule of "Setter" and "Getter" methods:

=>Every variable in class will have its own Setter and Getter

methods.




Ex : DemoCon5.java

import java.util.Scanner;

class Customer

{

//Instance variable memory in Object

String cId,cName;




//Setter methods

void setCId(String a)

{

cId=a;


}

void setCName(String b)

{

cName=b;

}




//Getter methods

String getCId()

{

return cId;

}

String getCName()

{

return cName;

}

}

class DemoCon5

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

Customer c = new Customer();//Con_call

System.out.println("Enter the CustId:");

String custId = s.nextLine();

c.setCId(custId);//Setter-method_Call

System.out.println("Enter the CustName:");

String custName = s.nextLine();

c.setCName(custName);




System.out.println("****CustomerDetails****");

System.out.println("CustId:"+c.getCId());

System.out.println("CustName:"+c.getCName());

}

}

o/p:

Enter the CustId:

A121

Enter the CustName:

Raj

****CustomerDetails****

CustId:A121

CustName:Raj

===========================================================

Assignment:

Read and display BookDetails using three process:

1.Using Constructor

2.Using Object reference variable

3.Using "Setter" methods

============================================================

Dt : 18/4/2023

Assignment:

Read and display BookDetails using three process:

(Using "Setter" methods)




Program : DemoCon6.java

import java.util.Scanner;

class BookData

{

//Instance Variables

String code,name,author;

float price;

int qty;




//Setter methods

void setCode(String code)

{

this.code=code;

}

void setName(String name)

{


this.name=name;

}

void setAuthor(String author)

{

this.author=author;

}

void setPrice(float price)

{

this.price=price;

}

void setQty(int qty)

{

this.qty=qty;

}




//Getter methods

String getCode()

{

return code;

}

String getName()

{


return name;

}

String getAuthor()

{

return author;

}

float getPrice()

{

return price;

}

int getQty()

{

return qty;

}




}

class DemoCon6

{

public static void main(String[] args)

{


Scanner s = new Scanner(System.in);

BookData ob = new BookData();

System.out.println("Enter the BookCode:");

ob.setCode(s.nextLine());

System.out.println("Enter the BookName:");

ob.setName(s.nextLine());

System.out.println("Enter the BookAuthor:");

ob.setAuthor(s.nextLine());

System.out.println("Enter the BookPrice:");

ob.setPrice(s.nextFloat());

System.out.println("Enter the BookQty:");

ob.setQty(s.nextInt());




System.out.println("****BookDetails****");

System.out.println("BookCode:"+ob.getCode());

System.out.println("BookName:"+ob.getName());

System.out.println("BookAuthor:"+ob.getAuthor());

System.out.println("BookPrice:"+ob.getPrice());

System.out.println("BookQty:"+ob.getQty());

}

}

o/p:

Enter the BookCode:

A121

Enter the BookName:

C-Lang

Enter the BookAuthor:

B-Swamy

Enter the BookPrice:

1600

Enter the BookQty:

10

****BookDetails****

BookCode:A121

BookName:C-Lang

BookAuthor:B-Swamy

BookPrice:1600.0

BookQty:10

===================================================

faq:

define "this" keyword in Java?

=>"this" keyword will hold the reference of object from where

current method or constructor is executing.

=>Uisng "this" keyword we can access variables and methods from

the Object.

faq:

In wt situation we use "this" keyword?

=>"this" keyword is used while loading the data from local

variables to Instance variables having same names.

=======================================================

faq:

wt is the behaviour of Constructor declared with return type?


=>If the Constructor is declared with return type then it is having


the behaviour like normal method.




faq:

define destructors in Java?

=>There is no concept of destructors in Java,because the

Constructors are destroyed automatically after execution.

(destructors are available in c++)

==========================================================

*imp

Blocks in Java:

=>The set-of-statements which are declared within the flower

brackets and executed automatically is known as block.

=>Blocks in Java are categorized into two types:

1.Static blocks

2.NonStatic blocks(Instance blocks)




1.Static blocks:

=>The blocks which are declared with "static" keyword are known

as static blocks.




syntax:

static

{

//statements

}




Execution behaviour of static blocks:

=>static blocks are executed only once with highest priority when

the class is used for the first time.

=>static blocks will get the memory within the class while class

loading and can access static variables of class directly,but

cannot access Instance variables.

-------------------------------------------------------

************************Student Marks Application************************

A class Student is given to you.
Instance Variables:
studentId :String
studentName :String
marks: int
grade: char

Create a parameterized constructor with the parameters: studentId, studentName, marks.

Note that grade is not set either through constructor because it is a calculated value.

Methods:

displayDetails(): This method should return a String with the details of the student in the following format:
Student [name=John Smith, studentId=C123, marks=95, grade=A]

calculateGrade(): This is a method that calculates the grade based on the marks that is set.

If marks are above 90, grade is set to A.
If marks are between 81 and 90, grade is set to B, if marks are between 71 and 80, grade is set to C, if marks are between 61 and 70, grade is set to D, if marks are less than 61, grade is set to E.

Use this method when you need to set or reset grade.
A class Tester with main method is given to you to test your code.

*************************************************************************

Assignment-3

Program-1
Define a method which returns the square of the given number if it is an even, return cube of the given number if it is an odd number.
Write the method with the following specifications:
Name of method: calculate() // which accepts an integer value as argument and return
square of the given value if it is an even, return cube of the given value if it is an odd number.
Arguments: one argument of type integer
Return Type: an integer value
Specifications: The value returned by the method calculates () is determined by the following rules:

If the given number is negative or zero, return -1.
If the given number is even, return square of the number.
If the given number is odd, return cube of the given number.



Program-2

Define a method which returns the sum of three rounded numbers. If the right most digit of the number is less than 5, then round off it's value to the previous multiple of 10 otherwise if the right most digit of the number is greater or equal to 5, then round off to the next multiple of 10. Write the method with the following specifications:

Name of method sumOfRoundedValues() // which accepts three integer value as argument
and return the sum of three rounded numbers.
Arguments: three argument of type integer
Return Type: an integer value
Example
If a = 23, b = 34, c = 66
20+30+70=120
If a = 23, b = 37, c = 55
20+40+60=120
Specifications: The value returned by the method sumOfRoundedValues() is determined by the following rules:
If any of the given number is negative or zero, return -1.
If any of the given numbers right most digit is of the number is lessthan 5, then round off its value to the previous multiple of 10 otherwise if the right most digit of the number is greater or equal to 5, then round off to the next multiple of 10.



Program-3

Define a method which accepts a 4-digit value as number and checks whether the number is
armstrong or not.
Armstrong number: An Armstrong number is an n-digit number that is equal to the sum of the

nth powers of its digits.

For this program we need 4-digit armstrong number and is calculated as Input: 1634 is a 4-digit armstrong number defined as
1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634
Write the method with the following specifications:
Name of method: checkArmStrong() // which accepts an integer value as argument and
return the String as specified below.
Arguments: one argument of type integer
Return Type: a String value
Specifications: The value returned by the method checkArmStrong() is determined by the following rules:
If the input value is negative, return "-1" as string.
If the input value is not a 4-digit number, return "-2" as string.
If the input value is a 4-digit number and is an armstrong, return "ArmStrong Number" as string otherwise return "Not ArmStrong Number" as string. Note: The string values you are returning are case sensitive.

Dt : 19/4/2023

Ex-program:(Demonstrating static block in MainClass)

program : DemoBlock1.java

class DemoBlock1

{

static int k;

static

{

System.out.println("****Static block****");

System.out.println("The value k:"+k);

}

public static void main(String[] args)

{

k++;

System.out.println("****main()****");

System.out.println("The value k:"+k );

}

}

o/p:

****Static block****

The value k:0

****main()****

The value k:1




Execution flow of above program:

ClassFiles:

DemoBlock1.class
































=============================================================

Ex-program:(Demonstrating static block in SubClass)




Program : DemBlock2.java

class BTest1

{


static int z;

static

{

System.out.println("****SubClass Static block****");

System.out.println("The value z:"+z);

}

}

class DemoBlock2

{

public static void main(String[] args)

{

BTest1.z++;

System.out.println("****main()****");

System.out.println("The value z:"+BTest1.z);

}

}

o/p:

****SubClass Static block****

The value z:0

****main()****

The value z:1





Execution flow of above program:

ClassFiles:

BTest1.class

DemoBlock2.class(MainClass)




































==============================================================

2.NonStatic blocks(Instance blocks:

=>The blocks which are declared without "static" keyword are

known as NonStatic blocks or Instance blocks





syntax:

{

//statements

}




Execution behaviour of Instance blocks:

=>Instance blocks are executed while object creation process.

=>Instance blocks are executed for all multiple object creations.

=>Instance blocks will get the memory within the object while

Object creation process,and can access both Instance variables

and Static variables.




Ex-Program : DemoBlock3.java

class BTest2

{

int x=10;

static int y=20;




{

x++;

y++;

System.out.println("****Instance block****");

System.out.println("The value x:"+x);

System.out.println("The value y:"+y);

}

}

class DemoBlock3

{

public static void main(String[] args)

{

System.out.println("--------ob1---------");

BTest2 ob1 = new BTest2();

System.out.println("--------ob2---------");

BTest2 ob2 = new BTest2();

}

}

o/p:

--------ob1---------

****Instance block****

The value x:11

The value y:21

--------ob2---------

****Instance block****

The value x:11

The value y:22


Execution flow of above program:

ClassFiles:

BTest2.class

DemoBlock3.class(MainClass)


































==============================================================

Dt : 20/4/2023

*imp

Class generating Multiple objects:

=>Classes in Java can generate any number of objects without

restriction.

=>The multiple objects which are generated from the class are

independent by their memory location on HeapArea of JVM.

=>In the process of generating multiple objects,the class is

loaded only once.




faq:

In wt situation class will generate multiple objects?

=>In the process of holding database table data we generate

multiple objects from a class,in this process each object will

hold one database table record.

==============================================================

faq:

wt is the diff b/w

(i)blocks

(ii)methods

=>blocks are executed automatically,but methods are executed on

method call

=>blocks will have highest priority in execution than methods.

=>static block will have highest priority in execution than

static method

=>Instance block will have highest priority in execution than

Instance method.

=============================================================

faq:

wt is the diff b/w

(i)Instance block

(ii)Constructor

=>Both components are executed while object creation process,but

Instance block will have highest priority in execution than

Constructor.

===============================================================

faq:

wt is the diff b/w

(i)Static block

(ii)Constructor

=>Static block is one time executable component when the class is

used for the first time.

=>constructor also one time executable component while object

creation process.

===============================================================

Program : DemoBlock4.java

class BTest4

{

BTest4()

{

System.out.println("====BTest4()=====");

}




static

{

System.out.println("====Static block====");

}




{

System.out.println("====Instance block====");

}




void dis()

{

System.out.println("====dis()====");


}


}

class DemoBlock4

{

public static void main(String[] args)

{

BTest4 ob = new BTest4();

ob.dis();

}

}

o/p:

====Static block====

====Instance block====

====BTest4()=====

====dis()====

=============================================================

Note:

=>In realtime static blocks are used in DAO(Data Access Object)

layer of MVC(Model View Controller) to hold database connection

code.

=>In realtime Instance blocks are less used when compared to

static blocks.

==============================================================

*imp

Packages in Java:

=>package is a collection of Classes and Interfaces.

=>packages in Java are categorized into two types:

1.Pre-defined packages

2.User defined packages




1.Pre-defined packages:

=>The packages which are defined and available from JavaLib are

known as Pre-defined packages or Built- in packages.

=>The following are some important pre -defined packages:

java.lang - language package(default package)

java.util - utility package java.io - Input/Output Streams package java.net - Networking package


2.User defined packages:

=>The packages which are defined by the user are known as user

defined packages.

=>we use "package" keyword to define User defined packages

syntax:

package package_name;

===============================================================

dt : 24/4/2023

Note:

=>Download and install IDE Eclipse using the following link:

https://www.eclipse.org/downloads/




=>Download:

"Eclipse IDE for Enterprise java and Web Developers"

(IDE-Integrated Development Environment)

===============================================================

*imp

Creating Java Project using IDE Eclipse:

step-1 : Open IDE Eclipse,while opening name the WorkSpace and

click "Launch"




step-2 : Create Java Project

Click on File->new->Project->Java->select "Java Project" and click

"Next"->name the project and click "Finish"





step-3 : Create packages in "src"

RightClick on "src"->new->package,name the package and click

"Finish"




step-4 : Construct Classes under packages

RightClick on package->new->Class,name the class and click "Finish"




Note:

=>To increase font-size,click on Window->Preferences->General->

Appearance->Colors and Fonts->Java->Java Editor Text font...




step-5 : Execute the application




Open MainClass->click Run->Run

=========================================================

Ex-application:




Project name : EmployeeDetails App





packages,

p1 : EmpData,EmpSalary

p2 : EmpMainClass





Diagram:
























EmpData.java

package p1;

public class EmpData {
public String id,name,desg;
public void getEmpData() {
System.out.println("====EmpData====");
System.out.println("EmpId:"+id);
System.out.println("EmpName:"+name);
System.out.println("EmpDesg:"+desg);
}
}


EmpSalary.java

package p1;

public class EmpSalary {
public float getTotSal(int bSal) { return bSal+(0.93F*bSal)+(0.63F*bSal); }

}


EmpMainClass.java(MainClass)

package p2;

import java.util.Scanner;

import p1.EmpData;

import p1.EmpSalary;

public class EmpMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

EmpData ed = new EmpData();

EmpSalary es = new EmpSalary();




System.out.println("Enter the empId:");

ed.id = s.nextLine();

System.out.println("Enter the empName:");

ed.name = s.nextLine();

System.out.println("Enter the empDesg:");

ed.desg = s.nextLine();

System.out.println("Enter the bSal:");

int bSal = s.nextInt();

float totSal = es.getTotSal(bSal);





ed.getEmpData();

System.out.println("BSal:"+bSal);

System.out.println("TotSal:"+totSal);




s.close();

}

}

==========================================================

Assignment:




Project_name : StudentDetails_App




packages,

p1 : StuData,StuContact,StuPercentage

p2 : StuMainClass




StuData

=>rollNo,name,branch

=>void getStuData()





StuContact

=>mailId,phNo

=>void getStuContact()

StuPercentage

=>float getPercentage(int totMarks)




StuMainClass

=>main()

=>read ...

6 sub marks

==============================================================

Dt : 25/4/2023

Assignment:(Solution)

Project_name : StudentDetails_App

packages,

p1 : StuData,StuContact,StuPercentage

p2 : StuMainClass




StuData.java

package p1;

public class StuData {
public String rollNo,name,branch; public void getStuData() {

System.out.println("****StudentDetails****"); System.out.println("RollNo:"+rollNo); System.out.println("Name:"+name); System.out.println("Branch:"+branch);

}
}


StuContact.java

package p1;

public class StuContact {
public String mailId;
public long phNo;
public void getStuContact() {
System.out.println("MailId:"+mailId);
System.out.println("PhoneNo:"+phNo);
}
}



StuPercentage.java
package p1;

public class StuPercentage {
public float getPercentage(int totMarks) { return (float)totMarks/6; }

}


StuMainClass.java(MainClass)

package p2;

import java.util.Scanner;

import p1.StuData;

import p1.StuContact;

import p1.StuPercentage;

public class StuMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

StuData sd = new StuData();

StuContact sc = new StuContact();

StuPercentage sp = new StuPercentage();




System.out.println("Enter the rollNo:");

sd.rollNo = s.nextLine();

System.out.println("Enter the StuName:");

sd.name = s.nextLine();

System.out.println("Enter the Branch:");

sd.branch = s.nextLine();

System.out.println("Enter the MailId:");

sc.mailId = s.nextLine();

System.out.println("Enter the PhoneNo:");

sc.phNo = s.nextLong();

System.out.println("****Enter 6 Sub Marks****");

int i=1,totM=0;

while(i<=6) {

System.out.println("Enter Marks of Subject-"+i);

int sub = s.nextInt();

if(sub<0 || sub>100)

{

System.out.println("Invalid marks...");

continue;

}

totM = totM+sub;

i++;

}//end of loop

sd.getStuData();

sc.getStuContact();

System.out.println("TotalMarks:"+totM);

float per = sp.getPercentage(totM);

System.out.println("Percentage:"+per);

s.close();

}

}

==============================================================

Assignment-1:

Update above StudentDetails_App by adding "StuResult"

p1 : StuResult

=>String generate(float per)

===============================================================

Assignment-2:

Project name : Arithmetic App





packages,

p1 : Addition,Subtraction,Multiplication,Division,

ModDivision

p2 : ArithmeticMainClass

============================================================

*imp

Access Modifiers in Java:

=>Access Modifiers in Java specify the scope and visibility of

programming components in project.

=>Access Modifiers are categorized in to the following:

1.public

2.private

3.protected

4.default




1.public:

=>"public" programming components are accessed within the project




2.private:

=>"private" programming components are accessed only within the

class.




3.protected:

=>"protected" programming components are accessed inside the

package,but these "protected" programming components canbe

accessed by the ChildClass declared outside the package.




4.default:

=>The programming components in class,which are declared without

any access modifier are considered as "default".

=>default programming components are accessed only inside the

package.

Note:

=>"default" keyword mustnot be used in classes(Compilation Error)




Diagram:








































===============================================================

*imp

define "import" statement?

=>"import" statement will specify the "class or Interface"

available from one package to another package.

=>Importing process in Java canbe done in three ways:

(i)Using "import package_name.CName/IName; "

(ii)Using "import package_name.*; "

(iii)Using "Fully Qualified Names"


Dt : 26/4/2023

(i)Using "import package_name.CName/IName; "

=>In this importing process the required class or interface

from the package available to current running program.

=>This importing process is also known as "Explicit importing

process"




Ex:

import java.util.Scanner;

import p1.StuData;

import p1.StuContact;

import p1.StuPercentage;




(ii)Using "import package name.*; "


=>In this importing process all the classes and Interfaces from

the package are available to current running program.

=>This importing process is also known as "Implicit importing

process"





Ex:

import java.util.*;

import p1.*;


(iii)Using "Fully Qualified Names"

=>The process of declaring classes and Interfaces with

package_names part of programming code are known as

"Fully Qualified names"




Ex:

java.util.Scanner s = new java.util.Scanner(System.in);

p1.StuData sd = new p1.StuData();

p1.StuContact sc = new p1.StuContact();

p1.StuPercentage sp = new p1.StuPercentage();

============================================================

faq:

define "static" import?

=>The process of declaring "import" statement with static keyword

is known as "static import" and which is introduced by Java5 version

syntax:

import static package name.CName/IName.*;


Ex:

import static p1.Test.*;





Advantage:

=>In static import,all the static members of Class or Interface

available to current running program and can be accessed directly

without class_name or Interface_name.




Ex-progrm:

Test.java

package p1;

public class Test { public static int k; public static void dis() {

System.out.println("****static method dis()****");

System.out.println("The value k:"+k);
}
public void m(int z) {
System.out.println("****Instance method
m(z)****");
System.out.println("The value z:"+z);
}
}


DemoStatic.java(MainClass)

package p2;

import java.util.Scanner;

import static p1.Test.*;//Only Static members are available

import p1.Test;//Class available

public class DemoStatic {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of k:");

k = s.nextInt();//static variable of class Test

dis();//static method of class Test

Test ob = new Test();

ob.m(123);

s.close();

}

}

o/p:

Enter the value of k:

125

****static method dis()****

The value k:125

****Instance method m(z)****

The value z:123




Diagram:





==========================================================

faq:

define "s.close()"?

=>s.close() represent closing Scanner Object connection to Console

input.




Note:

=>According to Java Application development,the resources which

are opened outside the JVM must be closed after using the resources

part of Security.

(Resources means IO,File,Database,N/W,WB,...)`

==========================================================

*imp

Relations in Java:

=>The process of establishing relations b/w Programming components

are known as "relations in Java".

=>Relations in Java are categorized into three types:

1.References  - Interlinking of Objects

2.Inheritance - Interlinking of Classes

3.InnerClasses - Class holding class
5/20/23, 9:59 AM	Packages2.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NjA2MzkzMDk1MjYy/details	1/1

Dt : 27/4/2023




1.References  - Interlinking of Objects

=>The process in which one object holding the reference of another

object is known as References Concept.

=>In references concept the members of one object can access the

members of another object.

=>References in Java are categorized into two types:

(a)Tightly Coupled References

(b)Loosly Coupled References




(a)Tightly Coupled References:

=>The references concept in which the reffered-class object is

available to only one object is known as Tightly Coupled References

=>In Tightly Coupled references the reffered-class object is

created when we create OuterClass object.




Diagram:


















































Ex-Program:

EAddress.java

package p1;

public class EAddress {
public String hNo,sName,city,state; public int pinCode;

public void getEAddress() {
System.out.println("****EAddress****"); System.out.println("HNo:"+hNo); System.out.println("SName:"+sName); System.out.println("City:"+city); System.out.println("State:"+state); System.out.println("PinCode:"+pinCode);

}
}


Employee.java

package p1;

public class Employee {
public String eId,eName,eDesg; public EAddress ea = new EAddress();

//Tightly Coupled
reference
public void getEmployee() {
System.out.println("****Employee****"); System.out.println("EmpId:"+eId); System.out.println("EmpName:"+eName); System.out.println("EmpDesg:"+eDesg); }

}


DemoRef1.java(MainClass)

package p2;

import java.util.Scanner;

import p1.Employee;

public class DemoRef1 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

Employee e = new Employee();


System.out.println("Enter the EmpId:");

e.eId = s.nextLine();

System.out.println("Enter the EmpName:");

e.eName = s.nextLine();

System.out.println("Enter the EmpDesg:");

e.eDesg = s.nextLine();

System.out.println("Enter the HNo:");

e.ea.hNo = s.nextLine();

System.out.println("Enter the StreetName:");

e.ea.sName = s.nextLine();

System.out.println("Enter the City:");

e.ea.city = s.nextLine();

System.out.println("Enter the State:");

e.ea.state = s.nextLine();

System.out.println("Enter the PinCode:");

e.ea.pinCode = s.nextInt();




e.getEmployee();

e.ea.getEAddress();




s.close();

}

}

o/p:

Enter the EmpId:

A111

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the HNo:

12-34/h

Enter the StreetName:

SRNagar

Enter the City:

Hyd

Enter the State:

TS

Enter the PinCode:

612345

****Employee****

EmpId:A111

EmpName:Raj

EmpDesg:SE

****EAddress****

HNo:12-34/h

SName:SRNagar

City:Hyd

State:TS

PinCode:612345

-------------------------------------------------------------

(b)Loosly Coupled References:

=>The references concept in which the reffered class object is

available to more than one object is known as Loosly Coupled

references.

=>In Loosly Coupled References reffered-class objects are not

created while creating OuterClass objects,which means reffered

class objects already created and available while creating

OuterClass Objects.

=>This Loosly Coupled References Concept is also known as

Construct Injection process.




Ex-program:

BookDetails.java


package p1;
public class BookDetails {

public String bCode,bName,bAuthor; public float bPrice; public int bQty;

public void getBookDetails() {
System.out.println("****BookDetails****");
System.out.println("BookCode:"+bCode);
System.out.println("BookName:"+bName);
System.out.println("BookAuthor:"+bAuthor);
System.out.println("BookPrice:"+bPrice);
System.out.println("BookQty:"+bQty);
}
}


CreateBook.java

package p1;

import java.util.Scanner;
public class CreateBook {
//Instance Variable
public BookDetails bd=null;

//Construct to initialize instance variable

public CreateBook(BookDetails bd) {
this.bd=bd;
}

public void readBookDetails(Scanner s) {

System.out.println("Enter the BookCode:");
bd.bCode = s.nextLine();
System.out.println("Enter the BookName:");
bd.bName = s.nextLine();
System.out.println("Enter the BookAuthor:");
bd.bAuthor = s.nextLine();
System.out.println("Enter the BookPrice:");
bd.bPrice = s.nextFloat();
System.out.println("Enter the BookQty:");
bd.bQty = s.nextInt();
}

}


DisplayBook.java

package p1;

public class DisplayBook {
//Instance Variable
public BookDetails bd=null;

//Constructor to Initialize Instance variable public DisplayBook(BookDetails bd) {

this.bd=bd;
}

public void disBookDetails() { bd.getBookDetails();

}
}


DemoRef2.java(MainClass)

package p2;

import java.util.Scanner;

import p1.*;

public class DemoRef2 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);//Con_call

BookDetails bd = new BookDetails();//Con_Call





CreateBook cb = new CreateBook(bd);//Con_Call

DisplayBook db = new DisplayBook(bd);//Con_call


cb.readBookDetails(s);//Scanner as parameter

db.disBookDetails();




s.close();

}

}

o/p:

Enter the BookCode:

A101

Enter the BookName:

C-Lang

Enter the BookAuthor:

B-Swamy

Enter the BookPrice:

1200

Enter the BookQty:

12

****BookDetails****

BookCode:A101

BookName:C-Lang

BookAuthor:B-Swamy

BookPrice:1200.0

BookQty:12

=========================================================

Assignment:

Construct the application using the following Layout:































=====================================================

Dt : 28/4/2023

Diagram:(demonstrating Loosly Coupled references)


























=====================================================

Assignment:(Solution)

SAddress.java

package p1;

public class SAddress {
public String hNo,sName,city,state; public int pinCode;

public void getSAddress() {
System.out.println("****Address****");
System.out.println("HNO:"+hNo);
System.out.println("SName:"+sName);
System.out.println("City:"+city);
System.out.println("State:"+state);
System.out.println("PinCode:"+pinCode);

}


}

SContact.java

package p1;

public class SContact {
public String mailId;
public long phNo;
public void getSContact() {
System.out.println("****Contact****");
System.out.println("MailId:"+mailId);
System.out.println("PhoneNO:"+phNo);
}
}


Student.java

package p1;

public class Student {
public String rollNo,name,branch; public SAddress sa = new SAddress(); public SContact sc = new SContact(); public void getStudent() {

System.out.println("****StudentDetails****"); System.out.println("RollNo:"+rollNo); System.out.println("Name:"+name); System.out.println("Branch:"+branch);

}
}


DemoRef3.java(MainClass)

package p2;

import java.util.*;

import p1.Student;

public class DemoRef3 {


public static void main(String[] args) {

Scanner s = new Scanner(System.in);

Student ob = new Student();




System.out.println("Enter the RollNo:");

ob.rollNo = s.nextLine();

System.out.println("Enter the Name:");

ob.name = s.nextLine();

System.out.println("Enter the Branch:");

ob.branch = s.nextLine();

System.out.println("Enter the hNo:");

ob.sa.hNo = s.nextLine();

System.out.println("Enter the StreetName:");

ob.sa.sName = s.nextLine();

System.out.println("Enter the City:");

ob.sa.city = s.nextLine();

System.out.println("Enter the State:");

ob.sa.state = s.nextLine();

System.out.println("Enter the PinCode:");

ob.sa.pinCode = Integer.parseInt(s.nextLine());

System.out.println("Enter the MailId:");

ob.sc.mailId = s.nextLine();

System.out.println("Enter the PhoneNo:");

ob.sc.phNo = s.nextLong();




ob.getStudent();

ob.sa.getSAddress();

ob.sc.getSContact();

s.close();

}

}










o/p:

Enter the RollNo:

91234

Enter the Name:

Raj

Enter the Branch:

CSE

Enter the hNo:

12-34/h

Enter the StreetName:

SR

Enter the City:

Hyd

Enter the State:

TS

Enter the PinCode:

612345

Enter the MailId:

v@

Enter the PhoneNo:

989898

****StudentDetails****

RollNo:91234

Name:Raj

Branch:CSE

****Address****

HNO:12-34/h

SName:SR

City:Hyd

State:TS

PinCode:612345

****Contact****

MailId:v@

PhoneNO:989898

==========================================================

Note:

=>String-data reading is skipped,when we read String-data after

reading numeric-data because the numeric methods will leave

enter-key information in Scanner Object.

=>This can be Overcomed using pre-defined parse-methods.

=>These parse-methods are used to read data in the form of String

and converts into numeric.

=>The following are some important parse-menthods:

byte var = Byte.parseByte(s.nextLine());

short var = Short.parseShort(s.nextLine());

int var = Integer.parseInt(s.nextLine());

long var = Long.parseLong(s.nextLine());

float var = Float.parseFloat(s.nextLine());

double var = Double.parseDouble(s.nextLine());

=>Byte,Short,Integer,Long,Float,Double are pre-defined Wrapper

Classes.

=============================================================

Dt : 29/4/2023

Assignment:(Solution)

wap to perform WithDraw process?




WithDraw.java

package p1;

public class WithDraw {
public void wDraw(int amt) {
System.out.println("Amt withdrawn:"+amt); System.out.println("balance amt:"+(2000-amt)); System.out.println("Transaction Successfully..."); }

}


BankMainClass.java(MainClass)

package p2;

import java.util.*;

import p1.WithDraw;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

int count=0;

while(true) {

System.out.println("Enter the PinNo:");

int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {

System.out.println("Enter the amt to WithDraw:");

int amt = s.nextInt();

if(amt>0 && amt%100==0) {

if(amt<=2000) {

WithDraw wd = new WithDraw();

wd.wDraw(amt);//method call

break;//stop the loop

}else {

System.out.println("Insufficient fund..");

break;//stop the loop

}

}else {

System.out.println("Invalid amt...");

break;//stop the loop

}

}else {

System.out.println("Invalid pinNo...");

count++;


}

if(count==3) {

System.out.println("Sorry ! Transaction blocked...");

break;//stop the loop

}

}//end of loop

s.close();

}

}

o/p:

Enter the PinNo:

1234

Enter the amt to WithDraw:

1200

Amt withdrawn:1200

balance amt:800

Transaction Successfully...

=========================================================

Student Marks Application:(Solution)




Student.java

package p1;

public class Student {
public String studentId,studentName;
public int marks;
public char grade;
public Student(String studentId,String studentName,int marks) {
this.studentId=studentId; this.studentName=studentName; this.marks=marks;

}
public void caluculateGrade() { if(marks>90 && marks<=100) {

grade = 'A';
}else if(marks>=81 && marks<=90) { grade='B';

}else if(marks>=71 && marks<=80) { grade='C';

}else if(marks>=61 && marks<=70) { grade='D';

}else {
grade='E';
}
}
public String displayDetails() {
String details = "StudentName="+studentName+

"\nStudentId="+studentId+
"\nMarks="+marks+
"\nGrade="+grade;
return details;
}
}

DemoTestMarks.java(MainClass)

package p2;

import java.util.*;

import p1.Student;

public class DemoTestMarks {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

System.out.println("Enter the StudentId:");

String stuId = s.nextLine();

System.out.println("Enter the StudentName:");

String stuName = s.nextLine();

System.out.println("Enter the Marks:");

int marks = s.nextInt();

Student ob = new Student(stuId,stuName,marks);

ob.caluculateGrade();

String details = ob.displayDetails();

System.out.println(details);

s.close();

}

}

o/p:

Enter the StudentId:

V123

Enter the StudentName:

Alex

Enter the Marks:

67

StudentName=Alex

StudentId=V123

Marks=67

Grade=D

========================================================

Dt : 2/5/2023

Note:

=>References concept is also known as 'HAS-A Relation',because

in references concept one object has-a reference of another object.

===========================================================

*imp

2.Inheritance - Interlinking of Classes

=>The process of interlinking two classes with "extends" keyword

in Java is known as Inheritance process.

=>In Inheritance process the ParentClass members are available

to ChildClass.




Diagram:
































syntax:

class A

{

//PClass body


}

class B extends A

{

//CClass_body

}

===========================================================

Case-1 : Variables and methods from the SuperClass/ParentClass

Case-2 : Constructors from the SuperClass/ParentClass

Case-3 : Blocks from the SuperClass/ParentClass




Case-1 : Variables and methods from the SuperClass/ParentClass




Ex-program-1:(Demonstrating Instance members)

A.java

package p1;

public class A {
public int p,q;
public void showpq() {
System.out.println("****SuperClass-A****"); System.out.println("p:" +p+"\nq:"+q);

}
}


B.java

package p1;

public class B extends A{
public int r;
public void showr() {
System.out.println("****SubClass-B****");
System.out.println("r:"+r);
}
public void sum() {
System.out.println("****SubClass-sum()***");
System.out.println("p+q+r:"+(p+q+r));
}
}



DemoInheritance1.java(MainClass)
package p2;

import p1.*;
public class DemoInheritance1 {
public static void main(String[] args) {
System.out.println("-----SuperClass Object----

-");
A ob1 = new A();
ob1.p=11;
ob1.q=12;
ob1.showpq();
System.out.println("-----SubClass Object-----
");
B ob2 = new B();
ob2.p=20;
ob2.q=21;
ob2.r=22;
ob2.showpq();
ob2.showr();
ob2.sum();
}
}


o/p:

-----SuperClass Object-----

****SuperClass-A****

p:11

q:12

-----SubClass Object-----

****SuperClass-A****

p:20

q:21


****SubClass-B****

r:22

****SubClass-sum()***

p+q+r:63




Execution flow of above program:(Demonstrating Inheritance)

ClassFiles:

A.class

B.class

DemoInheritance1.class(MainClass)

































--------------------------------------------------------

Note:

=>In Inheritance process we create object for SubClass/ChildClass,

in this process the ChildClass object will hold all instance members

of ParentClass and ChildClass.

=======================================================

Ex-program-2:(Demonstrating static members)




A.java

package p1;

public class A {
public static int a;
public static void showa() {
System.out.println("====PClass====");
System.out.println("The value a:"+a);
}
}


B.java

package p1;

public class B extends A{
public static int b;
public static void showb() {
System.out.println("====ChildClass===="); System.out.println("The value b:"+b);

}
}


DemoInheritance2.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance2 {
public static void main(String[] args) {
System.out.println("----Access with Class----");

B.a=12;
B.showa();
B.b=13;
B.showb();
System.out.println("----Access with Object----");
B ob = new B();
ob.a=21;
ob.showa();
ob.b=22;
ob.showb();
}
}


o/p:

----Access with Class----

====PClass====

The value a:12

====ChildClass====

The value b:13

----Access with Object----

====PClass====

The value a:21

====ChildClass====

The value b:22

-------------------------------------------------------------

Note:

=>In Inheritance process all the static members of ParentClass

are available to ChildClass and can be accessed with ChildClass

name directly.

------------------------------------------------------------

Implement a bank application that requires two classes namely, Account and Customer.

The class Customer is given and has the following specifications.
Customer:
Instance Variables: firstName, lastName.(both Strings) Getters/setters ,default constructor, and parameter constructor. A class Account is given and has the following specifications. Account:
Instance	Variables:customer(of	type	Customer),	balance:	double,	accountNo:	int,
interestRate:float
Methods:
deposit(amount) deposits the given amount. Add the given amount to balance withdraw(amount) withdraw /subtract the amount from balance if the amount is less

than balance. Other wise do not withdraw.
A tester class BankTester with the main method is given to you. Use this class to test your solution.

Dt : 3/5/2023

Execution Flow of above program:(Demonstrating static members)

ClassFiles:

A.class

B.class

DemoInheritance2.class(MainClass)




===========================================================

faq:

define Empty-Object-reference?

=>Empty-Object-reference is generated when we create object for

the class holding only static members.

===========================================================

faq:

can we access static members of class using Object reference or

Object name?

=>Yes,we can access static members of class using object reference

because the object reference generated for the class and belongs to

class.

=============================================================

*imp

Case-2 : Constructors from the SuperClass/ParentClass


(i)O-parameter constructor from the SuperClass/ParentClass

=>when we have 0-parameter constructor in PClass then compiler

at compilation stage will add "super()" to the CClass constructor

and which PClass_Con_Call.




Ex:

A.java

package p1;

public class A {
public A() {
System.out.println("****PClass-A()****"); }

}


B.java

package p1;

public class B extends A{
public B() {
System.out.println("****CClass-B()****");
}
}


DemoInheritance3.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance3 {
public static void main(String[] args) { B ob = new B();//CClass_Con_Call


}
}



o/p:

****PClass-A()****

****CClass-B()****




(ii)Parameterized Constructor from the SuperClass/ParentClass

=>when we have parameterized constructor in PClass then we must

add "super()" to the CClass constructor to pass parameters to

PClass_Constructor.




Ex:

A.java

package p1;

public class A {
public A(int x,int y) {
System.out.println("****PClass-A()****"); System.out.println("The value x:"+x); System.out.println("The value y:"+y); }

}


B.java

package p1;

public class B extends A{ public B(int v1,int v2) {

super(v1,v2);//PClass_Con_Call

}
}



DemoInheritance4.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance4 {
public static void main(String[] args) { B ob = new B(12,13);//CClass Con Call

}

}


o/p:

****PClass-A()****

The value x:12

The value y:13

===============================================================

*imp

Case-3 : Blocks from the SuperClass/ParentClass




=>Static blocks in PClass are executed first and then CClass static

blocks are executed.

=>Instance blocks in pClass are executed first and then CClass

Instance blocks are executed.





Ex:

A.class

package p1;

public class A
{

public A()

{
System.out.println("****PClass-A()****");
}

static

{
System.out.println("****PClass-static-block****");

}

{

System.out.println("****PClass-Instance-block****");

}


}



B.class

package p1;

public class B extends A
{
static
{
System.out.println("****CClass-static-block****");

}





public B()

{
System.out.println("****CClass-B()****");

}

{

System.out.println("****CClass-Instance-block****");

}
}


DemoInheritance5.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance5 {
public static void main(String[] args) { B ob = new B();

}
}


o/p:

****PClass-static-block****

****CClass-static-block****

****PClass-Instance-block****

****PClass-A()****

****CClass-Instance-block****

****CClass-B()****

============================================================
5/20/23, 10:02 AM	Inheritance1.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 4/5/2023

*imp

Member Access and Inheritance:

(i)"public" programming components of ParentClass can be accessed

by the ChildClasses available in the same package or different

package.

(ii)In Inheritance process "private" programming components of

ParentClass cannot be accessed by the ChildClasses,because

private programming are accessed only inside the class.

(iii)"protected" programming components of parentClass can be

accessed by the ChildClasses within the same package or

different package.

(iv)defualt programming components of ParentClass can be accessed

by the ChildClasses within the same package,but cannot be

accessed by the ChildClasses from differet packages.




Ex-program:

A.java

package p1;

public class A {
protected int a=10;
public void mA() {
System.out.println("****mA()****"); System.out.println("The value a:"+a);


}
}



B.java

package p1;

public class B extends A{

public int b=20;
public void mB() {
System.out.println("****mB()****"); System.out.println("The value a:"+a); System.out.println("The value b:"+b);

}

}


C.java

package p2;

import p1.A;
public class C extends A{

public int c=30;
public void mC() {
System.out.println("The value a:"+a);
System.out.println("The value c:"+c);
}
}


DemoInheritance6.java(MainClass)

package maccess;

import p1.*;

import p2.C;

public class DemoInheritance6 {


public static void main(String[] args) {

B ob1 = new B();

ob1.mA();

ob1.mB();

C ob2 = new C();

ob2.mA();

ob2.mC();

}

}

o/p:

****mA()****

The value a:10

****mB()****

The value a:10

The value b:20

****mA()****

The value a:10

The value a:10

The value c:30

=========================================================

*imp

Method Overriding process:

=>The method with same method signature in ParentClass and

ChildClass,then ParentClass method is replaced by ChildClass

method while Object creation process is known as Method Overriding

process or Method Replacement process.

=>Same method signature means,

same return_type

same method_name

same para_list

same para_type




Case-1 : Instance method Overriding process

Case-2 : Static method Overriding process

Case-3 : Constructor Overriding process







Case-1 : Instance method Overriding process

=>The Instance method with same method Signature in PClass and

CClass then PClass Instance method is replaced by CClass instance

method while Object creation process,is known as Instance method

Overriding process.





Ex-program:

A.class
package p1;

public class A {
public void showA(int a) //Overrided_method
{
System.out.println("****PClass-showA(a)****"); System.out.println("The value a:"+a); }

}


B.class

package p1;

public class B extends A{
public void showA(int a) //Overriding method
{
System.out.println("****CClass-showA(a)****"); System.out.println("The value a:"+a);

}
public void showB(int b) //Non Overriding method
{
System.out.println("****CClass-showB(b)****"); System.out.println("The value b:"+b);

}
}


DemoInheritance7.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance7 {
public static void main(String[] args) { B ob = new B();

ob.showA(12);
ob.showB(13);
}
}



o/p:

****CClass-showA(a)****

The value a:12

****CClass-showB(b)****

The value b:13




Execution flow of above program:(Demonstrating Overriding process)

ClassFiles:

A.class

B.class

DemoInheritance7.class(MainClass)




































===========================================================

Case-2 : Static method Overriding process

=>There is no concept of static method Overriding process,because

static methods will get the memory within the class and available

within the class.







Case-3 : Constructor Overriding process

=>There is no concept of Constructor Overriding process,because

PClass Constructor will hace PClass_name and CClass Constructor

will have CClass_name.

=============================================================

faq:

define Method Hiding process?

=>when we have same static method signature in PClass and CClass,

then PClass Static method is hided by CClass static method while

execution process,is known as Method Hiding process.




Ex:

A.class

package p1;

public class A {
public static void showA(int a)
{
System.out.println("****PClass-showA(a)****"); System.out.println("The value a:"+a); }

}


B.class

package p1;

public class B extends A{
public static void showA(int a)
{
System.out.println("****CClass-showA(a)****"); System.out.println("The value a:"+a);


}
public static void showB(int b) //Non Overriding method

{
System.out.println("****CClass-showB(b)****"); System.out.println("The value b:"+b);

}
}


DemoInheritance8.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance8 {
public static void main(String[] args) { B.showA(123);

B.showB(124);
}
}


o/p:

****CClass-showA(a)****

The value a:123

****CClass-showB(b)****

The value b:124




Diagram:



































==========================================================

Summary:

(i)Same Instance method signature in PClass and CClass is known as

Method Overriding process

(ii)Same Static method Signature in PClass and CClass is known as

Method Hiding process.

=========================================================


A class Student is given to you. It contains the following implementation.

Instance Variables: studentId : int , name :String , examFee:double
Methods: displayDetails(): String , payFee() :double
Default constructor, an all-fields constructor and a toString method.
Create two sub classes of Student called DayScholar and Hosteller. Add the following
implementations to each class.
DayScholar:
Instance Variables : transportFee:double ,
Methods: Default constructor and an all-fields constructor
Hosteller:
Instance Variables: hostelFee :double
Methods: Default constructor and an all-fields constructor .
Add the following methods in BOTH classes.
Method: displayDetails(): This method should return a string containing the details of the student in the following format:
Student [name=John Smith,studentId=123,examFee=100.0] OR DayScholar[transportFee=500, name=John Smith,studentId=123,examFee=100.0] and so on. Method: payFee(amount): This method takes amount as parameter that represents the fee provided. You must calculate and

then return the remaining amount paid in excess. If excess is paid, the returned amount will be negative. The total fees that each student must pay must include all the fees applicable to that Student(examFees, transportFees, hostelFees as applicable). Subtract the given amount from total fee for each student and return the remaining amount.
A class StudentTester is given to you with a main method. Use this class to test your solution's classes and methods.

Dt : 5/5/2023

Method Overloading process:

=>More than one method with same method name but differentiated by their

para_list or para_type is known as Method Overloading process or Method

extention process.

=>In Method Overloading process,return type of methods are not cosidered.





Case-1 : Instance method Overloading process

Case-2 : Static method Overloading process

Case-3 : Constructor Overloading process




Case-1 : Instance method Overloading process

=>More than one Instance method with same name but differentiated by their

para list or para type is known as Instance method Overloading process.





Ex-program:

A.java

package p1;

public class A {
public void m(int a) { System.out.println("*****PClass-

m(a)******");
System.out.println("The value a:"+a);

}
public void m(int a,int b) { this.m(a);
System.out.println("*****PClass-m(a,b)******");

System.out.println("The value b:"+b);
}
}


B.java

package p1;

public class B extends A{
public void m(int a,int b,int c) { super.m(a, b);
System.out.println("*****CClass-m(a,b,c)******");

System.out.println("The value

c:"+c);


}

public void m(int a,int b,int c,int d) {
this.m(a, b, c);
System.out.println("*****CClass-m(a,b,c,d)******");

System.out.println("The value

d:"+d);


}

}


DemoInheritance9.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance9 { public static void main(String[]

args) {
B ob = new B();
ob.m(1, 2, 3, 4);
}
}


o/p:

*****PClass-m(a)******

The value a:1

*****PClass-m(a,b)******

The value b:2

*****CClass-m(a,b,c)******

The value c:3

*****CClass-m(a,b,c,d)******

The value d:4

-------------------------------------------------------------

faq:

define Instance method Interlinking process?

=>The process of calling one Instance method from another Instance method

using "this" or "super" keyword is known as Instance method Interlinking

process or Instance method Chaining process.




faq:

wt is the diff b/w

(i)super

(ii)this




(i)super:

=>"super" keyword is used to access the variables and methods from the

SuperClass or ParentClass.




(ii)this:

=>"this" keyword is used to access the variables and methods from the

Same class or Current running class.

===================================================================

Case-2 : Static method Overloading process

=>More than one static method with same method_name but differentiated

by their para_list or para_type is known as Static method Overloading process.




faq:

Can we perform Static method Interlinking process or not?

=>No,we cannot perform Static method Interlinking process using "super"

and "this" keywords,because "super" and "this" are NonStatic reference

variables




faq:

Can we access static methods using "super" and "this" keywords?

=>Yes,we can access static methods using "super" and "this" keywords,but

"super" and "this" keywords must be used in NonStatic methods or Instance

methods.




Ex-program:

A.java

package p1;

public class A {
public static void m(int a) { System.out.println("*****PClass-

m(a)******");
System.out.println("The value a:"+a);
}
public static void m(int a,int b)
{
//this.m(a);
System.out.println("*****PClass-
m(a,b)******");
System.out.println("The value
a:"+a);
System.out.println("The value
b:"+b);
}
}


B.java

package p1;

public class B extends A{
public static void m(int a,int
b,int c) {
//super.m(a, b);
System.out.println("*****CClass-m(a,b,c)******");

System.out.println("The value a:"+a);
System.out.println("The value

b:"+b);
System.out.println("The value

c:"+c);


}

public static void m(int a,int b,int c,int d) {
//this.m(a, b, c);
System.out.println("*****CClass-m(a,b,c,d)******");

System.out.println("The value a:"+a);
System.out.println("The value

b:"+b);
System.out .println("The value

c:"+c);
System.out .println("The value

d:"+d);


}

public void access(int a,int b,int c,int d) {
super.m(a);
super.m(a, b);
this.m(a, b, c);
this.m(a, b, c, d);
}
}

DemoInheritance10.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance10 { public static void main(String[]

args) {
B ob = new B();
ob.access(1, 2, 3, 4);
}

}


o/p:

*****PClass-m(a)******

The value a:1

*****PClass-m(a,b)******

The value a:1

The value b:2

*****CClass-m(a,b,c)******

The value a:1

The value b:2

The value c:3

*****CClass-m(a,b,c,d)******

The value a:1

The value b:2

The value c:3

The value d:4

================================================================

*imp

Case-3 : Constructor Overloading process

=>More than one Constructor differentiated by their para list or para type


is known as Constructor Overloading process.




faq:

define Constructor Chaining Process?(Constructor Interlinking process)

=>The process of calling one constructor from another constructor using

"super()" or "this()" is known as Constructor Chaining Process.




Ex-program :

A.java

package p1;

public class A {
public A(int a) {

System.out.println("****A(a)****");

System.out.println("The value a:"+a);

}
public A(int a,int b) { this(a);



System.out.println("****A(a,b)****"); System.out.println("The value

b:"+b);
}
}


B.java

package p1;

public class B extends A{ public B(int a,int b,int c) {

super(a,b);

System.out.println("****B(a,b,c)****") ;

System.out.println("The value c:"+c);

}

public B(int a,int b,int c,int d) { this(a,b,c);

System.out.println("****B(a,b,c,d)**** ");
System.out.println("The value d:"+d);
}
}


DemoInheritance11.java(MainClass)

package p2;

import p1.*;
public class DemoInheritance11 { public static void main(String[]

args) {
B ob = new
B(1,2,3,4);//Con_Call with para
}

}


o/p:

****A(a)****

The value a:1

****A(a,b)****

The value b:2

****B(a,b,c)****

The value c:3

****B(a,b,c,d)****


The value d:4

==================================================================

Dt : 6/5/2023

faq:

wt is the diff b/w

(i)super()

(ii)this()




(i)super():

=>super() is used to access the constructors from the ParentClass or

SuperClass.




(ii)this():

=>this() is used to access the Constructors from the Same Class or

Current Running Class.

===================================================================

===

Note:

=>Inheritance process is not manditory to perform Method Overloading

process,but Inheritance is manditory to perform Method Overriding process.

===================================================================

====

Ex-program:

Addition.java
package p1;

public class Addition {
public void add(int x,int y){ System.out.println("Sum1:"+(x+y)); }

public int add(int x,int y,int z){
return x+y+z;
}
public float add(float x,float y){
return x+y;
}
}


DemoInheritance12.java(MainClass)

package p2;

import p1.Addition;
public class DemoInheritance12 {
public static void main(String[] args) { Addition ob = new Addition(); ob.add(1, 2);

int sum2 = ob.add(1, 2, 3); float sum3 = ob.add(1.2F, 4.3F); System.out.println("Sum2:"+sum2); System.out.println("Sum3:"+sum3);

}

}


o/p:

Sum1:3

Sum2:6

Sum3:5.5


==========================================================

Assignmnet:(References)(Solution)

Customer.java

package p1;

public class Customer {
public String firstName,lastName; public Customer() {}

public Customer(String firstName,String lastName) {
this.firstName=firstName;
this.lastName=lastName;
}
public String getFirstName() { return firstName;

}
public void setFirstName(String firstName) { this.firstName = firstName;

}
public String getLastName() { return lastName;

}
public void setLastName(String lastName) { this.lastName = lastName;

}

}



Account.java

package p1;

public class Account {
public Customer c = new Customer(); public double balance=2000; public int accountNo;

public float interestRate; public void withDraw(int amt) {

System.out.println("FirstName:"+c.getFirstName()); System.out.println("LastName:"+c.getLastName()); System.out.println("AccNo:"+accountNo); if(amt<=balance) {
balance=balance-amt;

System.out.println("balance:"+balance); System.out.println("Interest:"+interestRate);

}else {
System.out.println("Insufficient fund...");
}
}
public void deposit(int amt) {

System.out.println("FirstName:"+c.getFirstName());

System.out.println("LastName:"+c.getLastName());
System.out.println("AccNo:"+accountNo);
balance=balance+amt;
System.out.println("balance:"+balance);
System.out.println("Interest:"+interestRate);
}
}


BankTester.java(MainClass)

package p2;

import java.util.*;

import p1.*;

public class BankTester {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

Account ac = new Account();

System.out.println("Entere the firstName:");

ac.c.setFirstName(s.nextLine());

System.out.println("Entere the lastName:");

ac.c.setLastName(s.nextLine());

System.out.println("Enter the accNum:");

ac.accountNo = s.nextInt();

System.out.println("====Choice====");

System.out.println("1.WithDraw\n2.Deposit");

System.out.println("Enter the Choice:");

int choice = s.nextInt();

switch(choice) {

case 1:

System.out.println("Enter the amt:");

int a1 = s.nextInt();

ac.withDraw(a1);

break;

case 2:

System.out.println("Enter the amt:");

int a2 = s.nextInt();

ac.deposit(a2);

break;

default:

System.out.println("Invalid Choice:");

}//end of switch

s.close();

}

}

o/p:

Entere the firstName:

Alex

Entere the lastName:

K

Enter the accNum:

31313131

====Choice====

1.WithDraw

2.Deposit

Enter the Choice:

2

Enter the amt:

1300

FirstName:Alex

LastName:K

AccNo:31313131

balance:3300.0

Interest:0.0

=============================================================

*imp

Types of Inheritances:

=>Inheritances are categorized into 5 types:

1.Single Inheritance

2.Multiple Inheritance

3.Multi Level Inheritance

4.Hierarchal Inheritance

5.Hybrid Inheritance

Diagrams:





























===============================================================


*imp

Interfaces in Java:

=>Interface is a collection of variables,abstract methods and

concrete methods from Java8 version onwards.

(Upto Java7 version Interface is collection of variables and

abstract methods,but cannot hold concrete methods)




faq:

define abstract methods?

=>The methods which are declared without method body are known

as abstract methods.

structure of abstract methods:

abstract return type method name(para_list);





faq:

define concrete methods?

=>The methods which are declared with method_body are known as

Concrete methods.

structure of concrete methods:

return_type method_name(para_list)

{

//method_body

}

-----------------------------------------------------------

*imp

Coding rules of Interface:

Rule-1 : we use "interface" keyword to declare interfaces

syntax:

interface Interface_name

{

//Interface_body

}




Rule-2 : The programming components which are declared within the

interface are automatically "public"

Note:

=>The programming components which are declared in Classes

without any access modifier are considered as "default"




Rule-3 : Interfaces can be declared with both Primitive datatype

variables and NonPrimitive datatype variables





Rule-4 : The variables which are declared in interfaces are

automatically "static and final variables"

Note:

(i)static variables in interface will get the memory within

the interface while interface loading and can be accessed

with interface_name.

(ii)final variables must be initialized with value and once

initialized cannot be modified.

(final variables are also known as secured variables or

constant variables)

(iii)There is no concept of declaring NonStatic variables

in interfaces,because the variables are automatically

static variables.




Rule-5 : The methods which are declared in interfaces are

automatically NonStatic abstract methods.

(There is no concept of static abstract methods)




Rule-6 : The Normal interfaces can be declared with any number of

abstract methods no restriction.





Rule-7 : Interfaces cannot be instantiated,which means we cannot

create object for Interfaces directly.

Rule-8 : These interfaces are implemented to classes using

"implements" keyword and the classes are known as

implementation classes.




Rule-9 : These implementation classes must construct body for all

abstract methods of Interface.




Ex-program:

ITest.java

package p1;

public interface ITest {
public static final int k=123; public abstract void showA(int a); public abstract void showB(int b);

}


IClass.java

package p1;

public class IClass implements ITest{
public void showA(int a)//Overriding and
Implemented method
{
System.out.println("****showA(a)****"); System.out.println("The value a:"+a); System.out.println("The value k:"+k);

}

public void showB(int b)//Overriding and Implemented method

{

System.out.println("****showB(b)****");
System.out.println("The value b:"+b); System.out.println("The value k:"+k);

}
public void showC(int c)//NonOverriding and NonImplemented methods

{
System.out.println("****showC(c)****"); System.out.println("The value c:"+c); System.out.println("The value k:"+k);

}

}



DemoInterface1.java(MainClass)

package p2;

import p1.*;
public class DemoInterface1 {
public static void main(String[] args) { //ITest ob = new ITest();//Error IClass ob = new IClass(); ob.showA(100);

ob.showB(200);
ob.showC(300);
}
}


o/p:

****showA(a)****

The value a:100

The value k:123

****showB(b)****


The value b:200

The value k:123

****showC(c)****

The value c:300

The value k:123

-------------------------------------------------------


Dt : 9/5/2023

Execution flow of above program:

ClassFiles:

ITest.class

IClass.class

DemoInterface1.class(MainClass)



























----------------------------------------------------------

Rule-10 : Implementation classes can be declared with both implemented

methods and NonImplemented methods.





faq:

wt is the diff b/w

(i)Implemented methods

(ii)NonImplemented methods




(i)Implemented methods:

=>The methods which are taken from interfaces and constructed the body

are known as Implemented methods.




(ii)NonImplemented methods:

=>The methods which are declared in implementation classes directly are

known as NonImplemented methods.

-----------------------------------------------------------------

Rule-11 : Interfaces can be implemented to any number of implementation

Classes.

Diagram:


Ex-program :

IComparable.java

package p1;

public interface IComparable {
public abstract int compareTo(int x,int y);
}


GreaterValue.java

package p1;

public class GreaterValue implements IComparable{ public int compareTo(int x,int y) {

if(x>y) return x;
else return y;
}
}


SmallerValue.java

package p1;

public class SmallerValue implements IComparable{ public int compareTo(int x,int y) {

if(x<y) return x;
else return y;
}
}


DemoInterface2.java(MainClass)

package p2;

import java.util.*;

import p1.*;


public class DemoInterface2 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

System.out.println("Enter the value-1:");

int v1 = s.nextInt();

System.out.println("Enter the value-2:");

int v2 = s.nextInt();

if(v1>0 && v2>0) {

if(v1==v2) {

System.out.println("Values are equal...");

}else {

System.out.println("*******Choice*******");

System.out.println("\t1.GreaterValue"

"\n\t2.SmallerValue"); System.out.println("Enter the Choice:"); int choice = s.nextInt(); switch(choice) {

case 1:

GreaterValue gv = new GreaterValue(); int res1 = gv.compareTo(v1,v2); System.out.println("GreaterVale:"+res1); break;

case 2:

SmallerValue sm = new SmallerValue();

int res2 = sm.compareTo(v1,v2);

System.out.println("SmallerValue:"+res2);

break;

default:

System.out.println("Invalid choice...");

}//end of switch

}//end of else

}else {

System.out.println("Invalid input....");

}

s.close();

}

}

o/p:

Enter the value-1:

12

Enter the value-2:

13

*******Choice*******

1.GreaterValue

2.SmallerValue

Enter the Choice:

1

GreaterVale:13

===========================================================

Assignment:

Construct application from the following Layout:




============================================================

Rule-12 : Interfaces can be declared with Concrete methods

============================================================

*imp

Concrete methods in Interfaces:(Java8 - new feature)

=>From Java8 version onwards the interfaces can be declared with concrete

methods.

=>The following are the concrete methods can be declared in Interfaces:

(a)static Concrete methods(Java8)

(b)default Concrete methods(Java8)

(c)private Concrete methods(Java9)

Dt : 10/5/2023

(a)static Concrete methods(Java8):

=>The Concrete methods in interfaces which are declared with "static"

keyword are known as static Concrete methods,introduced by Java8 version.

Coding Rule:

=>Static concrete methods of Interfaces are not available to implementation

classes,which means Static concrete methods of Interface cannot be accessed

with Implementation_Class_name.




(b)default Concrete methods(Java8):

=>The Concrete methods in interfaces which are declared with "default"

keyword are known as default concrete methods,introduced by Java8 version.

=>These default concrete methods are only NonStatic methods.

Coding Rule:

=>These default concrete methods are available to implementation classes,

which means these default concrete methods will get the memory within the

object of implementation class and can be accessed with Implementation class

Object name






(c)private Concrete methods(Java9):

=>The concrete methods in interfaces which are declared with "private"

keyword are known as private concrete methods,introduced by Java9 version.

=>These private concrete methods are categorized into two types:

(i)NonStatic private concrete methods

(ii)static private Concrete methods

Coding Rule:

=>These private concrete methods are accessed only inside the interface,

which means accessed by the NonPrivate methods of same interface.




Ex:

ITest.java

package p1;

public interface ITest {
public abstract void showA(int a); public static void showB(int b) {

System.out.println("****static concrete showB(b)****");

System.out.println("The value b:"+b);
}
public default void showC(int c) {
System.out.println("****default concrete
showC(c)****");
System.out.println("The value c:"+c);
}
private static void showD(int d) {
System.out.println("****static private concrete
showD(d)****");
System.out.println("The value d:"+d);
}
private void showE(int e) {
System.out.println("****NonStatic private
concrete showE(e)****");
System.out.println("The value e:"+e);

}
public default void access(int d,int e) {
ITest.showD(d);

this.showE(e);
}
}


IClass.java

package p1;

public class IClass implements ITest{
public void showA(int a)//Overriding and Implemented method

{
System.out.println("****Implemented method showA(a)****");

System.out.println("The value a:"+a);
}
}


DemoInterface3.java(MainClass)

package p2;

import p1.*;
public class DemoInterface3 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.showA(12);
//IClass.showB(13);//Error
ITest.showB(13);
ob.showC(14);
//ITest.showD(15);//Error
//ob.showE(16);//Error
ob.access(15,16);
}
}


o/p:


****Implemented method showA(a)****

The value a:12

****static concrete showB(b)****

The value b:13

****default concrete showC(c)****

The value c:14

****static private concrete showD(d)****

The value d:15

****NonStatic private concrete showE(e)****

The value e:16

==========================================================

Rule-13 : There is no concept of Blocks and Constructors in Interfaces.

=======================================================

Rule-14 : Interfaces can be extended from another Interfaces using "extends"

Keyword,which means one interface can have features of another

interface.

Diagram:




Ex:

ITest1.java

package p1;

public interface ITest1 {
public abstract void showA(int a);

}

ITest2.java

package p1;

public interface ITest2 extends ITest1{ public abstract void showB(int b);

}


IClass.java

package p1;

public class IClass implements ITest2{ public void showA(int a) {

System.out.println("****showA(a)****"); System.out.println("The value a:"+a);

}
public void showB(int b) {
System.out.println("****showB(b)****");
System.out.println("The value b:"+b);
}
}


DemoInterface4.java(MainClass)

package p2;

import p1.*;
public class DemoInterface4 {
public static void main(String[] args) { IClass ob = new IClass(); ob.showA(12);

ob.showB(13);
}
}


o/p:

****showA(a)****


The value a:12

****showB(b)****

The value b:13

===================================================================

=====

Comparision Diagram:

===================================================================

====

dt : 11/5/2023

*imp

Summary of Single Inheritance process:




=================================================================

*imp

Multiple Inheritance process using Interfaces:




Model-1 : Extracting the features from more than one interface

into a Class.

(Class implementing from more than one Interface)




Diagram:

Note:

(i)Same abstract method signatures in multiple Inheritance will

not effect the inheritance process.

(ii)Same static concrete methods in multiple inheritance will

not effect the inheritance process,because the static concrete

methods are not available to implementation class.

(iii)when we have same default concrete methods in multiple

inheritance,will raise ambiguity at compilation stage and

which can be rectified

(iii)Same private concrete methods in Multiple Inheritance will

not effect the inheritance process,because the private methods

are not available to implementation class.




Ex-program:

ITest1.java

package p1;

public interface ITest1 {
public abstract void showA(int a); public static void showB(int b) {

System.out.println("***ITest1 static showB(b)***");

System.out.println("The value b:"+b);
}
public default void showC(int c) { System.out.println("***ITest1 default

showC(c)***");
System.out.println("The value c:"+c);
this.showD(16);

}
private void showD(int d) {
System.out.println("***ITest1 private
showD(d)***");
System.out.println("The value d:"+d);
}
}


ITest2.java

package p1;

public interface ITest2 {
public abstract void showA(int a); public static void showB(int b) {

System.out.println("***ITest2 static showB(b)***");

System.out.println("The value b:"+b);
}
public default void showCC(int c) {
System.out.println("***ITest2 default
showC(c)***");
System.out.println("The value c:"+c); this.showD(18);

}
private void showD(int d) {
System.out.println("***ITest2 private
showD(d)***");
System.out.println("The value d:"+d);
}
}


IClass.java

package p1;

public class IClass implements ITest1,ITest2{ public void showA(int a) {

System.out.println("****Implemented method showA(a)****");
System.out.println("The value a:"+a);

}
}


DemoMultipleInheritance1.java(MainClass)

package p2;

import p1.*;
public class DemoMultipleInheritance1 { public static void main(String[] args) {

IClass ob = new IClass();
ob.showA(123);
ITest1.showB(12);
ITest2.showB(13);
ob.showC(14);
ob.showCC(15);
}
}


o/p:

****Implemented method showA(a)****

The value a:123

***ITest1 static showB(b)***

The value b:12

***ITest2 static showB(b)***

The value b:13

***ITest1 default showC(c)***

The value c:14

***ITest1 private showD(d)***

The value d:16

***ITest2 default showC(c)***

The value c:15

***ITest2 private showD(d)***

The value d:18

----------------------------------------------------------------

Model-2 : Extracting the features from one class and any number of

Interfaces into a class.

(Class extends from one class and can be implemented from

any number of Interfaces)

Diagram:




Ex-program:

PClass.java

package p1;

public class PClass {
public void m1(int x) {
System.out.println("****PClass m1(x)****"); System.out.println("The value x:"+x); }

}


ITest.java

package p1;

public interface ITest {
public abstract void m2(int y);

}

IClass.java

package p1;

public class IClass extends PClass implements ITest{ public void m2(int y) {

System.out.println("****Implemented method m2(y)****");

System.out.println("The value y:"+y);
}
}


DemoMultipleInheritance2.java(MainClass)

package p2;

import p1.*;
public class DemoMultipleInheritance2 { public static void main(String[] args) {

IClass ob = new IClass();
ob.m1(12);
ob.m2(14);
}
}


o/p:

****PClass m1(x)****

The value x:12

****Implemented method m2(y)****

The value y:14

---------------------------------------------------------------

Model-3 : Extracting the features from more than one interface

into an Interface.

(Interface extends from more than one Interfaces)

Diagram:




Ex-program:

ITest1.java

package p1;

public interface ITest1 {
public abstract void m1(int x);
}


ITest2.java

package p1;

public interface ITest2 {
public abstract void m2(int y);
}


ITest3.java

package p1;

public interface ITest3 extends ITest1,ITest2{ public abstract void m3(int z);

}


IClass.java

package p1;

public class IClass implements ITest3{ public void m1(int x) {

System.out.println("****Implemented method m1(x)****");

System.out.println("The value x:"+x);
}
public void m2(int y) {
System.out.println("****Implemented method
m2(y)****");
System.out.println("The value y:"+y);

}
public void m3(int z) {
System.out.println("****Implemented method
m3(c)****");
System.out.println("The value z:"+z);
}
}


DemoMultipleInheritance3.java(MainClass)

package p2;

import p1.*;
public class DemoMultipleInheritance3 { public static void main(String[] args) {

IClass ob = new IClass();
ob.m1(11);
ob.m2(12);
ob.m3(13);
}
}


o/p:

****Implemented method m1(x)****

The value x:11

****Implemented method m2(y)****

The value y:12

****Implemented method m3(c)****

The value z:13

========================================================


Note:

Model-1 : java.lang.String Class

Model-2 : WrapperClasses

Model-3 : JDBC - java.sql.Connection Interface

=========================================================

Dt : 12/5/2023

*imp

AbstractClasses:

=>The classes which are declared with "abstract" keyword are

known as "abstract Classes".

=>Abstract Classes can hold variables,abstract methods,Concrete

methods,blocks,constructors and features.

=>Abstract methods in abstract classes must be declared with

"abstract" keyword.

=>AbstractClasses cannot be instantiated,which means we cannot

create object for AbstractClasses.

=>These AbstractClasses are extended to classes and the classes

are known as "Extention Classes" or "Implementation classes"

=>These "Extention Classes" must construct body for abstract

methods of AbstractClasses.





Ex:

AClass.java
package p1;

public abstract class AClass { public abstract void m1(int a); public void showX(int x) {

System.out.println("***AClass showX(x)***"); System.out.println("The value x:"+x); }

}


BClass.java

package p1;

public abstract class BClass extends AClass{
public abstract void m2(int b);
public void showY(int y) {
System.out.println("***BClass showY(y)***");
System.out.println("The value y:"+y);
}
}


EClass.java

package p1;

public class EClass extends BClass{ public void m1(int a) {

System.out.println("***Implemented method m1(a)***");

System.out.println("The value a:"+a);
}
public void m2(int b) {
System.out.println("***Implemented method

m2(b)***");
System.out.println("The value b:"+b);
}
}



DemoAbstractClass.java(MainClass)
package p2;

import p1.*;
public class DemoAbstractClass {
public static void main(String[] args) { //BClass ob = new BClass();//Error EClass ob = new EClass(); ob.m1(11);

ob.m2(12);
ob.showX(13);
ob.showY(14);
}
}


o/P:

***Implemented method m1(a)***

The value a:11

***Implemented method m2(b)***

The value b:12

***AClass showX(x)***

The value x:13

***BClass showY(y)***

The value y:14




Diagram:





























=======================================================

faq:

wt is the diff b/w

(i)Class

(ii)AbstractClass

=>Class holds only Concrete methods,but AbstractClass will hold

both abstract methods and Concrete methods.

=>Class can be instantiated ,but AbstractClass cannot be

instantiated.




faq:

wt is the diff b/w

(i)Interface

(ii)AbstractClass

=>Interface components are "public",but AbstractClass components

are "default"

=>Variables in interface are automatically "static and final",but

Variables in AbstractClasses are user choice.

=>Interfaces cannot hold "blocks and Constructors",but Abstract

Classes will hold blocks and Constructors.

=============================================================

faq:

define Abstraction process?

=>The process of hiding the background implementation from the

end-users is known as Abstraction process.

=>In Java,we use "Interfaces" and "AbstractClasses" to construct

Abstraction process.




=============================================================

faq:

define Encapsulation process?

=>The process of binding all the programming components into a

single unit class is known as Encapsulation process.

=>Class is Collection of Variables,Methods,Blocks,Constructors

and features.

============================================================

faq:

define TypeCasting process?

=>The process of converting one datatype into another datatype

is known as TypeCasting process.

=>This TypeCasting process can be done in two ways:

(a)Widening process

(b)Narrowing process




(a)Widening process:

=>The process of converting lower datatype into higher datatype

is known as Widening process.

=>This Widening process is also known as UpCasting process or

Implicit TypeCasting process.

char->byte->short->int->long->float->double




(b)Narrowing process:

=>The process of converting higher datatype into lower datatype

is known as Narrowing process.

=>This Narrowing process is also known as DownCasting process or

Explicit TypeCasting process.

double->float->long->int->short->byte->char

==============================================================
5/20/23, 10:04 AM	Interface3.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
5/20/23, 10:05 AM	Interface4.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 13/5/2023

Ex : DemoTypeCasting.java

package maccess;

public class DemoTypeCasting {
public static void main(String[] args) { char ch1 = 'n';

char ch2 = 'N';
//Widening process or UpCasting process //Implicit Type casting

int k = (int)ch1;//Char to ASCII code int z = (int)ch2;//Char to ASCII code

System.out.println("ASCII code of char n : "+k);

System.out.println("ASCII code	of char N :
"+z);

int v1 = 65;

int v2 = 97;
//Narrowing process or DownCasting process //Explicit Type Casting

char ch3 = (char)v1;
char ch4 = (char)v2;
System.out.println("char at ASCII code 65 :
"+ch3);
System.out.println("char at ASCII code 97 :
"+ch4);
}
}


o/p:

ASCII code of char n : 110

ASCII code of char N : 78

char at ASCII code 65 : A

char at ASCII code 97 : a

=====================================================


















*imp

Generalization process:

=>The process of converting CClass into PClass is known as

Generalization process.

=>In Generalization process one object is created holding all the

members of PClass and Only Overriding members from the CClass.

syntax:

PClass ob = (PClass)new CClass();

=>This Generalization process can also be applied on Interfaces

and AbstractClasses.

syntax:

ITest ob = (ITest)new IClass();

AClass ob = (AClass)new EClass();





Ex-program:

PClass.java

package p1;

public class PClass
{
public void m1(int x)
{
System.out.println("****PClass m1(x)****"); System.out.println("The value x:"+x);

}
public void m2(int y)
{
System.out.println("****PClass m2(y)****"); System.out.println("The value y:"+y);

}
}


ITest.java

package p1;

public interface ITest {
public abstract void showA(int a); public default void showB(int b) {

System.out.println("***ITest default showB(b)***");

System.out.println("The value b:"+b);
}
}


CClass.java

package p1;

public class CClass extends PClass implements ITest{ public void m1(int x)//Overriding method

{
System.out.println("****CClass m1(x)****"); System.out.println("The value x:"+x);


}
public void m3(int z)//NonOverriding method
{

System.out.println("****CClass m3(z)****"); System.out.println("The value z:"+z);

}
public void showA(int a) {
System.out.println("****ITest implemented
showA(a)****");
System.out.println("The value a:"+a);
}
}


DemoGeneralization1.java(MainClass)

package p2;

import p1.*;
public class DemoGeneralization1 {
public static void main(String[] args) { System.out.println("****Generalization on

Class****");
PClass ob1 = (PClass)new CClass();
ob1.m1(11);
ob1.m2(12);
//ob1.m3(13);
//ob1.showA(14);
System.out.println("****Generalization on Interface****");

ITest ob2 = (ITest)new CClass();
ob2.showA(16);
ob2.showB(17);
//Specialization process //CClass ob3 = (CClass)new PClass();

//raises Exception
}
}


o/p:


****Generalization on Class****

****CClass m1(x)****

The value x:11

****PClass m2(y)****

The value y:12

****Generalization on Interface****

****ITest implemented showA(a)****

The value a:16

***ITest default showB(b)***

The value b:17




Diagram:






































==========================================================

*imp

Specialization process:

=>The process of taking one feature from the PClass and

constructing the CClass is known as Specialization process.

syntax:

CClass ob = (CClass)new PClass();

=>The process of converting PClass into CClass is known as

Specialization process.

=>Specialization process cannot be applied on Interfaces and

Abstract Classes.




Coding Rule:

=>To perform Specialization process the PClass must be Pre-defined

Built-in class from the library,else raises

"java.lang.ClassCastException"




Ex for Specialization:

Cloning process

Serialization and DeSerialization process

=======================================================

dt : 15/5/2023

Assignment:(Solution)




Student.java

package p1;

public class Student {
public int studentId;
public String name;
public double examFee;
public Student() {}
public Student(int studentId,String name,double examFee) {

this.studentId=studentId;
this.name=name;
this.examFee=examFee;
}
public String displayDetails() {
return "StudentId:"+studentId+"\nName:"+name+ "\nExamFee"+examFee;

}
public double payFee(int amt) { return examFee;

}
}


DayScholar.java

package p1;

public class DayScholar extends Student{ public double transportFee;

public DayScholar() {}
public DayScholar(int studentId,String name, double examFee,double transportFee) {

super(studentId,name,examFee); this.transportFee=transportFee;


}
public String displayDetails() {

return "transportFee:"+transportFee+
"\nstudentId:"+studentId+
"\nName:"+name+
"\nExamFee:"+examFee;
}
public double payFee(int amt) {
return amt-(examFee+transportFee);
}
}


Hosteller.java

package p1;

public class Hosteller extends Student{ public double hostelFee;

public Hosteller() {}
public Hosteller(int studentId,String name,double examFee,

double hostelFee ) {
super(studentId,name,examFee);
this.hostelFee=hostelFee;
}
public String displayDetails() { return "hostelFee:"+hostelFee+

"\nstudentId:"+studentId+
"\nName:"+name+
"\nExamFee:"+examFee;
}
public double payFee(int amt) { return amt-(examFee+hostelFee);

}
}


DemoInheritance14.java(MainClass)

package p2;


import java.util.*;

import p1.*;

public class DemoInheritance14 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

//examFee=2000

//transportFee=2000

//hostelFee=2000

System.out.println("Enter the totalAmt(6000):");

int amt = Integer.parseInt(s.nextLine());

System.out.println("====Choice=====");

System.out.println("\t1.DayScholar"

"\n\t2.Hosteller");

System.out.println("Enter the Choice:"); int choice = Integer.parseInt(s.nextLine()); switch(choice) {

case 1:

System.out.println("Enter the StudentId:"); int id = Integer.parseInt(s.nextLine()); System.out.println("Enter the StudentName:"); String name = s.nextLine(); System.out.println("Enter the ExamFee:");

double examFee = Double.parseDouble(s.nextLine());

System.out.println("Enter the TransportFee:");

double transportFee = Double.parseDouble(s.nextLine());

DayScholar ds = new DayScholar

(id,name,examFee,transportFee);

System.out.println(ds.displayDetails());

System.out.println("returned Amt:"+ds.payFee(amt));

break;

case 2:

System.out.println("Enter the StudentId:");

int id2 = Integer.parseInt(s.nextLine());

System.out.println("Enter the StudentName:");

String name2 = s.nextLine();

System.out.println("Enter the ExamFee:");

double examFee2 = Double.parseDouble(s.nextLine());

System.out.println("Enter the hostelFee:");

double hostelFee = Double.parseDouble(s.nextLine());

Hosteller hs = new Hosteller

(id2,name2,examFee2,hostelFee);

System.out.println(hs.displayDetails());

System.out.println("returned Amt:"+hs.payFee(amt));

break;

default:

System.out.println("Invalid Choice:");

}//end of switch

s.close();

}

}

=========================================================

*imp

InnerClasses in Java:

=>The process of declaring class inside the class is known as

innerclass or Nested class.

=>These InnerClasses are categorized into the following:

1.Member InnerClasses

2.Anonymous InnerClasses




1.Member InnerClasses:

=>The innerclasses which are declared as members of class are

known as Member InnerClasses.

=>These Member InnerClasses are categorized into two types:

(a)Static member InnerClasses

(b)NonStatic member InnerClasses

(a)Static member InnerClasses:

=>The member InnerClasses which are declared with "static"

keyword are known as Static member InnerClasses or Class member

InnerClasses.




Coding Rules:

(i)Static member InnerClasses can be declared with both static

and NonStatic programming components.

(ii)Instance methods static member InnerClass can access static

variables of OuterClass directly,but cannot access instance

variables of OuterClass because there is no relation b/w

InnerClass Object and OuterClass Object.

(iii)Static methods of Static member InnerClasses can access only

static variables of OuterClass and InnerClass directly,but

cannot access Instance variables.


you can access the private members of the static member inner class from the outer class through an instance of the inner class because the instance has access to its own private members.

syntax of Object creation for static memberText InnerClasses:

OuterClass name.InnerClass name ob =


new OuterClass_name.InnerClass_name();


Ex:

SubClass1.SubClass2 ob2 = new SubClass1.SubClass2();

Program:

SubClass1.java

package p1;

public class SubClass1 {
public int x=10;
public static int y=20;
public void m1() {
System.out.println("****OuterClass m1()****");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}//OuterClass method
public static class SubClass2{ public int a=100; public static int b=200; public void m2() {

System.out.println("****InnerClass Instance
m2()****");
System.out.println("The value a:"+a); System.out.println("The value b:"+b); //System.out.println("The value x:"+x); System.out.println("The value y:"+y);

}
public static void m22() {
System.out.println("****InnerClass static
m22()****");
//System.out.println("The value a:"+a); System.out.println("The value b:"+b); //System.out.println("The value x:"+x); System.out.println("The value y:"+y);

}
}//Static member InnerClass }//OuterClass


DemoInnerClass1.java(MainClass)


package p2;

import p1.*;
public class DemoInnerClass1 {
public static void main(String[] args) { //OuterClass Object

SubClass1 ob1 = new SubClass1(); ob1.m1();//OuterClass method_call

//Static member InnerClass Object SubClass1.SubClass2 ob2 = new

SubClass1.SubClass2();
ob2.m2();//InnerClass Instance method call
SubClass1.SubClass2.m22();
//InnerClass static method call
}

}



o/p:

****OuterClass m1()****

The value x:10

The value y:20

****InnerClass Instance m2()****

The value a:100

The value b:200

The value y:20

****InnerClass static m22()****

The value b:200

The value y:20

The payroll system of an organization involves calculating the gross salary of each type of employee and the tax applicable to each.
Create the following entity classes as described below.
Class Employee
Fields: id: int, name : String, basicSalary : double, HRAPer : double, DAPer : double
Public Method: calculateGrossSalary() - returns a double Calculate the gross salary as : basicSalary +HRAPer +DAPer Class Manager
Fields:  id:  int,  name  :  String,  basicSalary  :  double,  HRAPer  :  double,DAPer  :  double,
projectAllowance: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer + projectAllowance Class Trainer
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double, batchCount:
int, perkPerBatch: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch) Class Sourcing
Fields:  id:  int,  name  :  String,  basicSalary  :  double,  HRAPer  :  double,DAPer  :  double,
enrollmentTarget: int, enrollmentReached: int, perkPerEnrollment: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer +((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment)

Class TaxUtil

Fields: None
Public Methods:
calculateTax(Employee) - returns a double
calculateTax(Manager) - returns a double
calculateTax(Trainer) - returns a double
calculateTax(Sourcing) - returns a double

Tax Calculation Logic: If gross salary is greater than 30000 tax is 20% else, tax is 5%

Note : Attributes/Fields must be non-Private for the above classes.

A ClassObject class is given to you with the main Method. Use this class to test your solution.

Dt : 16/5/2023

Execution flow of above program:

ClassFiles:

SubClass1.class

SubClass1$SubClass2.class

DemoInnerClass1.class(MainClass)





























==========================================================

(b)NonStatic member InnerClasses :

=>The member InnerClasses which are declared without "static"

keyword are known as NonStatic member InnerClasses.

=>NonStatic member InnerClasses are categorized into two types:

(i)Instance member InnerClasses

(ii)Local member InnerClasses


(i)Instance member InnerClasses:

=>The NonStatic member InnerClasses which are declared outside

the methods are known as Instance member InnerClasses or Object

member InnerClasses.




Coding Rules:

(i)Instance member InnerClasses can be declared with both static

and NonStatic members.

(ii)Instance methods of Instance member InnerClasses can access

all the members of OuterClass directly,because InnerClass object

will hold the reference of OuterClass object.

(The objects are inter-related)

(iii)The static methods of Instance member InnerClasses can access

only static members of OuterClass and InnerClass.




syntax of Object creation for Instance member InnerClass:

OuterClass name.InnerClass name ob =


OuterClass_Object_name.new InnerClass_name();




Ex-program:


SubClass1.java
package p1;

public class SubClass1 {
public int x=10;
public static int y=20;
public void m1() {
System.out.println("****OuterClass m1()****"); System.out.println("The value x:"+x); System.out.println("The value y:"+y); }//OuterClass method

public class SubClass2{
public int a=100;
public static int b=200;
public void m2() {
System.out.println("****InnerClass Instance m2()****");

System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
public static void m22() {
System.out.println("****InnerClass Static
m22()****");
//System.out.println("The value a:"+a); System.out.println("The value b:"+b); //System.out.println("The value x:"+x); System.out.println("The value y:"+y);

}
}//Instance member InnerClass }//OuterClass


DemoInnerClass2.java(MainClass)

package p2;

import p1.*;
public class DemoInnerClass2 {
public static void main(String[] args) { //OuterClass Object

SubClass1 ob1 = new SubClass1(); ob1.m1();//OuterClass method_call
//Instance member InnerClass Object SubClass1.SubClass2 ob2 = ob1.new SubClass2(); ob2.m2();//InnerClass instance method call SubClass1.SubClass2.m22();

//InnerClass static method call
}
}





o/p:

****OuterClass m1()****

The value x:10

The value y:20

****InnerClass Instance m2()****

The value a:100

The value b:200

The value x:10

The value y:20

****InnerClass Static m22()****

The value b:200

The value y:20

====================================================

Assignment:

Update above programs by initializing variable x,y,a and b using

Constructors.

=======================================================

Dt : 17/5/2023

Execution flow:(Instance member InnerClass)

ClassFiles:

SubClass1.class

SubClass1$SubClass2.class

DemoInnerClass2.class(MainClass)



































===========================================================

*imp

(ii)Local member InnerClasses:

=>The NonStatic member InnerClasses which are declared inside

the methods are known as Local member InnerClasses.

=>Local member InnerClasses can be declared in both static

and NonStatic methods.

=>Local member InnerClass in Instance method will have behaviour

like Instance member InnerClass.

=>Local member InnerClass in Static method will have behaviour

like Static member InnerClass.




Coding Rule:

=>Local member InnerClass objects are created inside the methods

where the classes are declared.




Ex-program:

SubClass1.java

package p1;

public class SubClass1 {
public void m1(int x) {
class SubClass2{
public void m2(int x) {
System.out.println("****m2(x)****");
System.out.println("The value x:"+x);
}
}//Instance member InnerClass SubClass2 ob2 = new SubClass2(); ob2.m2(x);

}//OuterClass Instance method public static void m11(int y) {

class SubClass22{
public void m22(int y) {
System.out.println("****m22(y)****");
System.out.println("The value y:"+y);

}
}//Static member InnerClass SubClass22 ob22 = new SubClass22(); ob22.m22(y);

}//OuterClass Static method }//OuterClass


DemoInnerClass3.java(MainClass)

package p2;

import p1.*;
public class DemoInnerClass3 {
public static void main(String[] args) { //OuterClass Object

SubClass1 ob1 = new SubClass1();
ob1.m1(11);//OuterClass Instance method SubClass1.m11(12);//InnerClass Instance method

}
}


o/p:

****m2(x)****

The value x:11

****m22(y)****

The value y:12

---------------------------------------------------------

ClassFiles:

SubClass1.class

SubClass1$1SubClass2.class


SubClass1$1SubClass22.class

DemoInnerClass3.class(MainClass)

=========================================================

*imp

2.Anonymous InnerClasses:

=>The InnerClasses which are declared without name are known as

Anonymous InnerClasses or Anonymous Local member InnerClasses

=>These Anonymous InnerClasses are categorized into two types:

(a)Anonymous InnerClass as Class extention

(b)Anonymous InnerClass as Implementation class




(a)Anonymous InnerClass as Class extention:

=>The process of declaring CClass without name is known as

"Anonymous InnerClass as Class Extention".




syntax:

class PClass

{

//PClass body


}





PClass ob = new PClass()

{

//CClass_body

};

-----------------------------------------------------

Dt : 18/5/2023

Ex-Program:

PClass.java

package p1;

public class PClass
{
public void m1(int x)
{
System.out.println("****PClass m1(x)****"); System.out.println("The value x:"+x);

}
public void m2(int y)
{
System.out.println("****PClass m2(y)****"); System.out.println("The value y:"+y);

}
}


DemoAnonymous1.java(MainClass)

package p2;

import p1.PClass;
public class DemoAnonymous1
{
public static void main(String[] args)
{
//Anonymous InnerClass as Class Extension PClass ob = new PClass() {

public void m1(int x)//Overriding method
{
System.out.println("****Overriding
m1(x)****");
System.out.println("The value x:"+x);

}
public void m3(int z)//NonOverriding method

{
System.out.println("****NonOverriding

m3(z)****");
System.out.println("The value z:"+z);
}
};

ob.m1(12);

ob.m2(13);
//ob.m3(14);//Error
}

}



o/p:

****Overriding m1(x)****

The value x:12

****PClass m2(y)****

The value y:13




Execution flow of above program:

ClassFiles:

PClass.class

DemoAnonymous1.class(MainClass)

DemoAnonymous1$1.class





























Note:

=>Generalization process using Classes is modified as "Anonymous

InnerClass as Class extension" model.

=============================================================

*imp

(b)Anonymous InnerClass as Implementation class:

=>The process of declaring implementation class without name

is known as Anonymous InnerClass as Implementation class.




syntax:

interface ITest

{

//Interface_body

}




ITest ob = new ITest()

{

//IClass_body

};




Ex-program:

ITest.java

package p1;

public interface ITest {
public abstract void m1(int x); public default void m2(int y) {

System.out.println("****default m2(y)****"); System.out.println("The value y:"+y);

}
}


DemoAnonymous2.java(MainClass)

package p2;

import p1.ITest;
public class DemoAnonymous2 {
public static void main(String[] args) { //Anonymous InnerClass as implementation class ITest ob = new ITest()

{
public void m1(int x)//Overriding and implemented
{

System.out.println("***Implemented m1(x)***");
System.out.println("The value x:"+x);

}
public void m3(int z)

{
System.out.println("***NonImplemented m3(z)***");

System.out.println("The value z:"+z);
}
};

ob.m1(11);

ob.m2(12);
//ob.m3(23);//Error
}
}


o/p:

***Implemented m1(x)***

The value x:11

****default m2(y)****

The value y:12




Execution flow of above program:

ClassFiles:

ITest.class

DemoAnonymous2.class(MainClass)

DemoAnonymous2$1.class


























Note:

=>Generalization process using Interfaces model is modified as

"Anonymous InnerClass as Implementation class".

===============================================================

Note:

=>Anonymous InnerClass as implementation class model is modified

as LambdaExpression in Java8 version.

=======================================================

*imp

LambdaExpressions in Java:(Java8 - new feature)

=>The process of declaring method without method name is known as

LambdaExpression,and which is also known as Anonymous method.

Structure of LambdaExpression:




(para_list)->

{

//method_body

}




Note:

=>This LambdaExpression is attached with the abstract method of

interface and we execute lambdaExpression with abstract method name





syntax:

Interface name ob = (para list)->


{

//body

};




Ex-program:

ITest.java

package p1;

public interface ITest {
public abstract void m1(int x); public default void m2(int y) {

System.out.println("***default m2(y)***");
System.out.println("The value y:"+y);

}
}


DemoLambdaExpression1.java(MainClass)

package p2;

import p1.ITest;
public class DemoLambdaExpression1 {
public static void main(String[] args) {
//LambdaExpression
ITest ob = (int x)->
{
System.out.println("****Implemented m1(x)****"); System.out.println("The value x:"+x);

};

ob.m1(11);

ob.m2(12);
}
}


o/p:

****Implemented m1(x)****

The value x:11

***default m2(y)***

The value y:12

======================================================

Dt : 19/5/2023

Execution flow of above program:(Demonstrating LambdaExpression)

ClassFiles:

ITest.class

DemoLambdaExpression1.class(MainClass)







































========================================================

Advantage of LambdaExpressions:

=>when we use LambdaExpressions,separate class files are not

generated and loading time of execution process is saved and

generate high performance of an application.

=========================================================

Coding Rules:

Rule-1 : The interface which provide abstract method to hold

LambdaExpression must be declared with only one abstract

method and which is known as Functional Interface.

Rule-2 : The parameter-names used in LambdaExpression,the same

names must not be used to declare local variables within

the same method scope.

Rule-3 : LambdaExpressions will access the variables of Functional

interface using interface_name.

=======================================================

Ex-program:(Variables with LambdaExpressions)

ITest.java

package p1;

//Functional Interface
public interface ITest {
public static final int x=10; public abstract void showA(int a);

}


DemoLambdaExpression2.java(MainClass

package p2;

import p1.ITest;
public class DemoLambdaExpression2
{

public static int y=20;
public static void main(String[] args)
{

int z = 30;
ITest ob = (int a)->
{
System.out.println("****Implemented showA(a)****");

System.out.println("The value a:"+a);
System.out.println("The value x:"+ITest.x);

System.out.println("The value y:"+y);
System.out.println("The value z:"+z);
};
ob.showA(12);
}

}



o/p:

****Implemented showA(a)****

The value a:12

The value x:10

The value y:20

The value z:30

==========================================================

Execution flow of above program:

ClassFiles:

ITest.class

DemoLambdaExpression2.class(MainClass)




























==========================================================

Note:

=>While execution process the LambdaExpression will be executed

local to the method where it is declared.

=========================================================

faq:

wt is the diff b/w

(i)Normal Interface

(ii)Functional Interface

(iii)Marker Interface




(i)Normal Interface:

=>The interface which is declared with any number of abstract

methods is known as Normal interface.

Ex:

Collection<E>

Map<K,V>




(ii)Functional Interface:

=>The interface which is declared with only one abstract method

is known as Functional Interface,but we can declare concrete

methods in Functional Interface.

Ex:

Predicate<T>

BiPredicate<T,U>

Function<T>

BiFunction<T,U>

Consumer<T>

BiConsumer<T,U>




(iii)Marker Interface:

=>The interface which is declared with 0-methods is known as

Marker Interface.(Empty Interface is Marker Interface)

Ex:

Cloneable

Serializable

==========================================================

Assignment-1:

Convert IComparable-Application into LambdaExpressions.

(GreaterValue and SmallerVlaue classes as LambdaExpressions)




Assignment-2:

Convert IArithmetic-Application into LambdaExpressions.

(Addition,Subtraction,Multiplication,Division,ModDivision class as

LambdaExpressions)

============================================================

Dt : 20/5/2023

Assignment-1:(solution)

Convert IComparable-Application into LambdaExpressions.

(GreaterValue and SmallerVlaue classes as LambdaExpressions)




IComparable.java

package p1;

public interface IComparable {
public abstract int compareTo(int x,int y);

}


DemoLambdaExpression3.java(MainClass)

package p2;

import java.util.*;

import p1.IComparable;

public class DemoLambdaExpression3 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

System.out.println("Enter the value-1:");

int v1 = s.nextInt();

System.out.println("Enter the value-2:");

int v2 = s.nextInt();

if(v1==v2) {

System.out.println("Values are equal...");

}else {

System.out.println("****Choice****");

System.out.println("\t1.GreaterValue"

"\n\t2.SmallerValue");

System.out.println("Enter the Choice:"); int choice = s.nextInt(); switch(choice) {


case 1:

IComparable ob1 = (int x,int y)->

{

if(x>y) return x; else return y;

};

int r1 = ob1.compareTo(v1,v2); System.out.println("GreaterValue:"+r1); break;

case 2:

IComparable ob2 = (int x,int y)->

{

if(x<y) return x; else return y;


};

int r2 = ob2.compareTo(v1, v2);

System.out.println("SmallerValue:"+r2);

break;

default:

System.out.println("Invalid Choice...");

}//end of switch

}

s.close();

}

}

o/p:

Enter the value-1:

12

Enter the value-2:

13

****Choice****

1.GreaterValue

2.SmallerValue

Enter the Choice:

1

GreaterValue:13

==============================================================

Assignment:

Construct BankTransaction Model using the following layout:




a.Read pinNo

=>pinNo must be in b/w 1111 to 9999,else inValid pinNo

=>If the pinNo validated Successfully,then verify the pinNo is

among 1111 or 2222 or 3333,else "pinNo donot exist"

=>If the pinNo validation and verification failed for 3 times

then display the msg as "Transaction blocked" and stop the

program.

b.If the pinNo validated and verifed Successfully,then show the

following options:

1.WithDraw

2.Deposit




1.WithDraw:

=>Enter the amt

=>The amt must be greater than zero and multiples of 100,else

"Invalid amt".

=>If the amt is validated Successfully,then create object

for WithDraw-class and pass amt as parameter to process()

method.

=>part of process() method check amt is less than balnace or

not.

=>If amt is less than bal then perform transaction,else

"Insufficient fund"

o/p:

Amt WithDrawn :

Balance amt  :

Transaction Successfull




2.Deposit:

=>Enter the amt

=>The amt must be greater than zero and multiples of 100,else

"Invalid amt".

=>If the amt is validated Successfully,then create object

for Deposit-class and pass amt as parameter to process()

method.

o/p:

Amt Deposited :

Balance amt  :

Transaction Successfull

=============================================================

Note:

=>Construct the application in three Models:




Model-1 : Interface and Implementation classes with names.




Model-2 : Interface and Implementation classes without names

(Anonymous InnerClasses as implementation classes)




Model-3 : Interface and Implementation classes as LambdaExpressions

(LambdaExpressions)

==========================================================

Dt : 22/5/2023

Model-1 : Interface and Implementation classes with names.

(Solution)




Balance.java

package p1;

public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}
}



CheckPinNo.java
package p1;

public class CheckPinNo {
public boolean verify(int pinNo) { return switch(pinNo) {

case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}


Transaction.java

package p1;

//Functional Interface
public interface Transaction {
public static final Balance b=new Balance(); //Tightly Coupled reference

public abstract void process(int amt);
}


WithDraw.java

package p1;

public class WithDraw implements Transaction{ public void process(int amt) {

if(amt<=b.bal) {
System.out.println("Amt WithDrawn:"+amt);
b.bal = b.bal-amt;
System.out.println("Balance
amt:"+b.getBal());
System.out.println("Transaction
Successfully..");
}else {
System.out.println("InSufficient Fund...");
}
}

}


Deposit.java

package p1;

public class Deposit implements Transaction{ public void process(int amt) {

System.out.println("Amt deposited:"+amt);
b.bal=b.bal+amt;
System.out.println("Balance amt:"+b.getBal());
System.out.println("Transaction
Successfull...");
}
}


BankMainClass.java(MainClass)

package p2;

import p1.*;

import java.util.*;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

int count=0;

xyz:

while(true) {

System.out.println("Enter the PinNo:");

int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {

CheckPinNo cpn = new CheckPinNo();

boolean k = cpn.verify(pinNo);

if(k) {

System.out.println("****Choice****");

System.out.println("\t1.WithDraw"

"\n\t2.Deposit");

System.out.println("Enter the Choice:"); switch(s.nextInt()) {

case 1:

System.out.println("Enter the amt:"); int a1 = s.nextInt();

if(a1>0 && a1%100==0) {

WithDraw wd = new WithDraw(); wd.process(a1);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz; case 2:

System.out.println("Enter the amt:"); int a2 = s.nextInt();

if(a2>0 && a2%100==0) {

Deposit dp = new Deposit();

dp.process(a2);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

default:

System.out.println("Invalid Choice...");

break xyz;//stop the loop

}//end of switch

}else {

System.out.println("PinNo donot exist..");

count++;

}

}else {

System.out.println("Invalid PinNo...");

count++;

}

if(count==3) {

System.out.println("Sorry!Transaction Blocked...");

break;//stop the loop


}

}//end of loop

}




}

-------------------------------------------------------

ClassFiles:

Balance.class

CheckPinNo.class

Transaction.class

WithDraw.class

Deposit.class

BankMainClass.class(MainClass)

===========================================================

Model-2 : Interface and Implementation classes without names

(Anonymous InnerClasses as implementation classes)

(Solution)

Balance.java

package p1;

public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}

}

CheckPinNo.java

package p1;

public class CheckPinNo {
public boolean verify(int pinNo) { return switch(pinNo) {

case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}


Transaction.java

package p1;

//Functional Interface
public interface Transaction {
public static final Balance b=new Balance(); //Tightly Coupled reference

public abstract void process(int amt);
}


BankMainClass.java(MainClass)

package p2;

import p1.*;

import java.util.*;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

int count=0;

xyz:

while(true) {

System.out.println("Enter the PinNo:");

int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {

CheckPinNo cpn = new CheckPinNo();

boolean k = cpn.verify(pinNo);

if(k) {

System.out.println("****Choice****");

System.out.println("\t1.WithDraw"

"\n\t2.Deposit");

System.out.println("Enter the Choice:"); switch(s.nextInt()) {

case 1:

System.out.println("Enter the amt:"); int a1 = s.nextInt();

if(a1>0 && a1%100==0) { //WithDraw class as Anonymous Transaction wd = new Transaction()

{


public void process(int amt) {

if(amt<=b.bal) {

System.out.println("Amt

WithDrawn:"+amt);

b.bal = b.bal-amt;

System.out.println("Balance

amt:"+b.getBal());



System.out.println("Transaction Successfully..");

}else {



System.out.println("InSufficient Fund...");

}

}

};

wd.process(a1);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

case 2:

System.out.println("Enter the amt:");

int a2 = s.nextInt();

if(a2>0 && a2%100==0) {

//Deposit class as Anonymous

Transaction dp = new Transaction()

{

public void process(int amt) {

System.out.println("Amt

deposited:"+amt);

b.bal=b.bal+amt;

System.out.println("Balance

amt:"+b.getBal());

System.out.println("Transaction

Successfull...");

}

};

dp.process(a2);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

default:

System.out.println("Invalid Choice...");

break xyz;//stop the loop

}//end of switch

}else {


System.out.println("PinNo donot exist..");

count++;

}

}else {

System.out.println("Invalid PinNo...");

count++;

}

if(count==3) {

System.out.println("Sorry!Transaction Blocked...");

break;//stop the loop

}

}//end of loop

}




}

-------------------------------------------------------

ClassFiles:

Balance.class

CheckPinNo.class

Transaction.class

BankMainClass.class(MainClass)

BankMainClass$1.class


BankMainClass$2.class

==============================================================

Model-3 : Interface and Implementation classes as LambdaExpressions

(LambdaExpressions)

(Solution)




Balance.java

package p1;

public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}
}


CheckPinNo.java

package p1;

public class CheckPinNo {
public boolean verify(int pinNo) { return switch(pinNo) {

case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}


Transaction.java

package p1;

//Functional Interface
public interface Transaction {
public static final Balance b=new Balance();
//Tightly Coupled reference

public abstract void process(int amt);
}


BankMainClass.java(MainClass)

package p2;

import p1.*;

import java.util.*;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

int count=0;

xyz:

while(true) {

System.out.println("Enter the PinNo:");

int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {

CheckPinNo cpn = new CheckPinNo();

boolean k = cpn.verify(pinNo);

if(k) {


System.out.println("****Choice****");

System.out.println("\t1.WithDraw"

+ "\n\t2.Deposit");

System.out.println("Enter the Choice:");

switch(s.nextInt()) {

case 1:

System.out.println("Enter the amt:");

int a1 = s.nextInt();

if(a1>0 && a1%100==0) {

//WithDraw class as LambdaExpression

Transaction wd = (int amt)->

{

if(amt<=Transaction.b.bal) {

System.out.println("Amt

WithDrawn:"+amt);

Transaction.b.bal =

Transaction.b.bal-amt;

System.out.println("Balance

amt:"+Transaction.b.getBal());



System.out.println("Transaction Successfully..");

}else {



System.out.println("InSufficient Fund...");

}


};

wd.process(a1);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

case 2:

System.out.println("Enter the amt:");

int a2 = s.nextInt();

if(a2>0 && a2%100==0) {

//Deposit class as LambdaExpression

Transaction dp =(int amt)->

{

System.out.println("Amt

deposited:"+amt);



Transaction.b.bal=Transaction.b.bal+amt;

System.out.println("Balance

amt:"+Transaction.b.getBal());

System.out.println("Transaction

Successfull...");

};

dp.process(a2);//method_call


}else {

System.out.println("Invalid amt...");

}

break xyz;

default:

System.out.println("Invalid Choice...");

break xyz;//stop the loop

}//end of switch

}else {

System.out.println("PinNo donot exist..");

count++;

}

}else {

System.out.println("Invalid PinNo...");

count++;

}

if(count==3) {

System.out.println("Sorry!Transaction Blocked...");

break;//stop the loop


}

}//end of loop

}

}

-------------------------------------------------------

ClassFiles:

Balance.class

CheckPinNo.class

Transaction.class

BankMainClass.class(MainClass)

==========================================================

Note:

=>"Anonymous InnerClass as Implementation class" model is used

for Normal Interfaces.

=>LambdaExpressions is used for Functional Interfaces.

===========================================================

*imp

Method References in Java:(Java8 - new feature)

=>The process in which abstract method of Functional interface is

attached with the body of method from a class where the class is

not related to interface,is known as Method References Concept.

=>method references are categorized into three types:

(a)reference to Constructor

(b)reference to Instance method

(c)reference to Static method

Dt : 23/5/2023

(a)reference to Constructor:

=>The process in which abstract method of functional interface is

attached with the body of Costructor is known as reference to

Constructor.

syntax:

Func_Interface_name ob = Class_name :: new;

Ex:

ITest ob1 = Display :: new;




(b)reference to Instance method:

=>The process in which abstract method of functional interface is

attached with the body of Instance method is known as reference to

Instance method.

syntax:

Func Interface name ob = Object name::method_name;


Ex:

Display d = new Display(1);

ITest ob2 = d :: m1;





(c)reference to Static method:

=>The process in which abstract method of functional interface is

attached with the body of static method is known as reference to

Static method

syntax:

Func_Interface_name ob = Class_name :: method_name;

Ex:

ITest ob3 = Display :: m2;

---------------------------------------------------------

Ex-application:

ITest.java

package p1;

public interface ITest {
public static final int p=600;
public abstract void dis(int k);
}


Display.java

package p1;

public class Display {
public Display(int x) {
System.out.println("****Constructor Body****"); System.out.println("The value x:"+x); }

public void m1(int y) {
System.out.println("****Instance method Body****"); System.out.println("The value y:"+y); }

public static void m2(int z) {
System.out.println("****Static method Body****"); System.out.println("The value z:"+z); }


}


DemoMethodReferences.java(MainClass)

package p2;

import p1.*;
public class DemoMethodReferences {
public static void main(String[] args) { System.out.println("*****LambdaExpression****");

ITest ob = (int k)->
{
System.out.println("The value k:"+k); };

ob.dis(100);
//reference to Constructor ITest ob1 = Display :: new; ob1.dis(200);

Display d = new Display(1);//Con Call //reference to Instance method

ITest ob2 = d :: m1;
ob2.dis(300);
//reference to static method ITest ob3 = Display :: m2; ob3.dis(400);

}

}



o/p:

*****LambdaExpression****

The value k:100

****Constructor Body****

The value x:200


****Constructor Body****

The value x:1

****Instance method Body****

The value y:300

****Static method Body****

The value z:400




Diagram:





































========================================================

*imp

=>The following are the models used in Providing body for abstract

method of Interface:




Model-1 : Using Interface-Implementation classes

(Implementation classes with name)

Model-2 : Using Interface-Anonymous InnerClasses

(Anonymous InnerClasses as implementation classes)

Model-3 : Using LambdaExpressions

Model-4 : Using Method references

=======================================================

*imp

InnerClasses in Interfaces:

=>we can also declare InnerClasses in interfaces and which are

automatically static member InnerClasses




*imp

InnerClasses in AbstractClasses:

=>we can also declare InnerClasses in AbstractClasses and which

can be static member InnerClasses or NonStatic member InnerClasses.




Ex-Program:

ITest.java


package p1;
public interface ITest {

public static class SubClass1{ public void m1(int a) {

System.out.println("***m1(a)****"); System.out.println("The value a:"+a);

}
}//Static member InnerClass }//OuterInterface


AClass.java

package p1;

public abstract class AClass { public static class SubClass2{

public void m2(int x) {
System.out.println("****m2(x)****");
System.out.println("The value x:"+x);
}
}//Static member InnerClass
public class SubClass22{
public void m22(int y) {
System.out.println("****m22(y)****");
System.out.println("The value y:"+y);
}
}//Instance member InnerClass }//OuterClass


DemoInnerClass4.java(MainClass)

package p2;

import p1.*;
public class DemoInnerClass4 {
public static void main(String[] args) {
System.out.println("----InnerClass in Interface-

---");
ITest.SubClass1 ob1 = new ITest.SubClass1();
ob1.m1(11);
System.out.println("---Static InnerClass in
AbstractClass----");
AClass.SubClass2 ob2 = new AClass.SubClass2();

ob2.m2(12);
System.out.println("----Instance InnerClass in

ABstractClass----");
AClass ob = new AClass()
{
//No members
};
AClass.SubClass22 ob22 = ob.new SubClass22(); ob22.m22(13);

}
}


o/p:

----InnerClass in Interface----

***m1(a)****

The value a:11

---Static InnerClass in AbstractClass----

****m2(x)****

The value x:12

----Instance InnerClass in ABstractClass----

****m22(y)****

The value y:13

====================================================

*imp

InnerInterfaces in Java:

(i)InnerInterfaces in Classes:

=>we can also declare InnerInterfaces in Classes and which can

be static member InnerInterfaces or NonStatic member InnerInterfaces.




(ii)InnerInterfaces in Interfaces:

=>we can also declare InnerInterfaces in Interfaces and which

are automatically Static member InnerInterfaces.




(iii)InnerInterfaces in AbstractClasses:

=>we can also declare InnerInterfaces in AbstractClasses and

which can be static member InnerInterfaces or NonStatic member

InnerInterfaces.

------------------------------------------------------

Diagram:



































===========================================================

Dt : 24/5/2023

Ex-Program:(Demonstrating InnerInterfaces)

SubClass.java

package p1;

public class SubClass { public interface ITest1{

public abstract void m1(int a); }//Instance member InnerInterface public static interface ITest11{

public abstract void m11(int b); }//Static member InnerInterface

}//OuterClass


ITest.java

package p1;

public interface ITest {
public static interface ITest2{ public abstract void m2(int x);

}//Static member InnerInterface }//OuterInterface


AClass.java

package p1;

public abstract class AClass { public interface ITest3{
public abstract void m3(int p);
}//Instance member InnerInterface public static interface ITest33{

public abstract void m33(int q); }//Static member InnerInterface

}//OuterAbstractClass


DemoInnerInterface.java(MainClass)

package p2;

import p1.*;
public class DemoInnerInterface { public static void main(String[]

args) {
System.out.println("****Interface in Class****");
SubClass.ITest1 ob1 = (int a)-> {
System.out.println("----m1(a)-

--");
System.out.println("The valu
a:"+a);

};

SubClass.ITest11 ob11 = (int b)-
>
{
System.out.println("----
m11(b)---");
System.out.println("The valu

b:"+b);
};
ob1.m1(11);
ob11.m11(12);
System.out.println("****Interface in Interface****");
ITest.ITest2 ob2 = (int x)-> {
System.out.println("----m2(x)-

--");
System.out.println("The valu
x:"+x);
};
ob2.m2(13);
System.out.println("****Interface in
AbstractClass****");
AClass.ITest3 ob3 = (int p)-> {
System.out.println("----m3(p)-

--");
System.out.println("The valu
p:"+p);
};
AClass.ITest33 ob33 = (int q)-> {
System.out.println("----
m33(q)---");
System.out.println("The valu

q:"+q);
};
ob3.m3(14);
ob33.m33(16);
}
}


o/p:

****Interface in Class****

----m1(a)---

The valu a:11

----m11(b)---

The valu b:12

****Interface in Interface****

----m2(x)---

The valu x:13

****Interface in AbstractClass****

----m3(p)---

The valu p:14

----m33(q)---

The valu q:16

=======================================================

*imp

InnerAbstractClasses in Java:

(i)InnerAbstractClasses in Class:

=>we can also declare InnerAbstractClasses in Classes and which

can be Static member InnerAbstractClasses or NonStatic member

InnerAbstractClasses.




(ii)InnerAbstractClasses in Interfaces:

=>we can also declare InnerAbstractClasses in Interfaces and

which are automatically Static member InnerAbstractClasses.




(iii)InnerAbstractClasses in AbstractClasses:

=>we can also declare InnerAbstractClasses in AbstractClasses

and which can be Static member InnerAbstractClasses or NonStatic

member InnerAbstractClasses




Ex-Program:(Assignment)

==========================================================

*imp

Summary of Programming Components(Java Alphabets)

(a)Variables

1.Primitive Datatype variables(values)

(i)static

(ii)NonStatic

=>Instance

=>Local

2.NonPrimitive Datatype variables(object references)

(i)static

(ii)NonStatic

=>Instance

=>Local

(b)Methods

1.static methods

2.NonStatic methods(Instance methods)




(c)Blocks

1.static blocks

2.NonStatic blocks(Instance blocks)




(d)Constructors

=>NonStatic Constructor





(e)Classes

1.Static Classes(Only InnerClasses as static)

2.NonStatic Classes


(f)Interfaces

1.static Interfaces(Only InnerInterfaces as static)

2.NonStatic Interfaces




(g)AbstractClasses

1.static AbstractClasses(Only InnerAbstractClasses as static)

2.NonStatic AbstractClasses

===========================================================

*imp

Design Models used in Application development:




Design-Model-1 : In this model "Anonymous InnerClass as

implementation class" is declared inside the

method of SubClass.




Diagram:




Ex-program:

ITest.java


package p1;

public interface ITest {
public abstract void m1(int x); public default void m2(int y) {

System.out.println("****default m2(y)****");

System.out.println("The value y:"+y);
}
}


Access.java

package p1;

public class Access {
public static ITest getRef() { ITest ob = new ITest()
{
public void m1(int x)
{

System.out.println("****Implemented m1(x)****");
System.out.println("The value x:"+x);

}
};
return ob;
}//OuterClass method
}

DesignModel1.java(MainClass)

package p2;

import p1.*;
public class DesignModel1 {
public static void main(String[]

args) {
ITest ob = Access.getRef(); ob.m1(11);
ob.m2(12);

}

}


o/p:

****Implemented m1(x)****

The value x:11

****default m2(y)****

The value y:12

--------------------------------------------------------

Design-Model-2 : In this model "LambdaExpression" is declared

inside the method of SubClass.




Diagram:





Ex-program:

ITest.java

package p1;

public interface ITest {
public abstract void m1(int x); public default void m2(int y) {

System.out.println("****default m2(y)****");

System.out.println("The value y:"+y);

}

}


Access.java

package p1;

public class Access {
public static ITest getRef() { return (int x)->
{

System.out.println("****Implemented m1(x)****");

System.out.println("The value x:"+x);

};


}//OuterClass method

}


DesignModel2.java(MainClass)

package p2;

import p1.*;
public class DesignModel2 {
public static void main(String[]

args) {
ITest ob = Access.getRef();
ob.m1(11);
ob.m2(12);
}
}


o/p:

****Implemented m1(x)****

The value x:11

****default m2(y)****

The value y:12

============================================================

Dt : 25/5/2023

*imp

Exception Handling process in Java:





define Exception?

=>The disturbance which is occured from the application is known

as Exception.




define Exception handling process?

=>The process which is used to handle the exception is known as

Exception handling process.

=>The following blocks are used in exception handling process:

1.try

2.catch

3.finally

=>These blocks are executed automatically when exception is raised

----------------------------------------------------

1.try:

=>"try" block will hold the statements which are going to raise

the exception.

syntax:

try

{

//statements

}





Execution behaviour of try:

=>when exception raised in try-block then one object is created

for exception-type-class and the object-reference is thrown onto

catch block.




2.catch:

=>"catch" block will hold the object reference thrown from the

"try" block and the required msg generated from the catch-block.

syntax:

catch(Exception-type-class ref-var)

{

//msg

}




3.finally:

=>"finally" block is part of exception handling process but

executed independently without depending on exception.

=>In realtime finally-block will hold resource closing operations

like IO Close,file close,DB close,...

syntax:

fially

{


//statements

}

=============================================================




*imp

Use the following steps to handle User defined exception:




step-1 : The user defined class must be extended from pre-defined

java.lang.Exception class




step-2 : The user defined class must be declared with parameterized

constructor with string as parameter.




step-3 : The parameterized constructor will pass the msg to Parent

class "Exception" using "super()"




step-4 : declare exception-condition




step-5 : If the exception-condition is "true" then create object

for User defined class and while object creation pass

exception-msg as parameter





step-6 : Throw the object-reference onto catch block using "throw"

keyword




step-7 : Display the msg from the catch block

--------------------------------------------------------------

Ex-program:

wap to read bSal of an employee and calculate totSal?

(using Exception handling process)




Program : DemoException1.java

package maccess;

import java.util.*;
public class DemoException1 extends Exception
{
public DemoException1(String msg)
{
super(msg);
}
public static void main(String[] args)
{
Scanner s = new Scanner(System.in); try

{
System.out.println("Enter the emp bSal:"); int bSal = s.nextInt();//Exception for

NonInteger value
if(bSal<12000)//Exception
{
DemoException1 ob =
new DemoException1("Invalid
bSal..");

throw ob;

}
float totSal =

bSal+(0.93F*bSal)+(0.61F*bSal);
System.out.println("****Details****");

System.out.println("BSal:"+bSal);
System.out.println("TotSal:"+totSal);

}

catch(InputMismatchException ime)
{
System.out.println("Enter only Integer
value...");
}
catch(DemoException1 ob)
{
System.out.println(ob.getMessage());
}
finally
{
s.close();
}
}
}


o/p:

Enter the emp bSal:

15000

****Details****

BSal:15000

TotSal:38100.0





Diagraam-1:(Demonstrating Pre-defined Exception)

























Diagram-2:(Demonstrating User defined Exception)





























==============================================================

Dt : 26/5/2023

define 'Throwable'?

=>"Throwable" is a class from java.lang package and which is

root of exception handling process.

=>This "Throwable" class is extended to the following two

SubClasses:

1.Error class

2.Exception class




Hierarchy of Throwable:


-----------------------------------------------------

1.Error class:

=>The distrurbance which is occured from the environment is known

as error.

=>"java.lang.Error" class is the SuperClass or ParentClass of all

the errors occurs from the environment.

=>There is no separate process to handle the error.




2.Exception class:

=>The disturbance which is occured from the application is known

as exception.

=>"java.lang.Exception" class is the SuperClass or ParentClass of

all the exceptions raised from the application.

---------------------------------------------------------------

*imp

Types of exceptions:

=>The exceptions raised from the application are categorized into

two types:

1.UnChecked Exceptions

2.Checked Exceptions





1.UnChecked Exceptions:

=>The exceptions which are not identified by the compiler at

Compilation stage will be raised at execution stage are known as

UnChecked Exceptions or Runtime Exceptions.




2.Checked Exceptions:

=>The exceptions which are identified and raised by the compiler

at compilation stage are known as Checked Exceptions or Compile

time exceptions




Diagram:




































============================================================

*imp

Types of UnChecked Exceptions:

=>Unchecked Exceptions are categorized into two types:

(a)Pre-defined UnChecked Exceptions

(b)User defined UnChecked Exceptions




(a)Pre-defined UnChecked Exceptions:

=>The UnChecked exceptions which are defined and available from

JavaLib are known as Pre-defined UnChecked Exceptions or Built-in

UnChecked Exceptions.

Ex:

java.util.InputMismatchException

java.lang.NumberFormatException

...




(b)User defined UnChecked Exceptions:

=>The UnChecked Exceptions which are defined by the programmer

are known as User defined UnChecked Exceptions.




Ex:

above program : DemoException1.java

==============================================================

Ex-2 :

wap to raed 6 sub marks and calculate,totMarks and percentage?

(Validate marks using Exception handling process)




Program : DemoException2.java

package maccess;

import java.util.*;
public class DemoException2 extends Exception
{

public DemoException2(String msg)
{

super(msg);
}
public static void main(String[] args)
{
Scanner s = new Scanner(System.in); try

{
System.out.println("Enter number of Subjects:");

int n = Integer.parseInt(s.nextLine()); //Exception for NonInteger value

int i=1,totM=0;
System.out.println("Enter the "+n+" Sub marks...");

while(i<=n)
{
try
{
System.out.println("Enter the marks of
sub-"+i);
int sub =
Integer.parseInt(s.nextLine());
//Exception for NonInteger value if(sub<0 || sub>100)//Exception

{
DemoException2 ob =
new
DemoException2("Invalid Marks.."); throw ob;

}
totM=totM+sub;
i++;
}
catch(NumberFormatException nfe)
{
System.out.println("Enter Only Integer
value");

}
catch(DemoException2 ob)
{

System.out.println(ob.getMessage());
}
}//end of of loop
System.out.println("****details****");
System.out.println("TotalMarks:"+totM);
float per = (float)totM/n;
System.out.println("Percentage:"+per);
}
catch(NumberFormatException e)
{
System.out.println("Enter only Integer value..");

}
finally
{
s.close();
}

}

}



o/p:

Enter number of Subjects:

8

Enter the 8 Sub marks...

Enter the marks of sub-1

78

Enter the marks of sub-2

89

Enter the marks of sub-3

90

Enter the marks of sub-4

95

Enter the marks of sub-5

96

Enter the marks of sub-6

97

Enter the marks of sub-7

95

Enter the marks of sub-8

94

****details****

TotalMarks:734

Percentage:91.75




=============================================================

Dt : 27/5/2023

*imp

Types of Checked Exceptions:

=>Checked Exceptions are categorized into two types:

(a)Pre-defined Checked Exceptions

(b)User defined Checked Exceptions




(a)Pre-defined Checked Exceptions:

=>The Checked Exceptions which are defined and available from

JavaLib are known as Pre-defined Checked Exceptions or Built-in

Checked Exceptions.

Ex:

java.lang.ClassNotFoundException

java.lang.CloneNotSupportedException

java.io.IOException

java.sql.SQLException




----------------------------------------------------------

faq:

define forName() method?

=>forName() method is from "java.lang.Class" and which is used

to load the class at runtime or execution time,which means the class

is loaded at execution stage.




Method Signature:

public static java.lang.Class<?> forName(java.lang.String)

throws java.lang.ClassNotFoundException;







syntac:

Class c = Class.forName("Class_name");




Note:

=>"throws" keyword with method signature specify to raise the

exception at method call.

=>when exception raised at method call,then compiler will identify

the exception and comes under Checked Exception or Compile time

Exception.

----------------------------------------------------

Note:

=>"new" keyword cannot create object for the class loaded at

execution time or runtime.

=>we use newInstance() method from java.lang.Class to create

object for the class loaded at runtime or execution time.


Method Signature:

public T newInstance() throws java.lang.InstantiationException,

java.lang.IllegalAccessException;




Ex-program :

Display.java

package p1;

public class Display {
public void dis(int x) {
System.out.println("****method dis(x)****"); System.out.println("The value x:"+x);

}
}


DemoException3.java

package p2;

public class DemoException3 {
public static void main(String[] args) { try

{
Class c =
Class.forName("p1.Display");//method_call
p1.Display ob = (p1.Display)c.newInstance();

ob.dis(123);
}
catch(ClassNotFoundException cnfe)
{
cnfe.printStackTrace();
}
catch(InstantiationException ie)
{

ie.printStackTrace();
}

catch(IllegalAccessException iae)
{
iae.printStackTrace();
}
Display d = new Display(); //d.dis(123);

}
}





o/p:

****method dis(x)****

The value x:123

===========================================================

Assignment:

Convert BankTransaction process-Model- 1 into Exception Handling

process.

===============================================================

Dt : 29/5/2023

*imp

(b)User defined Checked Exceptions

=>The Checked Exceptions which are defined and raised by the

programmer are known as User defined Checked Exceptions.

=>The use the following steps to define and raise user defined

Checked Exceptions:

step-1 : Add "throws" keyword to method signature and raise the

exception at method call




step-2 : Add "throw" keyword in catch-block and perform re-throwing

process.




Program :

Calculate.java

package p1;

@SuppressWarnings("serial")
public class Calculate extends Exception
{
public Calculate(String msg)
{
super(msg);
}
public double cal(double val)throws Calculate
{

try

{
if(val<=0)//Exception

{
Calculate c2 = new Calculate
("Enter Only +ve numeric

val...");
throw c2;
}
return Math.sqrt(val);
}//end of try
catch(Calculate c2)
{
throw c2;//re-throwing
}
}
}


DemoException4.java(MainClass)

package p2;

import p1.Calculate;

import java.util.*;

public class DemoException4

{

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try

{

System.out.println("Enter the value to cal SQRT:");

double v = Double.parseDouble(s.nextLine());

Calculate c1 = new Calculate("");

double res = c1.cal(v);

System.out.println("SQRT of "+v+" is "+res);

}//end of try

catch(Calculate ob)

{

System.out.println(ob.getMessage());

}

catch(NumberFormatException nfe)

{

System.out.println("Enter only Numeric value...");

}

finally

{

s.close();

}

}

}

o/p:

Enter the value to cal SQRT:

1234.56

SQRT of 1234.56 is 35.136306009596396


Diagram:















































=============================================================

faq:

define Exception re-throwing process?

=>The process of declaring "throw" keyword in catch-block and

throwing the exception is known as Exception re-throwing process.

=>In Exception re-throwing process the exception is thrown to

the catch-block of try-block where method call is declared.




faq:

define Exception Propagation?

=>In Exception re-throwing process the exception is moved from

one method to another method is known as Exception Propagation.

=============================================================

faq:

wt is the diff b/w

(i)throw

(ii)throws




(i)throw:

=>"throw" keyword will throw the object reference onto catch

block.




(ii)throws:

=>"throws" keyword added with method signature and raise the

exception at method call

=============================================================

faq:

define Annotation?

Annotations in Java are a form of metadata that can be added to various elements of a program, such as classes, interfaces, methods, variables, and more. They provide additional information about the code to the compiler, runtime environment, or other tools.



=>The tag based information which is added to the programming

component Class,Interface,method,variable is known as Annotation.

=>we use "@" symbol to add annotations in Java.

=>Annotations will provide information to compiler at compilation

stage.

=>The following are some important annotations in CoreJava:

(i)@SuppressWarnings

(ii)@Override




(i)@SuppressWarnings:

=>"@SuppressWarnings" annotation will give information to

compiler to close the raised warnings.




(ii)@Override:

=>"@Override" annotation will give information to Compiler to

check the method is Overriding method or not.

===========================================================


Annotations can serve multiple purposes, including:

Providing information to the compiler: Annotations can be used to specify additional details about classes, methods, or variables that the compiler can use for processing or verification. For example, the "@Override" annotation indicates that a method is intended to override a superclass method, and the compiler will generate an error if the method doesn't actually override any method.

Enabling runtime processing: Some annotations are used by the runtime environment or frameworks to perform certain actions or configurations at runtime. For example, the "@Entity" annotation in Java Persistence API (JPA) marks a class as an entity to be persisted in a database.

Documentation and code organization: Annotations can be used to generate documentation or provide hints and guidelines to developers. For example, the "@Deprecated" annotation indicates that a method or class is deprecated and should not be used anymore.

Customization and extension: Annotations can be created by developers to define custom behaviors, configurations, or restrictions within their code or frameworks.

Dt : 1/6/2023

*imp

Handling Multiple Exceptions:

=>We use the following two ways to handle multiple exceptions:

(i)Using Multiple catch blocks to a try block

syntax:

try

{

//Exception-1

//Exception-2

}

catch(Exception-1 ob)

{

//msg

}

catch(Exception-2 ob)

{

//msg

}





(ii)From Java7 version onwards we use single catch-block to a

try-block

syntax:

try

{

//Exception-1

//Exception-2

}

catch(Exception-1 | Exception-2 | ... ob)

{

//msg

}

================================================================

faq:

define try-with-resource?

=>try-with-resource statement is introduced by Java7 version and

in which the try is declared with resource.

syntax:

try(resource1;resource2;...)

{

//statements

}





Ex:

try(Scanner s = new Scanner(System.in);)

{

//statements

}




Advantage:

=>In try-with-resource statement the resources are closed

automatically,which means no need to use finally-block.

=>In try-with-resource statement catch-block is not manditory,

which means catch-block is optional.




Coding Rule:

=>The resource-class which is used in try-with-resource Statement

must be implementation class of "java.lang.AutoCloseable" interface.




Ex:

"Scanner-class" is implementation of "AutoCloseable" interface




Diagram:
It's important to note that for a resource class to be used with "try-with-resources", it must implement the AutoCloseable interface or its sub-interface, Closeable. Otherwise, a compilation error will occur.



























============================================================

faq:

define Enhanced try-with-resource statement?

=>Enhanced try-with-resource statement introduced by Java9

version and in which the resources are declared outside the try and

resource-ref-variables are declared with try.




syntax:

resource1;resource2;...

try(res1_var;res2_var;...)

{


//statements

}




Ex:

Scanner s = new Scanner(System.in);

try(s;)

{

//statements

}

==============================================================

Ex : BankTransaction-Model




Balance.java

CheckPinNo.java

Transaction.java

WithDraw.java

Deposit.java

=>Code not modified




DemoException5.java

(MainClass Modified with Exception handling process)

package p2;

import java.util.*;

import p1.*;

@SuppressWarnings("serial")

public class DemoException5 extends Exception

{

public DemoException5(String msg)

{

super(msg);

}

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try(s;){

int count=0;

xyz:while(true) {

try

{

System.out.println("Enter the PinNo:");

int pinNo = s.nextInt();

if(!(pinNo>=1111 && pinNo<=9999))//Exception

{

DemoException5 de = new


DemoException5

("Invalid pinNo..");

throw de;

}

CheckPinNo cpn = new CheckPinNo();

boolean k = cpn.verify(pinNo);

if(!k)//Exception

{

DemoException5 de = new

DemoException5

("PinNo donot exits...");

throw de;

}

System.out.println("****Choice****");

System.out.println("\t1.WithDraw"

+ "\n\t2.Deposit");

System.out.println("Enter the Choice:");

switch(s.nextInt()) {

case 1:

try

{

System.out.println("Enter the


amt:");

int a1 = s.nextInt();

if(!(a1>0 &&

a1%100==0))//Exception

{

DemoException5 de = new

DemoException5

("Invalid amt..");

throw de;

}

WithDraw wd = new WithDraw();

wd.process(a1);

}//end of try

catch(DemoException5 ob)

{



System.out.println(ob.getMessage());

break xyz;

}

break xyz;

case 2:

try

{

System.out.println("Enter the

amt:");

int a2 = s.nextInt();

if(!(a2>0 &&

a2%100==0))//Exception

{

DemoException5 de = new

DemoException5

("Invalid amt..");

throw de;

}

Deposit dp = new Deposit();

dp.process(a2);

}//end of try

catch(DemoException5 ob)

{

System.out.println("Invalid amt..");

}

break xyz;

default:

System.out.println("Invalid Choice...");

}//end of switch

}//end of try

catch(DemoException5 ob)

{

System.out.println(ob.getMessage());

count++;

if(count==3)

{

System.out.println("Transaction

blocked..");

break xyz;//stop the loop

}

}

}//end of loop

}//end of try

}

}

========================================================

Dt : 2/6/2023

faq:

wt is diff b/w

(i)getMessage()

(ii)toString()

(iii)printStackTrace()







(i)getMessage():

=>getMessage() method is used to display only msg available

exception object.

syntax:

String msg = ob.getMessage();




(ii)toString():

=>toString() method is used to display exception-class and

msg.

syntax:

String msg = ob.toString();





(iii)printStackTrace():

=>printStackTrace() method is used to display the complete details

of exception like exception-class-name,msg,method_name and Line_no.

syntax:

ob.printStackTrace();

==========================================================

faq:

wt is the diff b/w

(i)InputMismatchException

(ii)NumberFormatException




=>exception in parseMethods will be NumberFormatException.

=>exception in Scanner-methods will be InputMismatchException




faq:

define NullPointerException?

=>"NullPointerException" is raised when we perform operations

using NonPrimitive datatype variables holding "null" value.







EX-program : DemoException6.java(MainClass)

package maccess;

import java.util.*;
public class DemoException6
{

public static String name;
public static void main(String[] args)

{
Scanner s = new Scanner(System.in);
try(s;)
{
try
{
System.out.println("Enter the value-1:"); int v1 =

Integer.parseInt(s.nextLine());
System.out.println("Enter the value-
2:");
int v2 = s.nextInt();
System.out.println("*****Values****"); System.out.println("Value-1:"+v1); System.out.println("Value-2:"+v2); System.out.println("Name : "+name); System.out.println("length of name :

"+name.length());
}
catch(InputMismatchException | NumberFormatException ob)

{
System.out.println("Only Integer
values...");
System.out.println(ob.getClass());
}
catch(NullPointerException npe)
{
System.out.println("Using Reference Variable holding null value..");

System.out.println(npe.getClass());
}
}//end of try with resource


}


}

o/p:

Enter the value-1:

12

Enter the value-2:

13

*****Values****

Value-1:12

Value-2:13

Name : null

Using Reference Variable holding null value..

class java.lang.NullPointerException

======================================================

*imp

PolyMorphism in Java:

=>The process in which programming components having more than

one form is known as PolyMorphism.

Poly  - Many

Morphism - Forms

=>PolyMorphism is categorized into two types:

1.Dynamic PolyMorphism

2.Static PolyMorphism

1.Dynamic PolyMorphism:

=>The PolyMorphism at execution stage is known as Dynamic

PolyMorphism or Runtime PolyMorphism.

Ex:

Method Overriding process.




Note:

=>Through Method Overriding process we can provide more than

one form of same method at execution stage,because of this reason

Method Overriding process comes under Dynamic PolyMorphism.




2.Static PolyMorphism:

=>The PolyMorphism at compilation stage is known as Static

PolyMorphism or Compile time PolyMorphism.

Ex:

Method Overloading process




Note:

=>Through Method Overloading process we can provide more than

one form by changing para_list or para_type at compilation stage,

because of this reason Method Overloading process comes under

Static PolyMorphism or Compiletime PolyMorphims

Ex:

add(int,int)

add(int,int,int)

add(int,float)




public class Addition

{

public void add(int x,int y) {}

public void add(int x,int y,int z) {}

public void add(int x,float y) {}




}

=========================================================

*imp

=>Compiler at compilation stage will understand the behaviour of

the following keywords:

1.static

2.private

3.final





1.static:

=>The following are the static programming components:

(a)static variables

(b)static methods

(c)static blocks

(d)static classes

(e)static Interfaces

(f)static AbstractClasses

=>There is no concept of static Constructors in Java.

-----------------------------------------------------------

*imp

2.private:

=>The following are the private programming components:

(a)private variables

(b)private methods

(c)private Constructors

(d)private Classes

=>There is no concept of private blocks,private Interfaces and

private abstractclasses.

Dt : 3/6/2023

(a)private variables:

=>The variables which are declared with "private" keyword are

known as private variables

Coding Rule:

=>Private variables are accessed by the methods of same class.




(b)private methods:

=>The methods which are declared with private keyword are

known as private methods.

Coding Rule:

=>private methods are accessed by the NonPrivate methods of

Same class.




Note:

=>In realtime private variables are used in Bean classes of Servlet

programming.

=>In realtime private methods are less used.





*imp

(c)private Constructors:

=>The Constructors which are declared with private keyword are

known as private Constructors.

Coding Rule:

=>Private Constructor is executed when the object is created

inside the same class where private Constructor is declared.




Note:

=>In realtime private constructors are used to restrict object

creations from externally(outside the class).




(d)private Classes:

=>The classes which are declared with private keyword are known

as private classes.

=>These private classes can be declared only as InnerClass,which

means we cannot declare OuterClasses as private.

Coding Rule:

=>Private Classes objects are created inside the same class

where they are declared.

Note:

=>In realtime private classes are used part of Security.





Ex-program:

Display.java
package maccess;

public class Display {
private int a=10;
private static int b=20;
private Display() {}
public static Display d = new Display();//Con_call private void dis1() {

System.out.println("***Instance private dis1()****");

System.out.println("The value a:"+a); System.out.println("The value b:"+b);

}
private static void dis2() {
System.out.println("***Static private
dis2()****");
//System.out.println("The value a:"+a); System.out.println("The value b:"+b);

}
private class SubClass1{
public void m1() {
System.out.println("---InnerClass m1()---"); System.out.println("The value a:"+a); System.out.println("The value b:"+b);

}
}//private Instance member InnerClass private SubClass1 ob1 = new SubClass1(); private static class SubClass2{

public void m2() {
System.out.println("---InnerClass m2()---");
//System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
}
}//private Static member InnerClass private SubClass2 ob2 = new SubClass2(); public void access() {

this.dis1();
Display.dis2();
ob1.m1();
ob2.m2();

}
}



DemoPoly1.java(MainClass)

package maccess;

public class DemoPoly1 {
public static void main(String[] args) { Display.d.access();

}
}


o/p:

***Instance private dis1()****

The value a:10

The value b:20

***Static private dis2()****

The value b:20

---InnerClass m1()---

The value a:10

The value b:20

---InnerClass m2()---

The value b:20

----------------------------------------------------------

Note:

=>Private method Overriding process is not available,but we can

perform Private method Overloading process.


Ex-program:

PClass.java

package maccess;

public class PClass {
private void m1(int x) {

System.out.println("===PClass m1(x)===");
System.out.println("The value x:"+x);
}
}


CClass.java

package maccess;

public class CClass extends PClass{ private void m1(int x) {

System.out.println("===CClass m1(x)==="); System.out.println("The value x:"+x);

}
private void m1(int x,int y) {
System.out.println("===CClass m1(x,y)===");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);

}

public void access() {
this.m1(11);
this.m1(12, 13);
}
}


DemoPoly2.java(MainClass)


package maccess;

public class DemoPoly2 {
public static void main(String[] args) {
CClass ob = new CClass();

ob.access();
}
}


o/p:

===CClass m1(x)===

The value x:11

===CClass m1(x,y)===

The value x:12

The value y:13

=============================================================

*imp

3.final:

=>The following are the final programming components:

(a)final variables

(b)final methods

(d)final classes

=>There is no concept of final blocks,final constructors,final

Interfaces and final AbstractClasses.





(a)final variables:

=>The variables which are declared with "final" keyword in

classes are known as final variables.

Coding Rule:

=>final variables must be initialized with values and once

initialized cannot be modified.

(final variables are also known as constant variables or Secured

variables)

Note:

=>final varibles in classes can be intialized using Constructor.




(b)final methods:

=>The methods which are declared with final keyword are known as

final methods.

Coding Rule:

=>final methods cannot be overrided.




(d)final classes:

=>The classes which are declared with final keyword are known

as final classes.

Coding Rule:

=>final classes cannot be extended,which there is no inheritance

process for final classes.

-------------------------------------------------------

Note:

=>In realtime using final programming components we can construct

"Immutable Classes".

--------------------------------------------------------

*imp

define Immutable Classes?

=>The classes which are declared with the following rules are

known as Immutable Classes.

Rule-1 : The classes must be final classes

Rule-2 : The variables in classes must be "private and final"

(These variables are initialized with constructor)

Rule-3 : The classes must be declared only with "Getter methods"

Rule-4 : These "Getter methods" must be final methods




Note:

=>These Immutable Classes will generate "Immutable Objects",which

means the Objects once created cannot be modified.

(Immutable Objects are also known as Constant Objects or Secured

Objects)

---------------------------------------------------------------


Immutable objects provide numerous advantages in programming:

1.Thread Safety: Immutable objects are inherently thread-safe, as their state cannot be modified once created. This eliminates the need for locks or synchronization mechanisms when working with multiple threads, simplifying concurrent programming and reducing the risk of data inconsistency or race conditions.
2.Simplified and Predictable Behavior: Immutable objects have a fixed state that cannot be changed. This makes their behavior predictable, as you can rely on their state remaining constant throughout the program. This simplifies debugging and reasoning about code, leading to fewer bugs and easier maintenance.
3.Caching and Reusability: Immutable objects can be safely cached and shared among different parts of the program. Since their state remains constant, they can be reused without concern for side effects or unexpected changes. This improves performance by reducing the need for object creation and garbage collection.
4.Security and Integrity: Immutable objects are resistant to unauthorized modifications, making them useful in security-critical scenarios. They ensure the integrity of data, as the object's state cannot be tampered with once created. Immutable objects can be safely passed between components without fear of their values being compromised.
5.Hashability: Immutable objects can be easily used as keys in hash-based data structures, such as HashMaps or HashSets. Since the object's state is constant, its hash code remains the same, ensuring consistent behavior when used in collections.
Overall, the use of immutable objects promotes safer, more efficient, and more maintainable code. By preventing changes to the object's state, you can avoid synchronization issues, simplify code logic, improve performance, and ensure data integrity.

Dt : 5/6/2023

Ex-program : (Demonstrating Immutable Classes)

TransLog.java

package test;

import java.util.Date;
public final class TransLog {
private final long hAccNo,bAccNo;
private final float amt;
private final Date dTime;
public TransLog(long hAccNo,long bAccNo,float amt, Date dTime) {

this.hAccNo=hAccNo;
this.bAccNo=bAccNo;
this.amt=amt;
this.dTime=dTime;
}
public final long gethAccNo() { return hAccNo;

}
public final long getbAccNo() { return bAccNo;

}
public final float getAmt() { return amt;

}
public final Date getdTime() { return dTime;

}

}



DemoPoly3.java(MainClass)

package maccess;


import java.util.*;

import test.TransLog;

public class DemoPoly3 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter Home AccNo:");

long hAccNo = s.nextLong();

System.out.println("Enter beneficiery AccNo:");

long bAccNo = s.nextLong();

System.out.println("Enter the amt to be transferred:");

float amt = s.nextFloat();

Date dTime = new Date();

TransLog ob = new TransLog(hAccNo,bAccNo,amt,dTime);

System.out.println("====Display Trans-Details====");

System.out.println("HAccNo:"+ob.gethAccNo());

System.out.println("BAccNo:"+ob.getbAccNo());

System.out.println("Amount:"+ob.getAmt());

System.out.println("DateTime:"+ob.getdTime());

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter Home AccNo:

6123456

Enter beneficiery AccNo:

313131

Enter the amt to be transferred:

5000

====Display Trans-Details====

HAccNo:6123456

BAccNo:313131

Amount:5000.0

DateTime:Mon Jun 05 18:36:42 IST 2023

==============================================================

Note:

=>In realtime Immutable Objects are used to hold transaction

details in Banking Domain applications and these Immutable Objects

are stored in Database.

=============================================================

*imp

"Record" in Java:(Java17 - new feature)

=>"Record" is an abstract class from java.lang package and which

is used to generate record-objects and which are Immutable Objects.

=>The following is the structure of "Record" and which is

introduced by Java17 version:




public abstract class java.lang.Record

{

protected java.lang.Record();

public abstract boolean equals(java.lang.Object);

public abstract int hashCode();

public abstract java.lang.String toString();

}




=>we use the following pre-defined standard syntax to create

record-objects:




record Record name(para list)


{

//record body


}





Ex-Program:

TransLog.java
package test;

import java.util.*;
public record TransLog(long hAccNo,long bAccNo,float amt,

Date dTime)
{
public TransLog
{
if(amt<=0)
{
throw new IllegalArgumentException("Invalid
amt");
}
}
}


DemoRecord.java(MainClass)

package maccess;

import java.util.*;

import test.TransLog;

public class DemoRecord {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter the hAccNo:");

long hAccNo = s.nextLong();

System.out.println("Enter the bAccNo:");

long bAccNo = s.nextLong();

System.out.println("Enter the amt to be transferred:");

float amt = s.nextFloat();

Date dTime = new Date();

TransLog ob = new TransLog(hAccNo,bAccNo,amt,dTime);

//Con_Call

System.out.println("===Display Trans-details===");

System.out.println("HAccNo:"+ob.hAccNo());

System.out.println("BAccNo:"+ob.bAccNo());

System.out.println("Amt:"+ob.amt());

System.out.println("HAccNo:"+ob.dTime());




}catch(Exception e) {

System.out.println(e.getMessage());

}

}//end of try

}




}

o/p:

Enter the hAccNo:

4545123

Enter the bAccNo:

232323

Enter the amt to be transferred:

7000

===Display Trans-details===

HAccNo:4545123

BAccNo:232323

Amt:7000.0

HAccNo:Mon Jun 05 19:05:01 IST 2023

------------------------------------------------------

Advantages of Record:

(i)Auto generated Parameterized contructor to initialize instance

Variables and the Constructor is known as "Canonical

Constructor"

(ii)Auto generated "Getter methods" to display the data from the

Objects.

(iii)Record is used to replace Immutable Classes part of

application development.

------------------------------------------------------

Note:

=>we use "Compact Constructor" in records to validate parameters

=================================================================

*imp

Sealed classes in Java:(Java17 - new feature)

=>The classes which are declared with "sealed" keyword are known

as "sealed classes" and these sealed classes will specify the

permission for extention using "permits" keyword




syntax:

sealed class Class_name permits Class1,Class2,...


{

//body

}


can i create object for sealed class?

No, you cannot directly create an object of a sealed class in Java. Sealed classes are designed to have a limited set of subclasses that are explicitly defined within the sealed class declaration. They provide control over the inheritance hierarchy by restricting the subclasses to a specific set.

Sealed classes are typically used when you want to define a closed set of subclasses that can extend the sealed class. To create an instance of a sealed class, you need to create an object of one of its subclasses.


Coding Rules:

(i)sealed classes must specify the permissions.

(ii)The classes which are extended from sealed classes must be

final classes or non-sealed classes or another sealed class




Ex:

A.java

package test;

public sealed class A permits B,C,D
{
public void mA()
{
System.out.println("***mA()****");

}
}



B.java

package test;

public final class B extends A
{
public void mB()
{
System.out.println("***mB()***");
}
}


C.java

package test;

public non-sealed class C extends A
{
public void mC()
{
System.out.println("***mC()***");
}
}


D.java

package test;

public sealed class D extends A permits E

{
public void mD()
{
System.out.println("***mD()****");
}
}



E.java
package test;

public final class E extends D
{
public void mE()
{
System.out.println("***mE()***");
}
}


DemoSealed.java(MainClass)

package maccess;

import test.*;
public class DemoSealed {
public static void main(String[] args) { System.out.println("-----Class-B----");

B ob1 = new B();
ob1.mA();
ob1.mB();
System.out.println("-----Class-C----");
C ob2 = new C();
ob2.mA();
ob2.mC();
System.out.println("-----Class-E----");
E ob3 = new E();
ob3.mA();
ob3.mD();
ob3.mE();
}
}


o/p:

-----Class-B----

***mA()****


***mB()***

-----Class-C----

***mA()****

***mC()***

-----Class-E----

***mA()****

***mD()****

***mE()***




Diagram:

























===================================================

Benefits of sealed classes:

1.Enhanced encapsulation and abstraction: Sealed classes define a closed set of subclasses that are tightly related, improving encapsulation and abstraction in your code.
2.Improved maintainability: By restricting the set of subclasses, sealed classes help maintain a stable and predictable inheritance hierarchy, reducing the chances of unintended or incompatible subclass extensions.
3.Support for pattern matching: Sealed classes work in conjunction with pattern matching, enabling exhaustive checking at compile-time and enhancing type-based conditional logic.
4.Foundation for future language features: Sealed classes provide a foundation for potential future language features and enhancements that rely on a well-defined and controlled class hierarchy.
Overall, sealed classes in Java offer a way to define closed hierarchies, promoting code maintainability, encapsulation, and abstraction. They provide better control over inheritance and enable the adoption of future language features


Dt : 6/6/2023

Selead Interfaces in Java:

=>The interfaces which are declared with "selead" keyword are

known as sealed-interfaces.

=>selead interfaces must specify the permissions for

implementation classes.

=>The implementation classes can be final classes or non-sealed

classes or sealed classes.




structure of sealed interfaces:

sealed interface Interface_name

{

//body

}




Ex-Program:

ITest.java

package test;

public sealed interface ITest permits IClass{ public abstract void m1(int x);

public default void m2(int y) {
System.out.println("****default m2(y)****"); System.out.println("The value y:"+y); }

}


IClass.java

package test;

public non-sealed class IClass implements ITest{ public void m1(int x) {

System.out.println("****m1(x)****"); System.out.println("The value x:"+x);

}
}


DemoSealed2.java(MainClass)

package maccess;

import test.*;
public class DemoSealed2 {
public static void main(String[] args) { IClass ob = new IClass(); ob.m1(11);

ob.m2(12);
}

}


o/p:

****m1(x)****

The value x:11

****default m2(y)****

The value y:12





============================================================

*imp

=>Based on Security the objects in java are categorized into two

types:

(i)Mutable Objects

(ii)Immutable Objects




(i)Mutable Objects:

=>The Objects once created can be modified are known as Mutable

Objects.




(ii)Immutable Objects:

=>The Objects once created cannot be modified are known as

Immutable Objects.

=>These Immutable Objects are also known as Constant Objects or

Secured Objects.

==========================================================

*imp

Strings in Java:

=>The sequenced collection of characters which are represented in

double quotes is known as string.

Ex:

"hyd","nit",...

=>Characters in string are organized based on index values.

=>Strings in java are not Arrays.

=>The following are pre-defined classes from java.lang package

to create string-objects:

1.String class

2.StringBuffer class

3.StringBuilder class




1.String class:

=>The objects which are generated from "java.lang.String" class

are automatically Immutable objects.

=>16 Constructors by Java8 version and 15 Constructors from

Java17 version.

=>we use the following syntaxes to create "String-class" objects:

syntax-1 : Using "String literal process"

String s1 = "nit";

syntax-2 : Using "new" operator process

String s2 = new String("hyd");




Diagrams:





































Hierarchy of "String":




























------------------------------------------------------

Ex-program-1 : DemoString1.java

package maccess;

public class DemoString1 {
public static void main(String[] args) { System.out.println("****String Literal
Process***");
String s1 = "nit";
int len1 = s1.length();

char ch1 = s1.charAt(1);
System.out.println("s1 : "+s1.toString());
System.out.println("length of s1 : "+len1); System.out.println("char at index 1 : "+ch1); System.out.println("****new operator

process****");
String s2 = new String("Hyd"); int len2 = s2.length(); char ch2 = s1.charAt(0);

System.out.println("s2 : "+s2.toString());
System.out.println("length of s2 : "+len2);
System.out.println("char at index 0 : "+ch2);

}

}


o/p:

****String Literal Process***

s1 : nit

length of s1 : 3

char at index 1 : i

****new operator process****

s2 : Hyd

length of s2 : 3

char at index 0 : n

===============================================

faq:

define length() method?

=>length() method is used to find the length of Strings.

syntax:

int len = s1.length();




faq:

define chatAt() method?

=>charAt() method is used to retrieve char from the string based

on index value.

syntax:

char ch = s1.charAt(index);




faq:

define toString() method?

=>toString() method is used to display the content from the Object

syntax:

String data = s1.toString();




Note:

=>toString() method is auto executable method and which is

executed automatically when we display object reference variable.

==============================================================

Assignment:

wap to display the String in reverse?

==============================================================

Dt : 7/6/2023

Assignment:

wap to display the String in reverse?

program : DemoString2.java

package maccess;

import java.util.*;
public class DemoString2 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the String:"); String str = s.nextLine(); System.out.println("====Normal

String===");
System.out.println("Str :
"+str.toString());
int len = str.length();
System.out.println("length of str :"+len); System.out.println("****String-

reverse****");
for(int i=len-1;i>=0;i--)
{
char ch = str.charAt(i);
System.out.print(ch);
}//end of loop
}catch(Exception e) {e.printStackTrace();} }//end of try with resource

}
}


o/p:

Enter the String:


java program

====Normal String===

Str : java program

length of str :12

****String-reverse****

margorp avaj

=======================================================

faq:

define ASCII code?

=>ASCII stands for "American Standard Code for Information

Interchange" and which is a numeric value generated for each

character entered from the keyboard.




UpperCase Letters(A to Z) : 65 to 90






Program : DemoString3.java

package maccess;

public class DemoString3 {
public static void main(String[] args) { System.out.println("****UpperCase

Letters****");
for(int i=65;i<=90;i++)

{
char ch = (char)i;//Convert ASCII to char System.out.print(ch+" ");
}//end of loop

System.out.println("\n****LowerCase Letters****");

for(int i=97;i<=122;i++)
{
char ch = (char)i;//Convert ASCII to char System.out.print(ch+" "); }//end of loop

System.out.println("\n****Numeric Numbers****");

for(int i=48;i<=57;i++)
{
char ch = (char)i;
System.out.print(ch+" ");
}//end of loop
}
}


o/p:

****UpperCase Letters****

ABCDEFGHIJKLMNOPQRSTUVWXYZ

****LowerCase Letters****

a b c d e f g h i j k l m n o p q r s t u v w x y z

****Numeric Numbers****

0123456789

=======================================================

Ex-program:

wap to read a String and display the Consonents and count of

Consonents?

Program : DemoString4.java

package maccess;

import java.util.*;
public class DemoString4 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the String:"); String str = s.nextLine();

int len = str.length();
int count=0;
System.out.print("Consonents : "); for(int i=0;i<=len-1;i++) {

char ch = str.charAt(i);
int k = (int)ch;//char to ASCII code if((k>=65 && k<=90) || (k>=97 &&

k<=122))
{
switch(ch)
{
case 'a':
case 'A':
break;
case 'e':
case 'E':
break;
case 'i':
case 'I':
break;
case 'o':
case 'O':
break;
case 'u':
case 'U':
break;
default:
System.out.print(ch+" ");
count++;

}//end of switch
}
}//end of loop
System.out.println("\nCount of Consonents:"+count);

}catch(Exception e) {e.printStackTrace();} }//end of try with resource

}
}


o/p:

Enter the String:

Java17 is LTS product by 2021

Consonents : J v s L T S p r d c t b y

Count of Consonents:13

==============================================

Assignment:

wap to read a String and display the following:

Count of Vowels	:

Count of Consonents :

Count of Numbers	:

Sum of Numbers	:

Count of others	:





i/P:

Java17 is LTS product by 2021




O/p:






==============================================================

faq:

define String Concatenation process?

=>The process of combining multiple Strings into a single String

is known as String Concatenation process.

=>We use the following to perform Concatenation process in Java:

(i)Using "+" symbol

(ii)Using "concat()" method




Program : DemoString5.java

package maccess;

public class DemoString5 {
public static void main(String[] args) { String s1 = "Java";

String s2 = "Language";
String s3 = "Programming"; String s4 = s1+" "+s2+" "+s3;

System.out.println("s4 : "+s4.toString());
String s5 = s1.concat(" "+s3);
System.out.println("s5 : "+s5.toString());
String s6 = s1.concat(" "+s2).concat(" "+s3);

System.out.println("s6 : "+s6.toString());
}
}


o/p:

s4 : Java Language Programming

s5 : Java Programming

s6 : Java Language Programming

---------------------------------------------------

Note:

=>In String-Concatenation process separate String is created to

hold concatenated Strings,because the existing string-objects are

Immutable objects.

========================================================

faq:

define substring() method?

=>substring() method is used to display sub-string based on index

values

Method Signature:

public java.lang.String substring(int);

public java.lang.String substring(int,int);




Ex-program:

Wap to read Stu rollNo and display the details?




Program : DemoString6.java

package maccess;

import java.util.*;
public class DemoString6 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the
StuRollNo:");
String rNo = s.nextLine();
int len = rNo.length();
if(len==10) {
String yoj = rNo.substring(0, 2); String cc = rNo.substring(2, 6); String bc = rNo.substring(6, 8); String no = rNo.substring(8); System.out.println("===Details==="); System.out.println("Year of

Joining:20"+yoj);
System.out.println("College
Code:"+cc);
System.out.println("Branch Code:"+bc); System.out.println("Number in

batch:"+no);
}else {
System.out.println("Invalid RollNo");

}
}catch(Exception e) {e.printStackTrace();} }//end of try with resource
}

}


o/p:

Enter the StuRollNo:

19E11A05G1

===Details===

Year of Joining:2019

College Code:E11A

Branch Code:05

Number in batch:G1

===========================================================


Dt : 8/6/2023

*imp

define String Comparision?

=>The process of comparing two strings is known as String

Comparision process.

=>String Comparision process can be done in two ways:

(a)using equals() method

(b)using compareTo() method




(a)using equals() method:

=>equals() method is used to compare two strings and generate

boolean result.

Method Signatures:

public boolean equals(java.lang.Object);

public boolean equalsIgnoreCase(java.lang.String);




Ex-program : DemoString7.java

package maccess;

import java.util.*;
public class DemoString7 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s){

System.out.println("Enter the String-1:"); String str1 = s.nextLine().trim(); System.out.println("Enter the String-2:");
String str2 = s.nextLine().trim(); System.out.println("*****equals()*****"); boolean k = str1.equals(str2); if(k) {

System.out.println("Strings are equal..."); }else {

System.out.println("String are NotEqual..");
}

System.out.println( "****equalsIgnoreCase()****"); boolean z = str1.equalsIgnoreCase(str2); if(z) {

System.out.println("Strings are equal..."); }else {

System.out.println("String are NotEqual..");
}
}//end of try with resource
}
}


o/p:

Enter the String-1:

nit

Enter the String-2:

nit

*****equals()*****

Strings are equal...

****equalsIgnoreCase()****

Strings are equal...

-----------------------------------------------------------


Note:

=>In realtime equals() method is used for user authentication

process.

=========================================================

Assignment:

wap to read stuRollNo and display the rollNo branch?

(i)The rollNo must be 10 digits,else Invalid rollNo

(Msg through catch-block)

(ii)If the rollNo is validated then display branch based on

branch code.

Ex-branch-codes:

01 - CIVIL

02 - EEE

03 - MECH

04 - ECE

05 - CSE

12-IT




=>In brCode not not matched with any available codes,then

display the msg as "RollNo holding invalid brCode"

(Msg through catch-block)

==========================================================

(b)using compareTo() method:

=>compareTo() method also used to compare two strings and

generate int-result.

Method Signatures:

public int compareTo(java.lang.String);

public int compareToIgnoreCase(java.lang.String);




Ex:

int p = str1.compareTo(str2);




if p==0 , then Strings are equal

if p>0 , then str1>str2

if p<0 , then str1<str2




Note:

=>In realtime compareTo() method is used for sorting process




Ex-program : DemoString8.java

package maccess;

import java.util.*;
public class DemoString8 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s){

System.out.println("Enter the String-1:"); String str1 = s.nextLine().trim(); System.out.println("Enter the String-2:");
String str2 = s.nextLine().trim();

System.out.println("*****compareTo()*****"); int k = str1.compareTo(str2); if(k==0) {

System.out.println("Strings are equal..."); }else if(k>0){

System.out.println("str1 is greater than
str2");
}else {
System.out.println("str1 is less than
str2");
}

System.out.println("****compareToIgnoreCase()****"); int z = str1.compareToIgnoreCase(str2); if(z==0) {

System.out.println("Strings are equal..."); }else if(z>0){

System.out.println("str1 is greater than
str2");
}else {
System.out.println("str1 is less than
str2");
}
}//end of try with resource
}
}


o/p:

Enter the String-1:

java

Enter the String-2:

nit


*****compareTo()*****

str1 is less than str2

****compareToIgnoreCase()****

str1 is less than str2

=========================================================

faq:

wt is the diff b/w "String literal process" and "new Operator

process" in Object creation?

=>In String literal process,the execution-control will check the

"String Constant pool" is any object having same data,

=>If object not available then new Object is created

=>If Object is available then reference of existing object

is used without creating new object.




=>In new Operator process,one object is created directly in

HeapArea and the object will hold the reference of object

created in "String Constant Pool".




Diagram:




























Note:

=>"is equal to"(==) operator will compare object references,

because of this reason "is equal to"(==) operator is not preferable

to use on NonPrimitive datatypes.




Program : DemoString9.java

package maccess;

public class DemoString9 {
public static void main(String[] args) { //String Literal

String s1 = "nit";
String s2 = "nit"; //new operator process String s3 = new String("hyd"); String s4 = new String("hyd");

System.out.println("====String Literal process===");
if(s1==s2) {

System.out.println("Strings are equal..");
}else {
System.out.println("String are Not-
equal..");
}
System.out.println("====new Operator process====");

if(s3==s4) {
System.out.println("Strings are equal..");
}else {
System.out.println("Strings are Not-
equal...");
}
}
}


o/p:

====String Literal process===

Strings are equal..

====new Operator process====

Strings are Not-equal...

====================================================

faq:

define String Constant pool?

=>The separate partition of HeapArea where String-objects are

created is known as String Constant pool.

=>String Constant pool will restrict duplicate Object creations

and saves the execution time and high performance of an application.


faq:

why String-objects are immutable?

=>The object references of String Constant pool are available

to more than one reference variables and we must retrict

modifications,because of this reason String-objects are immutable

objects.




faq:

define String pooling?

=>The process of organizing multiple String-objects in a separate

location of HeapArea is known as "String Pooling"

===========================================================

Dt : 9/6/2023

2.StringBuffer class:

=>The objects which are created from "StringBuffer" are

Mutable Objects.

=>The following are some important constructors from

StringBuffer class:

public java.lang.StringBuffer();

public java.lang.StringBuffer(int);

public java.lang.StringBuffer(java.lang.String);

public java.lang.StringBuffer(java.lang.CharSequence);




Case-1 : Creating object using "StringBuffer()" constructor

syntax:

StringBuffer sb = new StringBuffer();

=>In this syntax StringBuffer object is created with the

default capacity 16.

=>we use append() method to add the data to StringBuffer

Object.

=>when length crosses the capacity then the capacity

increases automatically by doubling the capacity and adding 2.

16->(16+16+2)->34--->

Ex-program : DemoString10.java

package maccess;

public class DemoString10 {
public static void main(String[] args) { StringBuffer sb = new StringBuffer(); System.out.println("default

capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("java language");
System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());
sb.append(" programming");
System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());

}

}


o/p:

default capacity:16

length of sb:0

sb:java language

capacity:16

length of sb:13

sb:java language programming

capacity:34

length of sb:25

--------------------------------------------------

Case-2:Creating object using "StringBuffer(int)" constructor

syntax:

StringBuffer sb = new StringBuffer(5);

=>In this syntax StringBuffer object is created with the

capacity equal to the value passed as parameter while object

creation.




Ex-program : DemoString11.java

package maccess;

public class DemoString11 {
public static void main(String[] args) { StringBuffer sb = new StringBuffer(5); System.out.println("default

capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("java");
System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());
sb.append("AB");
System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());


}


}

o/p:

default capacity:5

length of sb:0

sb:java

capacity:5

length of sb:4

sb:javaAB

capacity:12

length of sb:6

------------------------------------------------

Case-3:Creating object using "StringBuffer(String)"

constructor

syntax:

StringBuffer sb = new StringBuffer("NIT");

=>In this syntax the StringBuffer object is created with

default capacity equal to the sum of "16 + length of String

passed as parameter".




Ex-program : DemoString12.java

package maccess;

public class DemoString12 {
public static void main(String[] args) { StringBuffer sb = new StringBuffer("NIT");
System.out.println("default capacity:"+sb.capacity());

System.out.println("length of sb:"+sb.length());

sb.append("java language Program"); System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());
sb.append("AB");
System.out.println("sb:"+sb.toString()); System.out.println("capacity:"+sb.capacity()); System.out.println("length of

sb:"+sb.length());


}

}


o/p:

default capacity:19

length of sb:3

sb:NITjava language Program

capacity:40

length of sb:24

sb:NITjava language ProgramAB

capacity:40

length of sb:26

-----------------------------------------------------

Case-4:Creating object using "StringBuffer(CharSequence)"

constructor

syntax:

StringBuffer sb1 = new StringBuffer("NIT");

StringBuffer sb2 = new StringBuffer(sb1);




=>This syntax is used to interlink two StringBuffer Objects,

which means sb2-object is holding the reference of sb1-object




Ex-program : DemoString13.java

package maccess;

public class DemoString13 {
public static void main(String[] args) { StringBuffer sb1 = new StringBuffer("NIT"); StringBuffer sb2 = new StringBuffer(sb1); System.out.println("sb2:"+sb2.toString()); System.out.println("default

capacity:"+sb2.capacity());
System.out.println("length of
sb:"+sb2.length());


}

}


o/p:

sb2:NIT

default capacity:19


length of sb:3

======================================================

Note:

=>StringBuffer will support some important methods:

(i)insert()

(ii)delete()

(iii)reverse()




Ex-program : DemoString14.java

package maccess;

public class DemoString14 {
public static void main(String[] args) {
StringBuffer sb = new StringBuffer();
sb.append("JavaLanguageProgram");
System.out.println("sb:"+sb.toString());
sb.insert(4, " NIT-HYD ");
System.out.println("sb:"+sb.toString());
sb.delete(4, 8);
System.out.println("sb:"+sb.toString());
sb.reverse();
System.out.println("sb:"+sb.toString());

}

}


o/p:

sb:JavaLanguageProgram

sb:Java NIT-HYD LanguageProgram

sb:Java-HYD LanguageProgram


sb:margorPegaugnaL DYH-avaJ

=================================================

Assignment:

wap to read a String and check the String is palindrome

String or not?

==================================================

Note:

=>StringBuffer class is synchronized class.

================================================

faq:

define synchronized class?

=>The class which is declared with synchronized methods is

known as synchronized class




faq:

define synchronized methods?

=>The methods which are declared with synchronized keyword

are known as synchronized methods.




Note:

=>These synchronized methods will be under the lock and the

methods are available to one user at-a-time.

--------------------------------------------------

3.StringBuilder class:

=>StringBuilder also generate mutable objects,but it is

NonSynchronized class.

=>The following are some important constructors from

StringBuilder:

public java.lang.StringBuilder();

public java.lang.StringBuilder(int);

public java.lang.StringBuilder(java.lang.String);

public java.lang.StringBuilder(java.lang.CharSequence);

=>StringBuilder internally having same behaviour like

StringBuffer.

=====================================================

summary:

String - Immutable objects

Holding protected data

ThreadSafe class




StringBuffer - Mutable Objects

Synchronized Class

ThreadSafe class

Used in Multi-user Applications (Server Applications)





StringBuilder - Mutable Objects

NonSynchronized Class

NonThreadSafe class

Used in Single User Applications

(NonServer Applications)

========================================================

Dt : 10/6/2023

Assignment:(Solution)

wap to read a String and display the following:

Count of Vowels	:

Count of Consonents :

Count of Numbers	:

Sum of Numbers	:

Count of others	:




Program : DemoString15.java

package maccess;

import java.util.*;
public class DemoString15 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the String:"); String str = s.nextLine();

int len = str.length();
int ac=0,vc=0,nc=0,sum=0;
for(int i=0;i<=len-1;i++)
{
char ch = str.charAt(i);
int k = (int)ch;//Char to ASCII if((k>=65 && k<=90) || (k>=97 &&

k<=122))
{
switch(ch)
{
case 'a':
case 'A':
case 'e':

case 'E':
case 'i':
case 'I':
case 'o':
case 'O':
case 'u':
case 'U':vc++;
break;
}//end of switch
ac++;
}//end of if
if(k>=48 && k<=57)
{
nc++;
String sr =
String.valueOf(ch);//Char to String
int v = Integer.parseInt(sr); //String to number

sum=sum+v;
}//end of if
}//end of loop
System.out.println("Count of
alphabets:"+ac);
System.out.println("Count of Vowels:"+vc); System.out.println("Count of

Consonents:"+(ac-vc));
System.out.println("Count of
Numbers:"+nc);
System.out.println("Sum of Numbers:"+sum); System.out.println("Count of

Others:"+(len-(ac+nc)));


}catch(Exception e) {e.printStackTrace();} }//end of try with resource

}

}

o/p:

Enter the String:

Java17 is LTS product by 2021

Count of alphabets:18

Count of Vowels:5

Count of Consonents:13

Count of Numbers:6

Sum of Numbers:13

Count of Others:5




==============================================================

Assignment:(Solution)

wap to read stuRollNo and display the rollNo branch?

(i)The rollNo must be 10 digits,else Invalid rollNo

(Msg through catch-block)

(ii)If the rollNo is validated then display branch based on

branch code.

Ex-branch-codes:

01 - CIVIL

02 - EEE

03 - MECH

04 - ECE

05 - CSE

12-IT




=>In brCode not not matched with any available codes,then

display the msg as "RollNo holding invalid brCode"

(Msg through catch-block)




Program :

GenerateBranch.java

package test;

public class GenerateBranch
{
public String generate(String brCode)
{
return switch(brCode)
{
case "01":yield "CIVIL";
case "02":yield "EEE";
case "03":yield "MECH";
case "04":yield "ECE";
case "05":yield "CSE";
default : yield null;
};
}
}


DemoString16.java

package maccess;


import java.util.*;

import test.GenerateBranch;

@SuppressWarnings("serial")

public class DemoString16 extends Exception

{

public DemoString16(String msg)

{

super(msg);

}

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try(s)

{

try

{

System.out.println("Enter the stuRollNo:");

String rollNo = s.nextLine();

if(rollNo.length()!=10)//Exception-condition

{

throw new DemoString16("Invalid rollNo..");


}

String brCode = rollNo.substring(6,8);

GenerateBranch gb = new GenerateBranch();

String br = gb.generate(brCode);

if(br==null)//Exception-Condition

{

throw new DemoString16

("RollNo holding Invalid brCode...");

}

System.out.println("RollNo belongs to "+br);

}//end of try

catch(DemoString16 ob)

{

System.out.println(ob.getMessage());

}

}//end of try with resource

}




}

o/p:

Enter the stuRollNo:

1234560590

RollNo belongs to CSE

==========================================================

define Utility Classes?

=>The classes which perform operations on other objects are

known as Utility Classes.

=>The following are some important utility classes on

string-objects:

(i)StringTokenizer class

(ii)StringJoiner class




(i)StringTokenizer class:

=>"StringTokenizer" class is from java.util package and

which is used to break the given String into pieces based on

delimiter.(delimiter means break specification)

=>The following are some important methods of

StringTokenizer:

(a)hasMoreTokens()

(b)nextToken()

(c)countTokens()




(a)hasMoreTokens():

=>hasMoreTokens() method will check the token available or

not,and generate boolean result.

Method Signature:

public boolean hasMoreTokens();




(b)nextToken():

=>nextToken() method is used to delete and retrieve the

token from StringTokenizer object.

Method Signature:

public java.lang.String nextToken();




(c)countTokens():

=>countTokens() method is used to count number of tokens

from the StringTokenizer Object.

Method Signature:

public int countTokens();

------------------------------------------------

Ex-program : DemoString17.java

package maccess;

import java.util.*;
public class DemoString17 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the String:"); String str = s.nextLine(); System.out.println("Enter the

delimiter:");
String dl = s.nextLine();
StringTokenizer ob = new StringTokenizer(str,dl);

System.out.println("count of Tokens:"+ob.countTokens());

System.out.println("****Display-Tokens****");

while(ob.hasMoreTokens())
{
String tk = ob.nextToken();
System.out.println(tk);
}//end of loop
System.out.println("****After retrieve-process****");

System.out.println("count of Tokens:"+ob.countTokens());

}catch(Exception e) {e.printStackTrace();} }//end of try

}
}


o/p:

Enter the String:

java is simple,java is secure,Java i MulT.Java is DD.

Enter the delimiter:

,.

count of Tokens:12

****Display-Tokens****

java

is

simple

java

is

secure

Java

i

MulT

Java

is

DD

****After retrieve-process****

count of Tokens:0




Diagram:




================================================

Assignment-1:

Wap to read a String and display reverse of words in the

String?





i/p : java is good language programming

o/p : avaj si doog egaugnal gnimmargorp

Assignment-2:

wap to read a String and display the reverse of words which

starts with Consonent?




i/p : Cat is under the table

o/p : taC is under eht elbat

=================================================

Dt : 12/6/2023

*imp

(ii)StringJoiner class:

=>StringJoiner class is from java.util package introduced by Java8

version and which is used to join the Strings based on delimiter.

=>The following are some important methods of StringJoiner class:

public java.util.StringJoiner setEmptyValue

(java.lang.CharSequence);

public java.lang.String toString();

public java.util.StringJoiner add(java.lang.CharSequence);

public java.util.StringJoiner merge(java.util.StringJoiner);

public int length();




Program : DemoString18.java


package maccess;
import java.util.*;

public class DemoString18 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
StringJoiner sj1 = new StringJoiner("/");

sj1.setEmptyValue("No Joining date
available");
System.out.println("Date of Joining:"+sj1.toString());

System.out.println("Enter the date:");
sj1.add(s.nextLine());
System.out.println("Enter the month:");

sj1.add(s.nextLine());
System.out.println("Enter the year:");
sj1.add(s.nextLine());
System.out.println("Date of
Joining:"+sj1.toString());
StringJoiner sj2 = new StringJoiner("-
");
sj2.setEmptyValue("No Address
available..");
System.out.println("Address => "+sj2.toString());

System.out.println("Enter the city:");
sj2.add(s.nextLine());
System.out.println("Enter the State:");

sj2.add(s.nextLine());
System.out.println("Enter the
PinCode:");
sj2.add(s.nextLine()); System.out.println("Address =>

"+sj2.toString());
System.out.println("****After
merging***");

sj1.merge(sj2);
System.out.println(sj1);
System.out.println("length of sj1 => "+sj1.length());

}catch(Exception e) {e.printStackTrace();} }//end of try

}
}


o/p:

Date of Joining:No Joining date available

Enter the date:

21

Enter the month:

11

Enter the year:

1990

Date of Joining:21/11/1990

Address => No Address available..

Enter the city:

Hyd

Enter the State:

TS

Enter the PinCode:

600123

Address => Hyd-TS-600123

****After merging***

21/11/1990/Hyd-TS-600123

length of sj1 => 24

============================================================

*imp

WrapperClasses in Java:

=>The pre-defined classes from java.lang package which are used to

make primitive datatypes available in the form of Objects are known as

WrapperClasses.

=>Every primitive datatype will have its own WrapperClass and there

are eight WrapperClasses.

=>The following are the list of WrapperClasses:

datatype	WrapperClass

byte	Byte

short	Short

int	Integer

long	Long

float	Float

double	Double

char	Character

boolean	Boolean





Hierarchy of WrapperClasses:

===============================================================

faq:

define Boxing Process?

=>The process of binding primitive datatypes into WrapperClass objects

is known as Boxing process.

=>This Boxing process can be performed using Constructors.

=>The following are the list of constructors from WrapperClasses:

WrapperClass	List-of-Constructors

Byte	Byte(byte),Byte(String)

Short	Short(short),Short(String)

Integer	Integer(int),Integer(String)

Long	Long(long),Long(String)

Float	Float(float),Float(double),Float(String)

Double	Double(double),Double(String)

Character	Character(char)

Boolean	Boolean(boolean)

-----------------------------------------------------------

Ex-program : DemoWrapperClass1.java

package maccess;

public class DemoWrapperClass1 { @SuppressWarnings({ "unused", "removal" }) public static void main(String[] args) {

//Boxing Process
Integer ob1 = new Integer(12); Integer ob2 = new Integer("13");

Float ob3 = new Float(12.34F);

Float ob4 = new Float(1234.56);
Float ob5 = new Float("11.23F");

Character ob6 = new Character('A');

Boolean ob7 = new Boolean(true); Boolean ob8 = new Boolean(false); System.out.println("====Display from

Objects====");
System.out.println("ob1:"+ob1.toString());
System.out.println("ob2:"+ob2.toString());
System.out.println("ob3:"+ob3.toString());
System.out.println("ob4:"+ob4.toString());
System.out.println("ob5:"+ob5.toString());
System.out.println("ob6:"+ob6.toString());
System.out.println("ob7:"+ob7.toString());
System.out.println("ob8:"+ob8.toString());
}

}



o/p:

====Display from Objects====

ob1:12

ob2:13

ob3:12.34

ob4:1234.56

ob5:11.23

ob6:A

ob7:true

ob8:false

====================================================

faq:

define UnBoxing process?

=>The process of taking primitive datatype values outof WrapperClass

Objects is known as UnBoxing process.

=>we use the following pre-defined methods to perform UnBoxing

process:

public byte byteValue();

public short shortValue();

public int intValue();

public long longValue();

public float floatValue();

public double doubleValue()

public char charValue();

public boolean booleanValue();




Ex-program : DemoWrapperClass2.java

package maccess;

public class DemoWrapperClass2{ @SuppressWarnings({ "removal" }) public static void main(String[] args) {

//Boxing Process
Integer ob1 = new Integer(12); Integer ob2 = new Integer("13");

Float ob3 = new Float(12.34F);

Float ob4 = new Float(1234.56);
Float ob5 = new Float("11.23F");

Character ob6 = new Character('A');

Boolean ob7 = new Boolean(true); Boolean ob8 = new Boolean("false");

//UnBoxing process

int i1 = ob1.intValue(); int i2 = ob2.intValue(); float f1 = ob3.floatValue(); double d = ob4.doubleValue(); float f2 = ob5.floatValue(); char ch = ob6.charValue(); boolean b1 = ob7.booleanValue(); boolean b2 = ob8.booleanValue();

System.out.println("====Display Values===="); System.out.println("i1:" +i1); System.out.println("i2:"+i2); System.out.println("f1:"+f1); System.out.println("d:"+d); System.out.println("f2:"+f2); System.out.println("ch:"+ch); System.out.println("b1:"+b1); System.out.println("b2:"+b2);




}

}



o/p:

====Display Values====

i1:12

i2:13

f1:12.34

d:1234.56005859375

f2:11.23

ch:A

b1:true

b2:false

===========================================================

faq:

define AutoBoxing process?

=>The boxing process which is performed automatically is known as

AutoBoxing process.

=>In AutoBoxing process the NonPrimitive datatype variables are

assigned with primitive datatype values.




faq:

define AutoUnBoxing process?

=>The UnBoxing process which is performed automatically is known as

AutoUnBoxing process.

=>In AutoUnBoxing process the Primitive datatype variable assigned

with NonPrimitive datatype variables.


Program : DemoWrapperClass3.java

package maccess;

public class DemoWrapperClass3{
public static void main(String[] args) { //AutoBoxing Process

Integer ob1 = 12;

Float ob3 = 12.34F;

Character ob6 = 'A';

Boolean ob7 = true;

//AutoUnBoxing process

int i1 = ob1;
float f1 = ob3;
char ch = ob6;
boolean b1 = ob7;

System.out.println("====Display Values===="); System.out.println("i1:"+i1); System.out.println("f1:"+f1); System.out.println("ch:"+ch); System.out.println("b1:"+b1);




}

}



o/p:

====Display Values====


i1:12

f1:12.34

ch:A

b1:true

===============================================================
6/14/23, 8:32 AM	String4.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
6/14/23, 8:33 AM	WrapperClass1.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 13/6/2023

faq:

why we have to make primitive datatypes available in the form of

Objects?

=>Java Frameworks and tools will accept data only in the form of

Objects,because of this reason we have to make primitive datatypes

available in the form of Objects.

=============================================================

*imp

Arrays in Java:

=>The sequenced collection of elements of same date type is known as

Array.

(or)

=>According to Java,Array is a sequenced Collection of Objects

generated from the same class




Types of Arrays:

=>In Java,Arrays are categorized into two types:

1.Single Dimensional Arrays

2.Multi Dimensional Arrays





1.Single Dimensional Arrays:

=>The Arrays which are declared with single dimension are known as

Single-D Arrays or 1-D Arrays.

syntax:

Class_name arr_var[] = new Class_name[size];

---------------------------------------------------

Ex-program :

Wap to read and display Integer WrapperClass objects using Array?




Program : DemoArray1.java

package p2;

import java.util.*;
public class DemoArray1 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the size of
Array:");
int n = s.nextInt();
Integer a[] = new Integer[n];
System.out.println("Enter "+n+" Integer
eles..");
for(int i=0;i<a.length;i++)
{
a[i] = new Integer(s.nextInt());

}//end of loop
System.out.println("====Using Old for
loop===");
for(int i= 0;i<a.length;i++)
{

System.out.print(a[i].toString()+" "); }//end of loop
System.out.println("\n****Using Extended for(Java5)****");

for(Integer k : a)
{
System.out.print(k.toString()+" ");
}//end of loop
System.out.println("\n****Uisng
Spliterator<T>(Java8)***"); Spliterator<Integer> sp =

Arrays.spliterator(a);
sp.forEachRemaining((k)->
{
System.out.print(k.toString()+" ");
});
}catch(Exception e) {e.printStackTrace();} }//end of try

}
}




o/p:

Enter the size of Array:

5

Enter 5 Integer eles..

11

10

9

18

17

====Using Old for loop===

111091817

****Using Extended for(Java5)****

111091817

****Uisng Spliterator<T>(Java8)***

111091817

--------------------------------------------------

faq:

define Extended-for?

=>Extended-for introduced by Java5 version and which is used to

retrieve elements from Array-Objects and which is also known as

Enhanced-for-loop

syntax:

for(data type var : Container name)


{

//loop body


}




Advantage:

=>In Extended-for we specify only Container-name and type of data.

=>In Extended-for,

=>no initialization

=>no Condition

=>no Increment-decrement

=>Extended-for is Auto-executable loop

==========================================================

*imp

define Spliterator<T>?

=>Spliterator<T> is an interface from java.util package introduced

by Java8 version and which is used to retrieve elements from Array and

Collection<E> objects.

=>Spliterator<T> will provide the one important method:

public default void forEachRemaining

(java.util.function.Consumer<? super T>);

=>we use spliterator() method from java.util.Arrays class to create

implementation object for "Spliterator<T>" interface




method Signature of spliterator():

public static <T> java.util.Spliterator<T> spliterator(T[]);




syntax:

Spliteratot<T> sp = Arrays.spliterator(T[]);

Ex:

Spliterator<Integer> sp = Arrays.spliterator(a);





faq:

define Consumer<T>?

=>Consumer<T> is a functional interface from java.util.function

package introduced by Java8 version and which provide method "accept(T)"

to hold LambdaExpression passed as parameter to forEachRemaining()

method.




Structure of Consumer<T>:

public interface java.util.function.Consumer<T>

{

public abstract void accept(T);

...

}




Diagram:




































================================================================

Assignment:

wap to read and display multiple Strings using Arrays?

==============================================================

Dt : 14/6/2023

Assignment:(Solution)

wap to read and display multiple Strings using Arrays?




Program : DemoArray2.java

package p2;

import java.util.*;
public class DemoArray2 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
System.out.println("Enter the size of
Array:");
int n = Integer.parseInt(s.nextLine());
String a[] = new String[n];
System.out.println("Enter "+n+" String
eles..");
for(int i=0;i<a.length;i++)
{
a[i] = new String(s.nextLine());
}//end of loop
System.out.println("====Using Old for
loop===");
for(int i= 0;i<a.length;i++)
{
System.out.println(a[i].toString()+"
");
}//end of loop
System.out.println("****Using Extended for(Java5)****");

for(String k : a)
{

System.out.println(k.toString()+" "); }//end of loop
System.out.println("****Uisng Spliterator<T>(Java8)***");

Spliterator<String> sp = Arrays.spliterator(a);

sp.forEachRemaining((k)->
{
System.out.println(k.toString()+" ");
});
}catch(Exception e) {e.printStackTrace();} }//end of try

}
}






o/p:

Enter the size of Array:

5

Enter 5 String eles..

java is Secured

java is PI

Java is AN

Java is Thread

Java is Robust

====Using Old for loop===

java is Secured

java is PI

Java is AN

Java is Thread

Java is Robust

****Using Extended for(Java5)****

java is Secured

java is PI

Java is AN

Java is Thread

Java is Robust

****Uisng Spliterator<T>(Java8)***

java is Secured

java is PI

Java is AN

Java is Thread

Java is Robust

==============================================================

Ex-program:

wap to read and display multiple employee details using Array?




Employee.java

package p1;

public class Employee extends Object
{

public String eId,eName,eDesg; public int bSal;
public float totSal;

@Override
public String toString()
{
return
eId+"\t"+eName+"\t"+eDesg+"\t"+bSal+"\t"+totSal;

}
}


DemoArray3.java(MainClass)

package p2;

import p1.Employee;

import java.util.*;

public class DemoArray3 extends Exception

{

public DemoArray3(String msg)

{

super(msg);

}

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try(s;){

try {


System.out.println("Enter the nymber of Employees:");

int n = Integer.parseInt(s.nextLine());

Employee ob[] = new Employee[n];

System.out.println("Enter "+n+" Employee details...");

int i=0;

while(i<ob.length)

{

try

{

System.out.println("Enter details of Employee-"+(i+1));

ob[i] = new Employee();

System.out.println("Enter the EmpId:");

ob[i].eId = s.nextLine();

System.out.println("Enter the EmpName:");

ob[i].eName = s.nextLine();

System.out.println("Enter the EmpDesg:");

ob[i].eDesg = s.nextLine();

System.out.println("Enter the EmpBSal:");

ob[i].bSal = Integer.parseInt(s.nextLine());

if(ob[i].bSal<12000)//Exception Condition

{

throw new DemoArray3("Invalid bSal..");


}

ob[i].totSal =

ob[i].bSal+(0.93F*ob[i].bSal)+(0.63F*ob[i].bSal);

i++;

}//end of try

catch(DemoArray3 da)

{

System.out.println(da.getMessage());

}

}//end of loop

System.out.println("====EmployeeDetails====");

Spliterator<Employee> sp = Arrays.spliterator(ob);

sp.forEachRemaining((k)- >System.out.println(k));

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter the nymber of Employees:

2

Enter 2 Employee details...

Enter details of Employee-1

Enter the EmpId:

A001

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the EmpBSal:

-12000

Invalid bSal..

Enter details of Employee-1

Enter the EmpId:

A123

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the EmpBSal:

18000

Enter details of Employee-2

Enter the EmpId:

123

Enter the EmpName:

Ram

Enter the EmpDesg:

TE

Enter the EmpBSal:

18000

====EmployeeDetails====

A123 Raj	SE	1800046080.0

123	Ram  TE	1800046080.0




































==========================================================

Assignment:

wap to read and display multiple Student-details?

(rollNo,name,branch,totM,per,result)

==========================================================

faq:

define Object-Array?

=>The Array which is declared with "java.lang.Object" class is known

as Object-Array.

=>Object-Array will hold Dis-Similer Objects,which means objects

generated from different classes.




syntax:

Object o[] = new Object[size];




Ex-program :

User.java

package p1;

public class User extends Object
{
public String name;
public long phNo;
public User(String name,long phNo)
{
this.name=name;
this.phNo=phNo;
}
@Override
public String toString()
{
return name+"\t"+phNo;
}

}


DemoArray4.java

package p2;

import java.util.*;

import p1.User;

public class DemoArray4

{

@SuppressWarnings("removal")

public static void main(String[] args)

{

Object o[] = new Object[3];

o[0] = new Integer(121);//Integer WrapperClass Object

o[1] = new String("NIT-JAVA");//String-Class Object

o[2] = new User("Raj",9898981234L);

System.out.println("****Object-Array****");

Spliterator<Object> sp = Arrays.spliterator(o);

sp.forEachRemaining((k)->System.out.println(k));

}

}





o/p:

****Object-Array****

121

NIT-JAVA

Raj	9898981234

=============================================================

2.Multi Dimensional Arrays:

=>The Arrays which are declared with multiple dimensions are known

as Multi-Dimensional Arrays

Ex:

2-D Arrays

3-D Arrays

4-D Arrays

...




syntax of 2-D Array:

Class name ob[][] = new Class name[size][size];





-------------------------------------------------------------

Ex-program : DemoArray5.java

package p2;

import java.util.*;
public class DemoArray5 {
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
Integer a[][] = new Integer[3][3]; System.out.println("Enter 3X3 Matrix:"); for(int i=0;i<=2;i++)//Rows

{
for(int j=0;j<=2;j++)//Cols
{
a[i][j] = new Integer(s.nextInt()); }//InnerLoop

}//OuterLoop
System.out.println("====Display 3x3 Matrix===");

for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
System.out.print(a[i][j]+" ");
}//InnerLoop
System.out.println();
}//OuterLoop
System.out.println("***Spliterator<T>****"); Spliterator<Integer[]> sp1 =

Arrays.spliterator(a);
sp1.forEachRemaining((i)->
{
Spliterator<Integer> sp2 = Arrays.spliterator(i);

sp2.forEachRemaining((j)->
{
System.out.print(j+" ");
});
System.out.println();
});
}catch(Exception e) {e.printStackTrace();} }//end of try

}
}


o/p:


Enter 3X3 Matrix:

11

12

13

14

15

16

17

18

19

====Display 3x3 Matrix===

11 12 13

14 15 16

17 18 19

***Spliterator<T>****

11 12 13

14 15 16

17 18 19

==============================================================

Dt : 15/6/2022

Diagram:(Representing 2-D Array)





















































===============================================================

faq:

define Jagged Array?

=>The Array which is holding Array-Objects is known as Jagged-Array




Note:

=>2-D Array we can call as Jagged Array

=============================================================

Ex-program:

wap to add two 3X3 Matrices?




Program :

Addition.java

package p1;

public class Addition
{
public Integer[][] add(Integer x[][],Integer y[][])
{
Integer z[][] = new Integer[3][3]; for(int i=0;i<=2;i++) {

for(int j=0;j<=2;j++)
{
z[i][j]=x[i][j]+y[i][j]; }//InnerLoop

}//outerLoop
return z;
}
}


DemoArra6.java


package p2;

import java.util.*;
import p1.Addition;

public class DemoArra6
{
public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter 3X3 Matrix A"); Integer a[][] = new Integer[3][3]; for(int i=0;i<=2;i++) {

for(int j=0;j<=2;j++)
{
a[i][j] = s.nextInt();
}//end of loop
}//end of loop
System.out.println("Enter 3X3 Matrix B"); Integer b[][] = new Integer[3][3]; for(int i=0;i<=2;i++) {

for(int j=0;j<=2;j++)
{
b[i][j] = s.nextInt();
}//end of loop
}//end of loop
Addition ad = new Addition();
Integer c[][] = ad.add(a, b);//method call System.out.println("====Matrix-

Addition====");
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
System.out.print(c[i][j]+" ");
}//end of loop
System.out.println();
}//end of loop
}catch(Exception e) {e.printStackTrace();} }//end of try with resource
}

}



o/p:

Enter 3X3 Matrix A

1

1

1

1

1

1

1

1

1

Enter 3X3 Matrix B

1

1

1

1

1

1

1

1

1

====Matrix-Addition====

2 2 2

2 2 2

2 2 2

===========================================================

Assignment-1:

wap to read 1-D Integer Array and display the following:

Sum of all elements=

Small element from Array=

Largest element from Array=




Assignment-2:

Wap to read 2-D Integer Array and display the sum of diagonal elements?




Assignment-3:

wap to perform Matrix Multiplication on 3X3 Matrices?

=========================================================

faq:

can we pass parameters to standard main() method?

=>Yes,we can pass parameters to Standard main() method while execution

command,because main() method call is available in execution command.




syntax:

java Class_name arg1 arg2 arg3 ...




Ex:

java DemoMain Text 12.34 A 123




Ex-program : DemoMain.java

import java.util.*;

class DemoMain

{

static public void main(String...p)

{

System.out.println("****Display from args[]****");

Spliterator<String> sp = Arrays.spliterator(p);

sp.forEachRemaining((k)->

{

System.out.println(k);

});





}

}

o/p:




D:\Demo146>javac DemoMain.java

D:\Demo146>java DemoMain Text 12.34 A 123

****Display from args[]****

Text

12.34

A

123




===================================================

faq:

define Command Line argument Program?

=>The program in which we pass arguments to main() method is known as

Command Line argument Program.




faq:

wt is the diff b/w

(i)arguments

(ii)parameters

=>arguments means passing values to method while method call

=>parameters means passing variables to methods while method call

=============================================================

*imp

=>we can represent standard main() method in the following ways:

public static void main(String args[])

public static void main(String[] args)

static public void main(String[] args)

public static void main(String...args) <====Var-args format

public static void main(String[] p)

================================================================

Dis-Advantage of Arrays:

=>Array size once defined cannot be modified at runtime,because of

this reason arrays are not preferable in realtime to hold dynamic and

runtime data.




Note:

=>DisAdvantage of Arrays can be Overcomed using Collection<E>

==================================================================

Dt : 16/6/2023

*imp

Java Collection Framework(JCF):




define collection?(General definition)

=>The process of collecting group of elements together is known as

collection.




*imp

define Collection<E>?(Java Component)

=>Collection<E> is an interface from java.util package and which

is root of Java Collection<E> framework.

=>This Collection<E> interface is extended into the following

SubInterfaces:

1.Set<E>

2.List<E>

3.Queue<E>




Hierarchy of Collection<E>:


































---------------------------------------------------------

faq:

define Framework?

=>The structure which is ready constructed and available for

application development is known as Framework.









































==============================================================

*imp

Complete Structure of Collection<E> Framework:























=================================================

faq:

define Generic Programming Components?

=>The components which are ready to accept any type are known

as Generic Programming Components

=>The following are some important generic Programming components:

1.Generic Types

2.Generic Methods

3.Generic Classes

4.Generic Interfaces




1.Generic Types:

=>The types which are ready to accept any type of data are known

as Generic Types.

T - Type

E - Element

K - Key

V - Value




2.Generic Methods:

=>The methods which are ready to accept any type of data as

parameters are known as Generic Methods.

Structure:

<T>return_type method_name(T)

{

//method name


}




3.Generic Classes:

=>The classes which generate objects and the Objects are ready

to hold any type of data are known as Generic Classes.

Structure:

class Class_name<T>

{

//Class_body

}


4.Generic Interfaces:

=>Generic Interfaces are implemented to Generic Classes.




Structure:

interface Interface_name<T>

{

//Interface_body

}

===========================================================

Ex-program:(Demonstrating User defined Generic Class)




Diusplay.java

package p1;

public class Display<T>
{
public T ob;
public Display(T ob)
{
this.ob = ob;
}
public T getRef()
{
return ob;
}
}

User.java


package p1;
public class User {

public String name,mId;
public User(String name,String mId) {
this.name=name;
this.mId=mId;
}
public String toString() {
return name+"\t"+mId;
}
}


DemoGeneric.java(MainClass)

package p2;

import p1.*;
public class DemoGeneric { @SuppressWarnings("removal")

public static void main(String[] args) { Display<Integer> ob1 = new Display<Integer>(new

Integer(12));
Display<String> ob2 = new Display<String>("NIT"); Display<User> ob3 = new Display<User>(new

User("Raj","r@.."));
System.out.println(ob1.getRef());
System.out.println(ob2.getRef());
System.out.println(ob3.getRef());

}

}


Diagram:



























===========================================================

dt : 17/6/2023

1.Set<E>:

=>Set<E> is an interface from java.util package and which is

extended from "Collectionb<E>".

=>Set<E> organizes elements without index values and which cannot

hold duplicate elements.

(Set<E> means no index and no duplicate)

=>The following are some important methods of Set<E>:

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean contains(java.lang.Object);

public abstract boolean add(E);

public abstract boolean remove(java.lang.Object);

public abstract boolean containsAll(java.util.Collection<?>);

public abstract boolean addAll

(java.util.Collection<? extends E>);

public abstract boolean retainAll(java.util.Collection<?>);

public abstract boolean removeAll(java.util.Collection<?>);

public abstract void clear();

public static <E> java.util.Set<E> of();





public abstract java.util.Iterator<E> iterator();

public default java.util.Spliterator<E> spliterator();




public abstract java.lang.Object[] toArray();

public abstract <T> T[] toArray(T[]);

------------------------------------------------

=>The following are the implementattion classes of Set<E>:

(a)HashSet<E>

(b)LinkedHashSet<E>

(c)TreeSet<E>




(a)HashSet<E>:

=>HashSet<E> will hold elements without any order.




(b)LinkedHashSet<E>:

=>LinkedHashSet<E> will hold elements in insertion order.




(c)TreeSet<E>:

=>TreeSet<E> will hold elements automatically in ascending order

==================================================================

Ex-program:(Demonstrating Operations on Set<E>)





Program : DemoSet1.java
package p2;

import java.util.*;
public class DemoSet1 {
@SuppressWarnings("removal")
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

Set<Integer> ob = null;
String nm = null;
while(true) {
System.out.println("****Choice****"); System.out.println("\t1.HashSet"

"\n\t2.LinkedHashSet"
"\n\t3.TreeSet"
"\n\t4.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
ob = new HashSet<Integer>(); nm = "HashSet";

break;
case 2:
ob = new LinkedHashSet<Integer>(); nm = "LinkedHashSet";

break;
case 3:
ob = new TreeSet<Integer>(); nm = "TreeSet";

break;
case 4:
System.out.println("Operatios
Stopped on Set");
System.exit(0);//Stop the program default:

System.out.println("Invalid
Choice");
continue;//skip below lines within
the loop

}//end of switch
System.out.println("---->Perform

operations on "+nm);
xyz:while(true) {

System.out.println("====Choice====");

System.out.println("\t1.add(E)"
"\n\t2.remove(Object)"
"\n\t3.DisplayElements"
"\n\t4.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
ele:");
ob.add(new
Integer(s.nextInt()));

System.out.println(ob.toString()); break;

case 2:
if(ob.isEmpty()) {
System.out.println("Set is
empty..");
}else {

System.out.println("Enter

the ele to be removed:");
if(ob.remove(new
Integer(s.nextInt()))) {

System.out.println("Ele removed Successfully..");

System.out.println(ob.toString()); }else {

System.out.println("Ele
not found in the Set...");
}

}
break;
case 3:

if(ob.isEmpty()) {
System.out.println("Set is
empty...");
}else {

System.out.println("====Iterator<E>===="); Iterator<Integer> it1 =

ob.iterator();
while(it1.hasNext()) {

System.out.print(it1.next()+" ");

}//end of loop

System.out.println("\n====Iterator<E>-forEachRemaing()=====");

Iterator<Integer> it2 =
ob.iterator();
it2.forEachRemaining((k)-
>System.out.print(k+" "));

System.out.println("\n====Spliterator<T>(Java8)===="); Spliterator<Integer> sp =

ob.spliterator();
sp.forEachRemaining((k)-
>System.out.print(k+" "));

System.out.println("\n=====forEach()(Java8)===="); ob.forEach((k)-

>System.out.print(k+" "));
System.out.println();
}//end of else
break;
case 4:
System.out.println("Operations
Stopped on "+nm);
break xyz;//Stopping InnerLoop default:

System.out.println("Invalid

Choice...");
}//end of switch

}//InnerLoop
}//OuterLoop
}//end of try-with-resource
}
}


o/p:

****Choice****

1.HashSet

2.LinkedHashSet

3.TreeSet

4.exit

Enter the Choice:

3

---->Perform operations on TreeSet

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

1

Enter the ele:

11

[11]

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

1

Enter the ele:

12

[11, 12]

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

1

Enter the ele:

14

[11, 12, 14]

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:




10

Invalid Choice...

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

1

Enter the ele:

9

[9, 11, 12, 14]

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

1

Enter the ele:

10

[9, 10, 11, 12, 14]

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

3

====Iterator<E>====

910111214

====Iterator<E>-forEachRemaing()=====

910111214

====Spliterator<T>(Java8)====

910111214

=====forEach()(Java8)====

910111214

====Choice====

1.add(E)

2.remove(Object)

3.DisplayElements

4.exit

Enter the Choice:

4

Operations Stopped on TreeSet

****Choice****

1.HashSet

2.LinkedHashSet

3.TreeSet

4.exit

Enter the Choice:

4

Operatios Stopped on Set

===========================================================

Dt : 21/6/2023

*imp

define Iterator<E>?

=>Iterator<E> is an interface from java.util package and which is

used to retrieve elements from Collection<E>-Objects in forward

direction.

=>The following are some important methods of Iterator<E>:

public abstract boolean hasNext();

public abstract E next();

public default void remove();

public default void forEachRemaining

(java.util.function.Consumer<? super E>);







hasNext() : This method will check the ele available or not,and returns

boolean result

next()	: This method is used to retrieve ele from Collection<E>

Object

remove() : This method is used to remove the ele from the Collection<E>

Object





forEachRemaining() : This method is also used to retrieve elements from

Collection<E> object using LambdaExpression as

method argument.

--------------------------------------------------------------

=>we use iterator() method to create implementation object for

Iterator<E> interface.

syntax:

Iterator<Integer> it1 = ob.iterator();




===================================================================

define Spliterator<T>?

=>Spliterator<T> is a normal interface introduced by Java8 version

and which is used to display elements from Array objects and

Collection<E> Objects.

=>Spliterator<T> is having the following method:

public default void forEachRemaining

(java.util.function.Consumer<? super T>);

=>we use spliterator() method to create implementation object for

Spliterator<T> interface.

syntax:

Spliterator<Integer> sp = ob.spliterator();





Diagram:

===============================================================

Assignment-1:

Update above program to display only Prime numbers?




Assignment-2:

Update above program to perform operations on User defined Class

Product Objects?

===================================================================

Dt : 22/6/2023

*imp

define Predicate<T>?

=>Predicate<T> is a functional interface from java.util.function package

and which is used to perform conditional operation on Collection<E> objects.




structure of Predicate<T>:




public interface java.util.function.Predicate<T>

{

public abstract boolean test(T);

...


}

syntax:

Predicate<Class_name> pr = (T)->

{

...

};




Assignment-1:(Solution)

Update above program to display only Prime numbers?




Program : DemoSet2.java

package p2;

import java.util.*;

import java.util.function.*;

public class DemoSet2 {

@SuppressWarnings("removal")

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {


LinkedHashSet<Integer> ob = new LinkedHashSet<Integer>();

System.out.println("Enter the number of eles:");

int n = s.nextInt();

System.out.println("Enter "+n+" elements...");

for(int i=1;i<=n;i++)

{

ob.add(new Integer(s.nextInt()));

}//end of loop

System.out.println("***All elements***");

System.out.println(ob.toString());

System.out.println("****Prime Numbers****");

Predicate<Integer> pr = (k)->

{

int count=0;

for(int i=1;i<=k;i++)

{

if(k%i==0)

{

count++;

}

}//end of loop

if(count==2)

{


return true;

}

else

{

return false;

}

};

ob.forEach((z)->

{

if(pr.test(z))

{

System.out.print(z+" ");

}

});

}catch(Exception e) {e.printStackTrace();}




}//end of try with resource

}

}

o/p:

Enter the number of eles:

11

Enter 11 elements...

13

20

16

14

56

17

21

43

41

77

27

***All elements***

[13, 20, 16, 14, 56, 17, 21, 43, 41, 77, 27]

****Prime Numbers****

13 17 43 41

==========================================================

Note:

=>when we want to perform Sorting process on User defined class Objects

using TreeSet<E>,the user defined class must be modified with the following:





step-1 : The User defined class must be implemented from

"java.lang.Comparable" interface

Structure of Comparable:

public interface java.lang.Comparable<T>

{

public abstract int compareTo(T);

}




step-2 : The user defined class must construct body for "compareTo()"

method and which holds sort-specification-logic.




----------------------------------------------------------------

Assignment-2:(Solution)

Update above program to perform operations on User defined Class

Product Objects?




Product.java

package p1;

@SuppressWarnings("rawtypes")
public class Product extends Object implements
Comparable
{
public String code,name;
public float price;
public int qty;
public Product(String code,String name,float price, int qty)

{

this.code=code;
this.name=name;

this.price=price;
this.qty=qty;
}
@Override
public String toString()
{
return code+"\t"+name+"\t"+price+"\t"+qty;
}
@Override
public int compareTo(Object o)
{
Product p = (Product)o;
int x = code.compareTo(p.code); if(x==0) return 0; else if(x>0) return 1;

else return -1;
}
}


DemoSet3.java(MainClass)

package p2;

import java.util.*;

import p1.Product;

public class DemoSet3 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

Set<Product> ob = null;

String nm = null;

while(true) {

System.out.println("****Choice****");

System.out.println("\t1.HashSet"

"\n\t2.LinkedHashSet"

"\n\t3.TreeSet"

"\n\t4.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

ob = new HashSet<Product>(); nm = "HashSet";

break;

case 2:

ob = new LinkedHashSet<Product>(); nm = "LinkedHashSet";

break;

case 3:

ob = new TreeSet<Product>(); nm = "TreeSet";

break;

case 4:

System.out.println("Operatios Stopped on Set"); System.exit(0);//Stop the program

default:

System.out.println("Invalid Choice");

continue;//skip below lines within the loop

}//end of switch

System.out.println("---->Perform operations on "+nm);

xyz:while(true) {

System.out.println("====Choice====");

System.out.println("\t1.add(E)"

"\n\t2.remove(Object)"

"\n\t3.DisplayElements"

"\n\t4.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

System.out.println("---ProductDetails---"); System.out.println("Enter the ProdCode:"); String code = s.nextLine(); System.out.println("Enter the ProdName:"); String name = s.nextLine(); System.out.println("Enter the ProdPrice:"); float price = Float.parseFloat(s.nextLine()); System.out.println("Enter the ProdQty:");

int qty = Integer.parseInt(s.nextLine());

ob.add(new Product(code,name,price,qty));

ob.forEach((k)->System.out.println(k));

break;

case 2:

if(ob.isEmpty()) {

System.out.println("Set is empty..");

}else {




System.out.println("Enter the code remove

product:");

String cd = s.nextLine();

Iterator<Product> it = ob.iterator();

while(it.hasNext())

{

Product p = (Product)it.next();

if(cd.equals(p.code))

{

it.remove();

//Product Object removed from the

Set


System.out.println

("Product deleted successfully..");

break;

}

}//end of loop

ob.forEach((k)->System.out.println(k));

}

break;

case 3:

if(ob.isEmpty()) {

System.out.println("Set is empty...");

}else {

System.out.println("====Iterator<E>====");

Iterator<Product> it1 = ob.iterator();

while(it1.hasNext()) {

System.out.println(it1.next()+" ");

}//end of loop

System.out.println("====Iterator<E>-

forEachRemaing()=====");

Iterator<Product> it2 = ob.iterator();

it2.forEachRemaining((k)-


>System.out.println(k+" "));



System.out.println("====Spliterator<T>(Java8)====");

Spliterator<Product> sp = ob.spliterator();

sp.forEachRemaining((k)-

>System.out.println(k+" "));

System.out.println();

}//end of else

break;

case 4:

System.out.println("Operations Stopped on "+nm);

break xyz;//Stopping InnerLoop

default:

System.out.println("Invalid Choice...");

}//end of switch

}//InnerLoop

}//OuterLoop

}//end of try-with-resource

}

}

------------------------------------------------------------------
6/22/23, 9:34 AM	Collection2.png












































































https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NjE0OTIyNDg3NTE5/details	1/1

------------------------------------------------------------------

Dt : 23/6/2023

Note:

=>TreeSet<E> internally uses Quick-sorting process for string-objects and

WrapperClass-objects.

=>TreeSet<E> internally uses Merge-sorting process for User defined class

Objects.




Diagram:









































==================================================================

*imp

2.List<E>:

=>List<E> is an interface from java.util package and extended from

"Collection<E>".

=>List<E> organizes elements based on index values and which can hold

duplicate elements.

=>The following are some important methods of List<E>:

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean contains(java.lang.Object);




public abstract boolean add(E);

public abstract boolean remove(java.lang.Object);

public abstract boolean containsAll(java.util.Collection<?>);

public abstract boolean addAll(java.util.Collection<? extends E>);

public abstract boolean addAll(int, java.util.Collection<? extends E>);

public abstract boolean removeAll(java.util.Collection<?>);

public abstract boolean retainAll(java.util.Collection<?>);

public default void replaceAll(java.util.function.UnaryOperator<E>);

public default void sort(java.util.Comparator<? super E>);

public abstract void clear();




public abstract E get(int);

public abstract E set(int, E);

public abstract void add(int, E);

public abstract E remove(int);

public abstract int indexOf(java.lang.Object);

public abstract int lastIndexOf(java.lang.Object);

public abstract java.util.List<E> subList(int, int);


public static <E> java.util.List<E> of();




public abstract java.util.Iterator<E> iterator();

public abstract java.util.ListIterator<E> listIterator();

public abstract java.util.ListIterator<E> listIterator(int);

public default java.util.Spliterator<E> spliterator();




public abstract java.lang.Object[] toArray();

public abstract <T> T[] toArray(T[]);

-------------------------------------------------------------------

=>The following are the implementation classes of List<E>:

(a)ArrayList<E>

(b)LinkedList<E>

(c)Vector<E>




(a)ArrayList<E>:

=>ArrayList<E> organizes elements in sequence and which is NonSynchronized

class.

=>ArrayList<E> is a replacement of Arrays.

syntax:

ArrayList<Class_name> al = new ArrayList<Class_name>();

-------------------------------------------------------------

Dt : 24/6/2023

Ex-program:

DemoList1.java

package p2;

import java.util.*;
public class DemoList1 {
@SuppressWarnings("removal")
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
ArrayList<Integer> al = new ArrayList<Integer>();

while(true) {
System.out.println("****Choice****");
System.out.println("\t1.add(E)"
"\n\t2.add(index,E)"
"\n\t3.remove(Object)"
"\n\t4.remove(index)"
"\n\t5.get(index)"
"\n\t6.set(index,E)"
"\n\t7.Sorting"
"\n\t8.Exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
ele:");
al.add(new Integer(s.nextInt())); System.out.println(al.toString()); break;

case 2:
if(al.isEmpty()) {
System.out.println("List is
empty..");

}else {
System.out.println("Enter the

index:");
int i1 = s.nextInt();
if(i1>=0 && i1<al.size()) { System.out.println("Enter

the ele:");
al.add(i1, new
Integer(s.nextInt()));

System.out.println(al.toString()); }else {

System.out.println("Invalid index..");

}
}

break;

case 3:
if(al.isEmpty()) {
System.out.println("List is
empty..");
}else {
System.out.println("Enter the
ele to be removed:");
Integer el = new
Integer(s.nextInt());
if(al.remove(el)) {
System.out.println("ele
removed Successfully..");

System.out.println(al.toString()); }else {

System.out.println("Ele
not found...");
}
}
break;
case 4:
if(al.isEmpty()) {
System.out.println("List is

empty...");
}else {
System.out.println("Enter the
index to remove the element:");
int i2 = s.nextInt();
if(i2>=0 && i2<al.size()) {
al.remove(i2);
System.out.println("Ele
removed Successfully...");

System.out.println(al.toString()); }else {

System.out.println("Invalid
index...");
}
}
break;
case 5:
if(al.isEmpty()) {
System.out.println("List is
empty..");
}else {
System.out.println("Enter the
index to get the ele:");
int i3 = s.nextInt();
if(i3>=0 && i3<al.size()){ Integer el2 = al.get(i3);

System.out.println(el2.toString()); }else {

System.out.println("Invalid
index..");
}
}
break;
case 6:
if(al.isEmpty()) {
System.out.println("List is

empty...");
}else {

System.out.println("Enter the
intex to set ele:");
int i4 = s.nextInt();
if(i4>=0 && i4<al.size()) { System.out.println("Enter

the new-ele:");
Integer el3 = new
Integer(s.nextInt());
al.set(i4, el3);

System.out.println(al.toString()); }else {

System.out.println("Invalid Index...");

}
}
break;
case 7:
if(al.isEmpty()) {
System.out.println("List is
empty...");
}else {
System.out.println("****Before
Sorting****");

System.out.println(al.toString());

Collections.sort(al);//Sorting
Process
System.out.println("****After
Sorting****");

System.out.println(al.toString());

}

break;

case 8:
System.out.println("Operations

Stopped..");
System.exit(0);

default:
System.out.println("Invalid
Choice...");
}//end of switch
}//end of loop
}catch(Exception e) {e.printStackTrace();} }//end of try with resource

}
}


o/p:

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

7

List is empty...

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

10

[10]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

11

[10, 11]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

9

[10, 11, 9]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

45

[10, 11, 9, 45]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

23

[10, 11, 9, 45, 23]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

8

[10, 11, 9, 45, 23, 8]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

Enter the ele:

17

[10, 11, 9, 45, 23, 8, 17]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

7

****Before Sorting****

[10, 11, 9, 45, 23, 8, 17]

****After Sorting****

[8, 9, 10, 11, 17, 23, 45]

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

8

Operations Stopped..

=============================================================

faq:

wt is the diff b/w

(i)Collection<E>

(ii)Collections





=>Collection<E> is an ineterface from java.util package and which is root

of Java Collection Framework.

=>Collections is a class from java.util package and which provide some

Pre-defined methods to perform operations on List<E> objects.

Ex:

sort()

binarySearch()




===================================================================

==




Method Signatures of sort():




public static <T extends java.lang.Comparable<? super T>>

void sort(java.util.List<T>);

public static <T> void sort(java.util.List<T>,

java.util.Comparator<? super T>);




Method Signatures of binarySearch():




public static <T> int binarySearch(java.util.List

<? extends java.lang.Comparable<? super T>>, T);





public static <T> int binarySearch(java.util.List<? extends T>, T,

java.util.Comparator<? super T>);

===================================================================

====

Assignment:

Update above program with User defined class Objects.(Product-Objects)

===================================================================

=

Dt : 26/6/2023

Assignment:(Solution)

Update above program with User defined class Objects.(Product-Objects)




Product.java

package p1;

@SuppressWarnings("rawtypes")
public class Product extends Object implements
Comparable
{
public String code,name;
public float price;
public int qty;
public Product(String code,String name,float price, int qty)

{
this.code=code;
this.name=name;
this.price=price;
this.qty=qty;
}
@Override
public String toString()
{
return code+"\t"+name+"\t"+price+"\t"+qty;
}
@Override
public int compareTo(Object o)
{
Product p = (Product)o;
/*int x = code.compareTo(p.code); if(x==0) return 0; else if(x>0) return 1;

else return -1;*/


if(price==p.price) return 0;
else if(price>p.price) return 1; else return -1;

}
}


DemoList2.java(MainClass)

package p2;

import java.util.*;

import p1.Product;

public class DemoList2{

@SuppressWarnings({ "unchecked" })

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

ArrayList<Product> al = new ArrayList<Product>();

while(true) {

System.out.println("****Choice****");

System.out.println("\t1.add(E)"

"\n\t2.add(index,E)"

"\n\t3.remove(Object)"

"\n\t4.remove(index)"

"\n\t5.get(index)"

"\n\t6.set(index,E)"

"\n\t7.Sorting"

"\n\t8.Exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

System.out.println("****ProductDetails****:"); System.out.println("Enter the ProductCode:"); String code = s.nextLine(); System.out.println("Enter the ProductName:"); String name = s.nextLine(); System.out.println("Enter the ProductPrice:"); float price = Float.parseFloat(s.nextLine()); System.out.println("Enter the ProductQty:"); int qty = Integer.parseInt(s.nextLine());


al.add(new Product(code,name,price,qty));

al.forEach((k)->System.out.println(k));

break;

case 2:

if(al.isEmpty()) {

System.out.println("List is empty..");

}else {

System.out.println("Enter the index:");

int i1 = Integer.parseInt(s.nextLine());

if(i1>=0 && i1<al.size()) {

System.out.println("****ProductDetails****:");

System.out.println("Enter the ProductCode:");

String code2 = s.nextLine();

System.out.println("Enter the ProductName:");

String name2 = s.nextLine();

System.out.println("Enter the ProductPrice:");

float price2 = Float.parseFloat(s.nextLine());

System.out.println("Enter the ProductQty:");

int qty2 = Integer.parseInt(s.nextLine());

al.add(i1, new

Product(code2,name2,price2,qty2));

al.forEach((k)->System.out.println(k));

}else {

System.out.println("Invalid index..");

}

}





break;

case 3:

if(al.isEmpty()) {

System.out.println("List is empty..");

}else {

System.out.println("Enter the prodCode to

delete Product Details::");

String pCode = s.nextLine();

Iterator<Product> it = al.iterator();

while(it.hasNext()) {

Product p = (Product)it.next();

if(pCode.equals(p.code)) {

al.remove(p);

System.out.println("Product

deleted Successfully...");

break;

}

}//end of loop

al.forEach((k)->System.out.println(k));

}

break;

case 4:

if(al.isEmpty()) {

System.out.println("List is empty...");

}else {

System.out.println("Enter the index to remove

the element:");

int i2 = Integer.parseInt(s.nextLine());

if(i2>=0 && i2<al.size()) {

al.remove(i2);

System.out.println("Product deleted Successfully...");

al.forEach((k)->System.out.println(k));

}else {

System.out.println("Invalid index...");

}

}

break;

case 5:

if(al.isEmpty()) {

System.out.println("List is empty..");

}else {

System.out.println("Enter the index to get the

ele:");


int i3 = Integer.parseInt(s.nextLine());

if(i3>=0 && i3<al.size()){

Product el2 = al.get(i3);

System.out.println(el2.toString());

}else {

System.out.println("Invalid index..");

}

}

break;

case 6:

if(al.isEmpty()) {

System.out.println("List is empty...");

}else {

System.out.println("Enter the intex to set

Product:");

int i4 = Integer.parseInt(s.nextLine());

if(i4>=0 && i4<al.size()) {

System.out.println("****New

ProductDetails****:");

System.out.println("Enter the ProductCode:");

String code3 = s.nextLine();

System.out.println("Enter the ProductName:");

String name3 = s.nextLine();

System.out.println("Enter the ProductPrice:");

float price3 = Float.parseFloat(s.nextLine());

System.out.println("Enter the ProductQty:");

int qty3 = Integer.parseInt(s.nextLine());

al.set(i4, new

Product(code3,name3,price3,qty3));

al.forEach((k)->System.out.println(k));

}else {

System.out.println("Invalid Index...");

}

}

break;

case 7:

if(al.isEmpty()) {

System.out.println("List is empty...");

}else {

System.out.println("****Before Sorting****");

al.forEach((k)->System.out.println(k));

Collections.sort(al);//Sorting Process

System.out.println("****After Sorting****");

al.forEach((k)->System.out.println(k));








}


break;

case 8:

System.out.println("Operations Stopped..");

System.exit(0);

default:

System.out.println("Invalid Choice...");

}//end of switch

}//end of loop

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

****ProductDetails****:

Enter the ProductCode:

A001

Enter the ProductName:

Mou

Enter the ProductPrice:

1200

Enter the ProductQty:

12

A001 Mou 1200.0	12

****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

****ProductDetails****:



****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

1

****ProductDetails****:



****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting



****Choice****

1.add(E)

2.add(index,E)

3.remove(Object)

4.remove(index)

5.get(index)

6.set(index,E)

7.Sorting

8.Exit

Enter the Choice:

8

Operations Stopped..

==============================================================

*imp

Limitation of ArrayList<E>:

=>when we perform add-by-index the elements are moved backward and when

we perform remove-by-index the elements are moved forward,which consumes

execution time and degrades the performance of an application.




Note:

(i)In realtime ArrayList<E> is used in the applications having less number

of add and remove operations.

Ex:

User-Login

(ii)Limitation of ArrayList<E> can be overcomed using LinkedList<E>.

===================================================================

===

*imp

(b)LinkedList<E>:

=>LinkedList<E> organizes elements in NonSequence and which is also

NonSynchronized class.

=>In LinkedList<E> elements are available in the form of Nodes.

=>This LinkedList<E> node is divided into the following partitions:

(i)Previous Node Address

(ii)Data

(iii)Next Node Address




Diagram:







syntax:

LinkedList<Class_name> ob = new LinkedList<Class name>();








Ex : DemoList3.java




o/p:

[13, 14, 15, 16, 17]

****Iterator<E>-forward***

13 14 15 16 17

****Iterator<E>-backward***

17 16 15 14 13

***ListIterator<E>-forward-backward***

Forward : 13 14 15 16 17

Backward : 17 16 15 14 13


Diagrams:































=================================================================

Dt : 27/6/2023

faq:

wt is the diff b/w

(i)iterator()

(ii)descendingIterator()




=>If Iterator<E> object is created using iterator() method the cursor is

generated pointing before the first-element.

=>If Iterator<E> object is created using descendingIterator() method then

the cursor is generated pointing after the last-element.

=================================================================

faq:

define ListIterator<T>?

=>ListIterator<T> is an interface from java.util package and which is used

to retrieve elements from List<E> objects in both directions

(forward and backward).

=>The following are some important methods of ListIterator<T>:

public abstract boolean hasNext();

public abstract E next();

public abstract boolean hasPrevious();

public abstract E previous();

public abstract int nextIndex();

public abstract int previousIndex();

public abstract void remove();

public abstract void set(E);

public abstract void add(E);

=>we use listIterator() method to create implementation object for

ListIterator<T> interface.

syntax:

ListIterator<Class_name> li = al.listIterator();




Note:

=>ListIterator<E> is a ChildInterface of Iterator<E>,which means

ListIterator<E> extends Iterator<E>

==================================================================

Assignment:

wap to read n Integer elements and display?




Condition : While displaying replace odd number to next mutiple of 10.




i/p : 11 13 16 18 19 20

o/p : 20 20 16 18 20 20

==================================================================

*imp

(c)Vector<E>:

=>Vector<E> class extends from List<E> and which organizes elements in

Sequence.

=>Vector<E> is synchronized class and Thread-safe class

=>Vector<E> is known as Legacy Class,because having unique features

Compared to other components.

=>The following are some important methods of Vector<E>:







public synchronized int capacity();

public synchronized int size();




public synchronized E elementAt(int);

public synchronized E firstElement();

public synchronized E lastElement();

public synchronized void setElementAt(E, int);

public synchronized void removeElementAt(int);

public synchronized void insertElementAt(E, int);

public synchronized void addElement(E);

public synchronized boolean removeElement(java.lang.Object);

public synchronized void removeAllElements();


public java.util.Enumeration<E> elements();




--------------------------------------------------------------

Ex-program : DemoVector.java

package p2;

import java.util.*;
public class DemoVector {
@SuppressWarnings("removal")
public static void main(String[] args) { Vector<Integer> ob = new Vector<Integer>(); System.out.println("default

capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());

for(int i=11;i<=20;i++) {
ob.addElement(new Integer(i));
}//end of loop
System.out.println("*****Vector<E>****");
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());

ob.addElement(new Integer(500));
System.out.println("*****Vector<E>****");
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());

System.out.println("****Vector<E>****"); System.out.println("FisrtElement:"+ob.firstElement()); System.out.println("LastElement:"+ob.lastElement());

ob.setElementAt(new Integer(800), 2);
System.out.println(ob.toString());
Integer el = ob.elementAt(4);
System.out.println("Ele at index 4 : "+el);
ob.removeElementAt(2);
System.out.println(ob.toString());
ob.insertElementAt(new Integer(900), 5);
System.out.println(ob.toString());

ob.removeElement(new Integer(14));
System.out.println(ob.toString());
System.out.println("****Enumeration<E>****");
Enumeration<Integer> e1 = ob.elements();
while(e1.hasMoreElements()) {
System.out.print(e1.nextElement()+" ");
}//end of loop
System.out.println("\n****Enumeratin<E>-
asIterator()***");
Enumeration<Integer> e2 = ob.elements();
Iterator<Integer> it = e2.asIterator();
it.forEachRemaining((k)->System.out.print(k+"
"));
System.out.println("\n****Vector<E>****");
ob.removeAllElements();
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());

}

}






o/p:

default capacity:10

size of Vector:0

*****Vector<E>****

[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

capacity:10

size of Vector:10


*****Vector<E>****

[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 500]

capacity:20

size of Vector:11

****Vector<E>****

FisrtElement:11

LastElement:500

[11, 12, 800, 14, 15, 16, 17, 18, 19, 20, 500]

Ele at index 4 : 15

[11, 12, 14, 15, 16, 17, 18, 19, 20, 500]

[11, 12, 14, 15, 16, 900, 17, 18, 19, 20, 500]

[11, 12, 15, 16, 900, 17, 18, 19, 20, 500]

****Enumeration<E>****

11 12 15 16 900 17 18 19 20 500

****Enumeratin<E>-asIterator()***

11 12 15 16 900 17 18 19 20 500

****Vector<E>****

[]

capacity:20

size of Vector:0

============================================================

faq:

define Enumeration<E>?

=>Enumeration is an interface from java.util package and which is used to

retrieve elements from Vector<E> objects in forward direction

=>The following are some important methods of Enumeration<E>:

public abstract boolean hasMoreElements();

public abstract E nextElement();

public default java.util.Iterator<E> asIterator();

=>we use elements() method to create implementation object for

Enumeration<E>.

syntax:

Enumeration<Class_name> e = ob.elements();

===================================================================



Dt : 28/6/2023

Diagram:














































define asIterator()?

=>asIterator() method will create implementation object for Iterator<E>,

but the Iterator<E> Object will hold reference of Enumeration<E> Object.

===================================================================

==

Note:

=>"java.util.StringTokenizer" class is the implementation of

"java.util.Enumeration<E>" interface.

===================================================================

==

Note:

=>In realtime Enumeration<E> is used in Servlet-programming.

===================================================================

====

*imp

define Cursor statements?

=>The statements which are used to retrieve elements from Collection-Objects

are known as Cursor Statements.

=>The following are some important Cursor Statements:

(a)Iterator<E> - used on Collection-Objects

(b)ListIterator<E> - used on List-Objects

(c)Enumeration<E> - used on Vector-Objects

(d)Spliterator<T> - used on Array-Objects and Collection-Objects

===================================================================

====

Summary:

(i)ArrayList<E> used for User-Login

(ii)LinkedList<E> used for Admin-Login

(iii)Vector<E> used for Connection-Pooling concept.

(Organizing multiple Database connections among multiple users)

===================================================================

======

*imp

define Stack<E>?

=>Stack<E> is a child-class of Vector<E> and which organizes elements

based on the algorithm First-In-Last-Out or Last-In-First-Oout

=>The following are some important methods of Stack<E>:

public E push(E);

public synchronized E pop();

public synchronized E peek();

public boolean empty();

public synchronized int search(java.lang.Object);




push(E) : method is used to add the element to Stack<E>

pop()  : method is used to delete the element from top-of-stack

peek() : method is used to display the element from top-of-stack

empty() : method is used to check Stack<E> is empty or not

search(Object) : method is used to search the element from top-of-stack to

bottom of stack and display position of an element

Ex-program : DemoStack.java

package p2;

import java.util.*;
public class DemoStack {
@SuppressWarnings("removal")
public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {
Stack<Integer> ob = new Stack<Integer>(); while(true) {

System.out.println("****Choice*****"); System.out.println("\t1.push(E)"

"\n\t2.pop()"
"\n\t3.peek()"
"\n\t4.search(Object)"
"\n\t5.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
element:");
ob.push(new Integer(s.nextInt())); System.out.println(ob.toString()); break;

case 2:
if(ob.empty()) {
System.out.println("Stack is
empty...");
}else {
ob.pop();

System.out.println(ob.toString());

}
break;
case 3:
if(ob.empty()) {
System.out.println("Stack is

empty..");
}else {
System.out.println("peek ele :

"+ob.peek());

System.out.println(ob.toString());

}
break;
case 4:
if(ob.empty()) {
System.out.println("Stack is
empty...");
}else {
System.out.println("Enter the
ele to be searched:");
Integer ele = new
Integer(s.nextInt());
int pos = ob.search(ele);
if(pos>0) {
System.out.println("Ele
found at position:"+pos);
}else {
System.out.println("Ele
not found...");
}
}
break;
case 5:
System.out.println("Stack
operations Stopped.."); System.exit(0);

default:
System.out.println("Invalid
Choice...");
}//end of switch
}//end of loop
}catch(Exception e) {e.printStackTrace();} }//end of try with resource


}
}



o/p:

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

4

Stack is empty...

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

22

[22]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

21

[22, 21]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

30

[22, 21, 30]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

42

[22, 21, 30, 42]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

67

[22, 21, 30, 42, 67]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

56

[22, 21, 30, 42, 67, 56]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

57

[22, 21, 30, 42, 67, 56, 57]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

1

Enter the element:

78

[22, 21, 30, 42, 67, 56, 57, 78]

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

4

Enter the ele to be searched:

21

Ele found at position:7

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

4

Enter the ele to be searched:

100

Ele not found...

****Choice*****

1.push(E)

2.pop()

3.peek()

4.search(Object)

5.exit

Enter the Choice:

5

Stack operations Stopped..

==============================================================


Dt : 29/6/2023

3.Queue<E>:

=>Queue<E> is an interface from from java.util package and extends from

"Collection<E>".

=>Queue<E> organizes elements based on the algorithm First-In-First-Out

or Last-In-Last-Out




Diagram:




































=>The following are some important methods of Queue<E>:

public abstract boolean add(E);

public abstract boolean offer(E);

public abstract E remove();

public abstract E poll();

public abstract E element();

public abstract E peek();

=>PriorityQueue<E> is an implementation of Queue<E> and which organizes

elements based on elements-priority







add(E)  : method is used to add element to Queue-Object

offer(E) : method is used to add element to Queue-Object

(This method internally activates algorithm)




remove() : method is used to remove the element from FrontEnd

poll()  : method is also used remove the element from FrontEnd

(This method internally activates algorithm)








peek()	: method will display the element from FrontEnd

element() : method also display the element from FrontEnd

(This method internally activates algorithm)

program : DemoQueue1.java

package p2;

import java.util.*;
public class DemoQueue1 {
@SuppressWarnings("removal")
public static void main(String[] args) { PriorityQueue<Integer> pq =

new PriorityQueue<Integer>(); for(int i=1;i<=5;i++) {

pq.add(new Integer(i));
}//end of loop
System.out.println(pq.toString());
pq.offer(new Integer(600));
System.out.println(pq.toString());
pq.remove();
System.out.println(pq.toString());
pq.poll();
System.out.println(pq.toString());
System.out.println("peek : "+pq.peek());
System.out.println("element : "+pq.element());

}
}


o/p:

[1, 2, 3, 4, 5]

[1, 2, 3, 4, 5, 600]

[2, 4, 3, 600, 5]

[3, 4, 5, 600]

peek : 3

element : 3

==============================================================

Note:

=>In realtime Stack<E> and Queue<E> are used in Algorithmic designs part

of Product-based development.

==============================================================

faq:

define Deque<E>?

=>Deque<E> is an extention of Queue<E> and which organizes elements on

both ends,and which is also known as Double-ended-queue




Diagram:




































=>The following are some important methods of Deque<E>:

public abstract void addFirst(E);

public abstract void addLast(E);

public abstract boolean offerFirst(E);

public abstract boolean offerLast(E);

public abstract E removeFirst();

public abstract E removeLast();

public abstract E pollFirst();

public abstract E pollLast();

public abstract E getFirst();

public abstract E getLast();

public abstract E peekFirst();

public abstract E peekLast();

public abstract boolean removeFirstOccurrence(java.lang.Object);

public abstract boolean removeLastOccurrence(java.lang.Object);




public abstract java.util.Iterator<E> iterator();

public abstract java.util.Iterator<E> descendingIterator();




-----------------------------------------------------------------

=>The following are the implementation classes of Deque<E>

(a)ArrayDeque<E> - Organizes elements in sequence

(b)LinkedList<E> - Organiges elements in NonSequence

-----------------------------------------------------------------

Ex-program: DemoQueue2.java

package p2;

import java.util.*;
public class DemoQueue2 {
@SuppressWarnings("removal")
public static void main(String[] args) { ArrayDeque<Integer> ad = new

ArrayDeque<Integer>();
for(int i=1;i<=5;i++)
{
ad.add(new Integer(i));
}//end of loop
System.out.println(ad.toString());
ad.addFirst(new Integer(200));
ad.addLast(new Integer(400));
System.out.println(ad.toString());
ad.removeFirst();
ad.removeLast();
System.out.println(ad.toString());
ad.offerFirst(new Integer(4));
ad.offerLast(new Integer(2));
System.out.println(ad.toString());
ad.removeFirstOccurrence(new Integer(4));

System.out.println(ad.toString());
ad.removeLastOccurrence(new Integer(2));
System.out.println(ad.toString());

}

}


o/p:

[1, 2, 3, 4, 5]

[200, 1, 2, 3, 4, 5, 400]


[1, 2, 3, 4, 5]

[4, 1, 2, 3, 4, 5, 2]

[1, 2, 3, 4, 5, 2]

[1, 2, 3, 4, 5]

========================================================

Dt : 30/6/2023

faq:

define Iterable<E>?

=>Iterable<E> is an interface from java.lang package and which is

Parant-Interface of Collection<E>

=>This Iterable<E> will provide the following methods to support

iterations on Collection<E> Objects:

(a)iterator() - used to create implementation of Iterator<E> interface

(b)spliterator() - used to create implementation of Spliterator<T>

interface

(c)forEach() - forEach() introduced by Java8 version and which is

used to retrieve elements from Collection<E> objects

directly.

=>The following are the method signatures:

public abstract java.util.Iterator<T> iterator();

public default java.util.Spliterator<T> spliterator();

public default void forEach(java.util.function.Consumer<? super T>);

===============================================================

Limitation of Collection<E>:

=>Collection<E> cannot differentiate Primary-key and NonPrimary-key-values

while holding Database table data

Note:

=>Collection<E> can be Overcomed using Map<K,V>

==============================================================

*imp

Map<K,V> in Java:

=>Map<K,V> is an interface from java.util package and which organizes

elements in the form of Key-value pairs

K - Key

V - Value




=>The following are some important methods of Map<K,V>:

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean containsKey(java.lang.Object);

public abstract boolean containsValue(java.lang.Object);

public abstract V get(java.lang.Object);

public abstract V put(K, V);

public abstract V remove(java.lang.Object);

public abstract void putAll(java.util.Map<? extends K, ? extends V>);

public abstract void clear();

public abstract java.util.Set<K> keySet();

public abstract java.util.Collection<V> values();

public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();

public default void forEach(java.util.function.BiConsumer<? super K,

? super V>);

public static <K, V> java.util.Map<K, V> of();

-----------------------------------------------------------

=>The following are the implementation classes of Map<K,V>:

(a)HashMap<K,V>

(b)LinkedHashMap<K,V>

(c)TreeMap<K,V>

(d)Hashtable<K,V>




(a)HashMap<K,V>:

=>HashMap<K,V> organizes elements without any order and which is

NonSynchronized class.




(b)LinkedHashMap<K,V>:

=>LinkedHashMap<K,V> organizes elements in insertion order and which is

also NonSynchronized class.





(c)TreeMap<K,V>:

=>TreeMap<K,V> organizes elements automatically in ascending order based on

primary-key and which is also NonSynchronized class.




(d)Hashtable<K,V>:

=>Hashtable<K,V> organized elements without any order,bute it is

Synchronized and Thread-safe class.

-----------------------------------------------------------------

Dt : 1/7/2023

Ex-application:

Consider the following Table data:















Step-1 : Construct one user defined class with variables equal to

NonPrimary-key-values





EmpValues.java
package p1;

public class EmpValues {
public String name,desg;
public int bSal;
public float totSal;
public EmpValues(String name,String desg,int bSal, float totSal) {

this.name=name;
this.desg=desg;
this.bSal=bSal;
this.totSal=totSal;
}
public String toString() {
return name+"\t"+desg+"\t"+bSal+"\t"+totSal;
}
}





step-2 : Construct Map<K,V> to hold elements in the form of Key-value pairs

K - String(id)

V - EmpValues(name,desg,bSal,totSal)

Map<String,EmpValues>




Designation.java

package p1;

public class Designation {
public boolean verify(String desg) { return switch(desg) { case "SE":yield true;

case "TE":yield true;
case "ME":yield true;
case "EE":yield true;
default:yield false;
};

}
}


DemoMap.java(MainClass)

package p2;

import java.util.*;

import p1.*;

@SuppressWarnings("serial")

public class DemoMap extends Exception

{

public DemoMap(String msg)

{

super(msg);

}

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try(s;){

try {


Map<String,EmpValues> ob = null;

String nm=null;

while(true) {

System.out.println("----Choice----");

System.out.println("\t1.HashMap"

"\n\t2.LinkedHashMap"

"\n\t3.TreeMap"

"\n\t4.Hashtable"

"\n\t5.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

ob = new HashMap<String,EmpValues>(); nm="HashMap";

break;

case 2:

ob = new LinkedHashMap<String,EmpValues>(); nm="LinkedHashMap";

break;

case 3:

ob = new TreeMap<String,EmpValues>(); nm="TreeMap";

break;

case 4:

ob = new Hashtable<String,EmpValues>();

nm="Hashtable";

break;

case 5:

System.out.println("Operations Stopped on Map...");

System.exit(0);

default:

System.out.println("Invalid Choice..");

continue;

}//end of switch

System.out.println("Perform operations on "+nm);

xyz:

while(true) {

System.out.println("====Choice====");

System.out.println("\t1.put(K,V)"

"\n\t2.remove(Object)"

"\n\t3.get(Object)"

"\n\t4.keySet()"

"\n\t5.values()"

"\n\t6.Display-using-entrySet()"

"\n\t7.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) {

case 1:

while(true) {

try {



System.out.println("****EmployeeDetails****");

System.out.println("Enter the

EmpId:");

String id = s.nextLine();

System.out.println("Enter the

EmpName:");

String name = s.nextLine();

System.out.println("Enter the

EmpDesg:");

String desg =

s.nextLine().toUpperCase();

boolean z = new

Designation().verify(desg);

if(!z)//Exception

{

throw new DemoMap("Invalid

Designation...");

}

System.out.println("Enter the


bSal:");

int bSal =

Integer.parseInt(s.nextLine());

if(bSal<12000)//Exception

{

throw new

DemoMap("InValid bsal...");

}

float totSal =

bSal+(0.93F*bSal)+(0.61F*bSal);

ob.put(new String(id),

new

EmpValues(name,desg,bSal,totSal));

ob.forEach((k,v)-

>System.out.println(k+"\t"+v));

break;//stop the loop

}catch(Exception e) {

System.out.println(e.getMessage());

}

}//end of loop





break;

case 2:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

System.out.println("Enter the EmpId to

remove details:");

String eId2 = s.nextLine();

if(ob.containsKey(eId2)) {

ob.remove(eId2);

System.out.println("Emp-details

removed...");

ob.forEach((k,v)-

>System.out.println(k+"\t"+v));

}else {

System.out.println("Invalid

empId...");

}

}

break;

case 3:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {


System.out.println("Enter the empId:");

String eId3 = s.nextLine();

if(ob.containsKey(eId3)) {

EmpValues ev = ob.get(eId3);

System.out.println(ev);

}else {

System.out.println("Invalid

empId...");

}

}

break;

case 4:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

Set<String> st = ob.keySet();

System.out.println("****Key-Set****");

st.forEach((k)->System.out.println(k));

}

break;

case 5:

if(ob.isEmpty()) {

System.out.println("Map is empty...");


}else {

Collection<EmpValues> c = ob.values();

System.out.println("****Values****");

c.forEach((v)->System.out.println(v));

}

break;

case 6:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

System.out.println("****entrySet()****");

for(Map.Entry<String, EmpValues> en :

ob.entrySet())

{



System.out.println(en.getKey()+"\t"+en.getValue());

}//end of loop

}




break;

case 7:

System.out.println("Operations Stooped on

"+nm);


break xyz;

}//end of switch

}//End of InnerLoop

}//end of OuterLoop

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:




----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

2

Perform operations on LinkedHashMap

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A001

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

1200

InValid bsal...

****EmployeeDetails****

Enter the EmpId:

1

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

12000

Raj   SE   1200030480.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:



****EmployeeDetails****

Enter the EmpId: 2

Enter the EmpName: Ram

Enter the EmpDesg:

TE

Enter the bSal:

17000

1	Raj	SE	1200030480.0

Ram  TE   1700043180.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice: 7

Operations Stooped on LinkedHashMap

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice: 3

Perform operations on TreeMap

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E10

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

120000

E10	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E5

Enter the EmpName:

Ram

Enter the EmpDesg:

TE

Enter the bSal:

180000

E10	Raj	SE	120000	304800.0

E5	Ram  TE	180000	457200.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A

Enter the EmpName:

Rah

Enter the EmpDesg:

TE

Enter the bSal:

16788

Rah  TE   1678842641.52



2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

B34

Enter the EmpName:

Rkk

Enter the EmpDesg:

TE

Enter the bSal:

19000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0



1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

C23

Enter the EmpName:

Ra

Enter the EmpDesg:

TE

Enter the bSal:

17000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0

C23  Ra   TE   1700043180.0

E10  Raj   SE   120000304800.0

E5	Ram  TE	180000	457200.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

D24

Enter the EmpName:

Rt

Enter the EmpDesg:

SE

Enter the bSal:

16000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0



====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

7

Operations Stooped on TreeMap

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

4

Perform operations on Hashtable

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E12

Enter the EmpName:

Raj

Enter the EmpDesg:

SE


Enter the bSal:

120000

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A11

Enter the EmpName:

Ram

Enter the EmpDesg:

SE

Enter the bSal:

19000

A11	Ram  SE	1900048260.0

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

Z23

Enter the EmpName:

Ram

Enter the EmpDesg:

SE

Enter the bSal:

18000

A11	Ram  SE	1900048260.0

Z23	Ram  SE	1800045720.0

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

7

Operations Stooped on Hashtable

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

5

Operations Stopped on Map...

=====================================================


Dt : 30/6/2023

faq:

define Iterable<E>?

=>Iterable<E> is an interface from java.lang package and which is

Parant-Interface of Collection<E>

=>This Iterable<E> will provide the following methods to support

iterations on Collection<E> Objects:

(a)iterator() - used to create implementation of Iterator<E> interface

(b)spliterator() - used to create implementation of Spliterator<T>

interface

(c)forEach() - forEach() introduced by Java8 version and which is

used to retrieve elements from Collection<E> objects

directly.

=>The following are the method signatures:

public abstract java.util.Iterator<T> iterator();

public default java.util.Spliterator<T> spliterator();

public default void forEach(java.util.function.Consumer<? super T>);

===============================================================

Limitation of Collection<E>:

=>Collection<E> cannot differentiate Primary-key and NonPrimary-key-values

while holding Database table data

Note:

=>Collection<E> can be Overcomed using Map<K,V>

==============================================================

*imp

Map<K,V> in Java:

=>Map<K,V> is an interface from java.util package and which organizes

elements in the form of Key-value pairs

K - Key

V - Value




=>The following are some important methods of Map<K,V>:

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean containsKey(java.lang.Object);

public abstract boolean containsValue(java.lang.Object);

public abstract V get(java.lang.Object);

public abstract V put(K, V);

public abstract V remove(java.lang.Object);

public abstract void putAll(java.util.Map<? extends K, ? extends V>);

public abstract void clear();

public abstract java.util.Set<K> keySet();

public abstract java.util.Collection<V> values();

public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();

public default void forEach(java.util.function.BiConsumer<? super K,

? super V>);

public static <K, V> java.util.Map<K, V> of();

-----------------------------------------------------------

=>The following are the implementation classes of Map<K,V>:

(a)HashMap<K,V>

(b)LinkedHashMap<K,V>

(c)TreeMap<K,V>

(d)Hashtable<K,V>




(a)HashMap<K,V>:

=>HashMap<K,V> organizes elements without any order and which is

NonSynchronized class.




(b)LinkedHashMap<K,V>:

=>LinkedHashMap<K,V> organizes elements in insertion order and which is

also NonSynchronized class.





(c)TreeMap<K,V>:

=>TreeMap<K,V> organizes elements automatically in ascending order based on

primary-key and which is also NonSynchronized class.




(d)Hashtable<K,V>:

=>Hashtable<K,V> organized elements without any order,bute it is

Synchronized and Thread-safe class.

-----------------------------------------------------------------

Dt : 1/7/2023

Ex-application:

Consider the following Table data:















Step-1 : Construct one user defined class with variables equal to

NonPrimary-key-values





EmpValues.java
package p1;

public class EmpValues {
public String name,desg;
public int bSal;
public float totSal;
public EmpValues(String name,String desg,int bSal, float totSal) {

this.name=name;
this.desg=desg;
this.bSal=bSal;
this.totSal=totSal;
}
public String toString() {
return name+"\t"+desg+"\t"+bSal+"\t"+totSal;
}
}





step-2 : Construct Map<K,V> to hold elements in the form of Key-value pairs

K - String(id)

V - EmpValues(name,desg,bSal,totSal)

Map<String,EmpValues>




Designation.java

package p1;

public class Designation {
public boolean verify(String desg) { return switch(desg) { case "SE":yield true;

case "TE":yield true;
case "ME":yield true;
case "EE":yield true;
default:yield false;
};

}
}


DemoMap.java(MainClass)

package p2;

import java.util.*;

import p1.*;

@SuppressWarnings("serial")

public class DemoMap extends Exception

{

public DemoMap(String msg)

{

super(msg);

}

public static void main(String[] args)

{

Scanner s = new Scanner(System.in);

try(s;){

try {


Map<String,EmpValues> ob = null;

String nm=null;

while(true) {

System.out.println("----Choice----");

System.out.println("\t1.HashMap"

"\n\t2.LinkedHashMap"

"\n\t3.TreeMap"

"\n\t4.Hashtable"

"\n\t5.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

ob = new HashMap<String,EmpValues>(); nm="HashMap";

break;

case 2:

ob = new LinkedHashMap<String,EmpValues>(); nm="LinkedHashMap";

break;

case 3:

ob = new TreeMap<String,EmpValues>(); nm="TreeMap";

break;

case 4:

ob = new Hashtable<String,EmpValues>();

nm="Hashtable";

break;

case 5:

System.out.println("Operations Stopped on Map...");

System.exit(0);

default:

System.out.println("Invalid Choice..");

continue;

}//end of switch

System.out.println("Perform operations on "+nm);

xyz:

while(true) {

System.out.println("====Choice====");

System.out.println("\t1.put(K,V)"

"\n\t2.remove(Object)"

"\n\t3.get(Object)"

"\n\t4.keySet()"

"\n\t5.values()"

"\n\t6.Display-using-entrySet()"

"\n\t7.exit"); System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) {

case 1:

while(true) {

try {



System.out.println("****EmployeeDetails****");

System.out.println("Enter the

EmpId:");

String id = s.nextLine();

System.out.println("Enter the

EmpName:");

String name = s.nextLine();

System.out.println("Enter the

EmpDesg:");

String desg =

s.nextLine().toUpperCase();

boolean z = new

Designation().verify(desg);

if(!z)//Exception

{

throw new DemoMap("Invalid

Designation...");

}

System.out.println("Enter the


bSal:");

int bSal =

Integer.parseInt(s.nextLine());

if(bSal<12000)//Exception

{

throw new

DemoMap("InValid bsal...");

}

float totSal =

bSal+(0.93F*bSal)+(0.61F*bSal);

ob.put(new String(id),

new

EmpValues(name,desg,bSal,totSal));

ob.forEach((k,v)-

>System.out.println(k+"\t"+v));

break;//stop the loop

}catch(Exception e) {

System.out.println(e.getMessage());

}

}//end of loop





break;

case 2:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

System.out.println("Enter the EmpId to

remove details:");

String eId2 = s.nextLine();

if(ob.containsKey(eId2)) {

ob.remove(eId2);

System.out.println("Emp-details

removed...");

ob.forEach((k,v)-

>System.out.println(k+"\t"+v));

}else {

System.out.println("Invalid

empId...");

}

}

break;

case 3:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {


System.out.println("Enter the empId:");

String eId3 = s.nextLine();

if(ob.containsKey(eId3)) {

EmpValues ev = ob.get(eId3);

System.out.println(ev);

}else {

System.out.println("Invalid

empId...");

}

}

break;

case 4:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

Set<String> st = ob.keySet();

System.out.println("****Key-Set****");

st.forEach((k)->System.out.println(k));

}

break;

case 5:

if(ob.isEmpty()) {

System.out.println("Map is empty...");


}else {

Collection<EmpValues> c = ob.values();

System.out.println("****Values****");

c.forEach((v)->System.out.println(v));

}

break;

case 6:

if(ob.isEmpty()) {

System.out.println("Map is empty...");

}else {

System.out.println("****entrySet()****");

for(Map.Entry<String, EmpValues> en :

ob.entrySet())

{



System.out.println(en.getKey()+"\t"+en.getValue());

}//end of loop

}




break;

case 7:

System.out.println("Operations Stooped on

"+nm);


break xyz;

}//end of switch

}//End of InnerLoop

}//end of OuterLoop

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:




----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

2

Perform operations on LinkedHashMap

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A001

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

1200

InValid bsal...

****EmployeeDetails****

Enter the EmpId:

1

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

12000

Raj   SE   1200030480.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:



****EmployeeDetails****

Enter the EmpId: 2

Enter the EmpName: Ram

Enter the EmpDesg:

TE

Enter the bSal:

17000

1	Raj	SE	1200030480.0

Ram  TE   1700043180.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice: 7

Operations Stooped on LinkedHashMap

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice: 3

Perform operations on TreeMap

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E10

Enter the EmpName:

Raj

Enter the EmpDesg:

SE

Enter the bSal:

120000

E10	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E5

Enter the EmpName:

Ram

Enter the EmpDesg:

TE

Enter the bSal:

180000

E10	Raj	SE	120000	304800.0

E5	Ram  TE	180000	457200.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A

Enter the EmpName:

Rah

Enter the EmpDesg:

TE

Enter the bSal:

16788

Rah  TE   1678842641.52



2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

B34

Enter the EmpName:

Rkk

Enter the EmpDesg:

TE

Enter the bSal:

19000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0



1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

C23

Enter the EmpName:

Ra

Enter the EmpDesg:

TE

Enter the bSal:

17000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0

C23  Ra   TE   1700043180.0

E10  Raj   SE   120000304800.0

E5	Ram  TE	180000	457200.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

D24

Enter the EmpName:

Rt

Enter the EmpDesg:

SE

Enter the bSal:

16000

Rah  TE   1678842641.52

B34  Rkk  TE   1900048260.0



====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

7

Operations Stooped on TreeMap

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

4

Perform operations on Hashtable

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

E12

Enter the EmpName:

Raj

Enter the EmpDesg:

SE


Enter the bSal:

120000

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

A11

Enter the EmpName:

Ram

Enter the EmpDesg:

SE

Enter the bSal:

19000

A11	Ram  SE	1900048260.0

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

1

****EmployeeDetails****

Enter the EmpId:

Z23

Enter the EmpName:

Ram

Enter the EmpDesg:

SE

Enter the bSal:

18000

A11	Ram  SE	1900048260.0

Z23	Ram  SE	1800045720.0

E12	Raj	SE	120000	304800.0

====Choice====

1.put(K,V)

2.remove(Object)

3.get(Object)

4.keySet()

5.values()

6.Display-using-entrySet()

7.exit

Enter the Choice:

7

Operations Stooped on Hashtable

----Choice----

1.HashMap

2.LinkedHashMap

3.TreeMap

4.Hashtable

5.exit

Enter the Choice:

5

Operations Stopped on Map...

=====================================================


Dt : 3/7/2023

Diagram:(Representating Map<K,V>)










































=======================================================

faq:

define forEach() method?

=>forEach() method introduced by Java8 version and which is used to

retrieve elements from Collecition<E> and Map<K,V> objects directly.

structure of forEach() on Collection<E>:

public default void forEach(java.util.function.Consumer<? super T>);




structure of forEach() on Map<K,V>:

public default void forEach(java.util.function.BiConsumer<? super K,

? super V>);




faq:

define Consumer<T>?

=>Consumer<T> is a functional interface from java.util.function package

introduced by Java8 version and which provide abstract method-accept(T) to

hold LambdaExpression passed as parameter to forEach() method on

Collection<E>




structure of Consumer<T>:

public interface java.util.function.Consumer<T>

{

public abstract void accept(T);

..


}

Ex:

ob.forEach((T)->

{

//statements

});

---------------------------------------------------------------

faq:

define BiConsumer<T,U>?

=>BiConsumer<T,U> is a functional interface from java.util.function package

introduced by Java8 version and which provide abstract method-accept(T,U)

to hold LambdaExpression passed as parameter to forEach() method on Map<K,V>



Structure of BiConsumer<T,U>:

public interface java.util.function.BiConsumer<T, U>

{

public abstract void accept(T, U);

...

}





Ex:

ob.forEach((T,U)->

{

//Statements

});

=============================================================

faq:

define BiPredicate<T,U>?

=>BiPredicate<T,U> is a functional interface from java.util.function

package introduced by Java8 version and which is used to perform conditional

operation on Map<K,V> objects




Structure of BiPredicate<T,U>:

public interface java.util.function.BiPredicate<T, U>

{

public abstract boolean test(T, U);

...

}

==============================================================

Ex-Program:

DemoMap2.java

package p2;

import java.util.*;

import java.util.function.*;

import p1.*;

public class DemoMap2 {

public static void main(String[] args) {

LinkedHashMap<String,EmpValues> ob=

new LinkedHashMap<String,EmpValues>();

ob.put(new String("A001"),

new

EmpValues("Raj","SE",12000,12000+(0.93F*12000)+(0.63F*12000)));

ob.put(new String("A005"),

new

EmpValues("Ram","ME",9000,9000+(0.93F*9000)+(0.63F*9000)));

ob.put(new String("A003"),

new

EmpValues("Alex","TE",8000,8000+(0.93F*8000)+(0.63F*8000)));

ob.put(new String("A006"),

new

EmpValues("AAAA","SE",16000,16000+(0.93F*16000)+(0.63F*16000)));

ob.put(new String("A009"),

new

EmpValues("TRTR","TE",7000,7000+(0.93F*7000)+(0.63F*7000)));

System.out.println("====EmployeeDetails====");

ob.forEach((k,v)->System.out.println(k+"\t"+v));

BiPredicate<String,EmpValues> bp =

(k,v)->v.bSal<10000;

System.out.println("====EmployeeDetails-bSal<10000===");

ob.forEach((k,v)->

{

if(bp.test(k, v))

{

System.out.println(k+"\t"+v);

}

});

}

}







o/p:

====EmployeeDetails====



====EmployeeDetails-bSal<10000===

A005 Ram  ME	9000 23040.0



==================================================================

Dt : 4/7/2023

faq:

define sort() method in List<E>?

=>sort() method in List<E> introduced by Java8 version and which is used

to perform sorting operation based on individual fields.




Method Signature:

public default void sort(java.util.Comparator<? super E>);




Ex-Application:

BookDetails.java

package p1;

public class BookDetails {
public String code,name,author;
public float price;
public int qty;
public BookDetails(String code,String name,String author,

float price,int qty) {
this.code=code;
this.name=name;
this.author=author;
this.price=price;
this.qty=qty;
}
public String toString() {
return
code+"\t"+name+"\t"+author+"\t"+price+"\t"+qty;
}

}

SortByCode.java

package p1;

import java.util.*; @SuppressWarnings("rawtypes")

public class SortByCode implements Comparator

{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
int z = bd1.code.compareTo(bd2.code);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}


SortByName.java

package p1;

import java.util.*; @SuppressWarnings("rawtypes")

public class SortByName implements Comparator

{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
int z = bd1.name.compareTo(bd2.name);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}



SortByAuthor.java
package p1;

import java.util.*; @SuppressWarnings("rawtypes")

public class SortByAuthor implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1; BookDetails bd2 = (BookDetails)ob2;

int z = bd1.author.compareTo(bd2.author);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}


SortByPrice.java

package p1;

import java.util.*; @SuppressWarnings("rawtypes")

public class SortByPrice implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1; BookDetails bd2 = (BookDetails)ob2; if(bd1.price==bd2.price) return 0; else if(bd1.price>bd2.price) return 1; else return -1;

}
}


SortByQty.java


package p1;

import java.util.*;
@SuppressWarnings("rawtypes")

public class SortByQty implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1; BookDetails bd2 = (BookDetails)ob2; if(bd1.qty==bd2.qty) return 0; else if(bd1.qty>bd2.qty) return 1; else return -1;

}
}


DemoList4.java(MainClass)

package p2;

import java.util.*;

import p1.*;

public class DemoList4 {

@SuppressWarnings("unchecked")

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

ArrayList<BookDetails> ob=

new ArrayList<BookDetails>();

ob.add(new BookDetails("A112","C-Lang","B-Swamy",1200,12));

ob.add(new BookDetails("A102","HBT","Abc",1100,10));

ob.add(new BookDetails("A109","AdvJava","Xyz",100,2));

ob.add(new BookDetails("A110","CoreJ","GRT",200,4));

ob.add(new BookDetails("A103","Spring","SHT",1800,9));

ob.add(new BookDetails("A111","Boot","Pqr",1500,11));

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));

while(true) {

System.out.println("---Sorting-Choice----");

System.out.println("\t1.Sort-by-Code"

"\n\t2.Sort-by-name"

"\n\t3.Sort-by-author"

"\n\t4.Sort-by-price"

"\n\t5.Sort-by-Qty"

"\n\t6.exit");

System.out.println("Enter the Choice:"); switch(Integer.parseInt(s.nextLine())) { case 1:

ob.sort(new SortByCode()); System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k)); break;

case 2:

ob.sort(new SortByName());

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));

break;

case 3:

ob.sort(new SortByAuthor());

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));

break;

case 4:

ob.sort(new SortByPrice());

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));

break;

case 5:

ob.sort(new SortByQty());

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));

break;

case 6:

System.out.println("Operation Stopped..");

System.exit(0);

default:

System.out.println("Invalid Choice...");

}//end of switch

}//end of loop

}catch(Exception e) {e.printStackTrace();}

}//end of try

}



---Sorting-Choice----

1.Sort-by-Code

2.Sort-by-name

3.Sort-by-author

4.Sort-by-price

5.Sort-by-Qty



---Sorting-Choice----

1.Sort-by-Code

2.Sort-by-name

3.Sort-by-author

4.Sort-by-price

5.Sort-by-Qty

6.exit

Enter the Choice:

6

Operation Stopped..





============================================================

define Comparator<T>?

=>Comparator<T> is an interface from java.util package and which is also

used to perform Sorting process on Collection<E> objects.




structure of Comparator<T>:

public interface java.util.Comparator<T>

{

public abstract int compare(T, T);

...

}




=============================================================

Ex-program : Demonstrating some methods of Set<E>




DemoSet4Methods.java

package p2;

import java.util.*;
public class DemoSet4Methods { @SuppressWarnings("removal")

public static void main(String[] args) { LinkedHashSet<Integer> ob1 =

new LinkedHashSet<Integer>(); ob1.add(new Integer(11)); ob1.add(new Integer(12)); ob1.add(new Integer(13)); ob1.add(new Integer(14));

System.out.println("ob1 : "+ob1.toString());
LinkedHashSet<Integer> ob2 =

new LinkedHashSet<Integer>(); ob2.add(new Integer(21)); ob2.add(new Integer(22)); ob2.add(new Integer(23)); ob2.add(new Integer(24));

System.out.println("ob2 : "+ob2.toString());
System.out.println("****addAll()****");
ob1.addAll(ob2);
System.out.println("ob1 : "+ob1.toString());
System.out.println("****containsAll()*****");
boolean k = ob1.containsAll(ob2);
System.out.println("ob1 contains ob2 : "+k);
System.out.println("****contains(Object)****");
boolean z = ob1.contains(new Integer(13));
System.out.println("ob1 contains 13 : "+z);
System.out.println("****removeAll()****");
ob1.removeAll(ob2);
System.out.println("ob1 : "+ob1.toString());
System.out.println("****retainAll()****");
LinkedHashSet<Integer> ob3 =
new LinkedHashSet<Integer>(); ob3.add(new Integer(1)); ob3.add(new Integer(12)); ob3.add(new Integer(13)); ob3.add(new Integer(4)); ob1.retainAll(ob3);

System.out.println("ob1 : "+ob1.toString()); System.out.println("***Immutable Set<E>

Object***");
Set<Integer> ob4 = Set.of(31,32,33,34);
System.out.println("ob4 : "+ob4.toString());
//ob4.add(new Integer(23));//Error
System.out.println("****clear()****");
ob1.clear();
ob2.clear();
System.out.println("ob1 : "+ob1.toString());
System.out.println("ob2 : "+ob2.toString());
}

}


o/p:

ob1 : [11, 12, 13, 14]

ob2 : [21, 22, 23, 24]

****addAll()****

ob1 : [11, 12, 13, 14, 21, 22, 23, 24]

****containsAll()*****

ob1 contains ob2 : true

****contains(Object)****

ob1 contains 13 : true

****removeAll()****

ob1 : [11, 12, 13, 14]

****retainAll()****

ob1 : [12, 13]

***Immutable Set<E> Object***

ob4 : [31, 32, 33, 34]

****clear()****

ob1 : []

ob2 : []

===================================================================

=

Ex-program:(Demonstrating some important methods from List<E>)


DemoList5.java

package p2;

import java.util.*;
public class DemoList5 {
@SuppressWarnings("removal")
public static void main(String[] args) { ArrayList<Integer> ob1 =

new ArrayList<Integer>(); ob1.add(new Integer(11)); ob1.add(new Integer(12)); ob1.add(new Integer(13)); ob1.add(new Integer(14));

System.out.println("ob1 : "+ob1.toString());

ArrayList<Integer> ob2 =

new ArrayList<Integer>(); ob2.add(new Integer(21)); ob2.add(new Integer(22)); ob2.add(new Integer(23)); ob2.add(new Integer(24));

System.out.println("ob2 : "+ob2.toString()); System.out.println("***addAll(index,Collection<E>)***") ;

ob1.addAll(1, ob2);
System.out.println("ob1 : "+ob1.toString()); System.out.println("****indexOf(Object)****"); int i1 = ob1.indexOf(new Integer(13)); System.out.println("index of 13 is : "+i1); ob1.add(new Integer(11));

System.out.println("****lastIndexOf(Object)****"); System.out.println("ob1 : "+ob1.toString()); int i2 = ob1.lastIndexOf(new Integer(11)); System.out.println("last index of 11 is : "+i2);

System.out.println("****subList(index,index)****"); List<Integer> ob3 = ob1.subList(2, 7); System.out.println("ob3 : "+ob3.toString()); System.out.println("***listIterator(index)****"); ListIterator<Integer> li = ob1.listIterator(3);
System.out.print("Forward : ");

while(li.hasNext()) {
System.out.print(li.next()+" ");
}
System.out.print("\nBackward : ");
while(li.hasPrevious()) {
System.out.print(li.previous()+" ");

}
}
}





o/p:

ob1 : [11, 12, 13, 14]

ob2 : [21, 22, 23, 24]

***addAll(index,Collection<E>)***

ob1 : [11, 21, 22, 23, 24, 12, 13, 14]

****indexOf(Object)****

index of 13 is : 6

****lastIndexOf(Object)****

ob1 : [11, 21, 22, 23, 24, 12, 13, 14, 11]

last index of 11 is : 8

****subList(index,index)****

ob3 : [22, 23, 24, 12, 13]

***listIterator(index)****

Forward : 23 24 12 13 14 11

Backward : 11 14 13 12 24 23 22 21 11

===============================================================

Dt : 5/7/2023

faq:

define Function<T,R>?

=>Function<T,R> is an functional interface from java.util.function package

introduced by Java8 version and which is used to perform functional operation

on Collection<E> objects.




Structure of Function<T,R>:

public interface java.util.function.Function<T, R>

{

public abstract R apply(T);

...

}




Ex:

Function<T,R> ob = (T)->

{

//body

};





faq:

define BiFunction<T,U,R>?

=>BiFunction<T,U,R> is an functional interface from java.util.function

package introduced by Java8 version and which is used to perform functional

operation on Map<K,V> objects.




Structure of BiFunction<T,U,R>:

public interface java.util.function.BiFunction<T, U, R>

{

public abstract R apply(T, U);

...

}




Ex:

BiFunction<T,U,R> ob = (T,U)->

{

//body

};




-----------------------------------------------------------------------

Ex-program:

DemoFunction.java

package p2;

import java.util.*;

import java.util.function.*;

public class DemoFunction {

@SuppressWarnings("removal")

public static void main(String[] args) {

ArrayList<Integer> al = new ArrayList<Integer>();

al.add(new Integer(12));

al.add(new Integer(10));

al.add(new Integer(9));

al.add(new Integer(15));

System.out.println("al : "+al.toString());

Function<Integer,Integer> ob1 = (x)->x+10;

System.out.println("====List<E> by +10====");

al.forEach((k)->

{

System.out.print(ob1.apply(k)+" ");

});

System.out.println("\n====List<E>====");

System.out.println("al : "+al.toString());

System.out.println("\n=====List<E>-replaceAll()====");

al.replaceAll((x)->x*10);

al.forEach((k)->

{

System.out.print(k+" ");

});




System.out.println("\n-----Map<K,V>-Object----");

LinkedHashMap<String,Float> ob2 =

new LinkedHashMap<String,Float>();

ob2.put(new String("A001"), new Float(123.45F));

ob2.put(new String("A002"), new Float(113.25F));

ob2.put(new String("A005"), new Float(133.15F));

ob2.put(new String("A006"), new Float(103.45F));

ob2.put(new String("A004"), new Float(163.25F));

ob2.forEach((k,v)->

{

System.out.println(k+"\t"+v);

});




BiFunction<String,Float,Float> ob3 =

(x,y)->y.floatValue()+30;

System.out.println("====BiFunction<T,U,R>====");

ob2.forEach((k,v)->

{


System.out.println(k+"\t"+ob3.apply(k, v));

});

System.out.println("====replaceAll()======");

ob2.replaceAll((x,y)->y.floatValue()+50);

ob2.forEach((k,v)->

{

System.out.println(k+"\t"+v);

});

}

}

o/p:

al : [12, 10, 9, 15]

====List<E> by +10====

22 20 19 25

====List<E>====

al : [12, 10, 9, 15]




=====List<E>-replaceAll()====

120 100 90 150

-----Map<K,V>-Object----



A006 103.45

A004 163.25

====BiFunction<T,U,R>====

A001 153.45

A002 143.25

A005 163.15

A006 133.45

A004 193.25

====replaceAll()======

A001 173.45

A002 163.25

A005 183.15

A006 153.45

A004 213.25

=============================================================

Structures of replaceAll() mnethods




public default void replaceAll(java.util.function.UnaryOperator<E>);

public default void replaceAll(java.util.function.BiFunction<? super K,

super V, ? extends V>);

============================================================

Note:

=>The following are some important pre-defined functional interfaces

introduced by Java8 version:

1.Consumer<T>

2.BiConsumer<T,U>

3.Predicate<T>

4.BiPredicate<T,U>

5.Function<T,R>

6.BiFunction<T,U,R>

===================================================================

define Enum<E>?

=>Enum<E> is an abstract class from java.lang package and which is used

to generate enum-objects.

=>we use the following syntax to create enum-objects:




enum Enum name


{

//elements

//variables

//methods

}

Enum is a special data type that allows you to define a set of named values, known as enumerators or constants, that represent a fixed number of possible values for a variable
Ex-program:


Enums are often used to represent a limited set of possible values that are relevant to a specific context in your

program.

Enum - is collection of named constant

Cars.java

package p1;

public enum Cars {
Figo(900),Alto(500),Dezire(700); public int price;

private Cars(int price) {
this.price=price;
}
public int getPrice() {
return price;
}
}


DemoEnum.java(MainClass)

package p2;

import java.util.*;

import p1.Cars;

public class DemoEnum {

public static void main(String[] args) {

Cars c[] = Cars.values();

System.out.println("===Enum-data====");

Spliterator<Cars> sp = Arrays.spliterator(c);

sp.forEachRemaining((k)->

{

System.out.println(k+" Costs "+k.getPrice()

+" Thousand Dollars");


});

}

}

o/p:

===Enum-data====

Figo Costs 900 Thousand Dollars

Alto Costs 500 Thousand Dollars

Dezire Costs 700 Thousand Dollars




Diagram:


































============================================================

Note:

=>Enum<E> is less used when compared to Classes and Interfaces.

=>Enum<E> can be used to hold defined list of elements like Week-days and

months in year

=>The Constructors which are declared in Enum<E> are automatically

private-constructors

==============================================================

Dt : 6/7/2023

*imp

Multi-Threading in Java:

define Application?

=>set-of-programs collected together to perform defined action

is known as Application.




define Process?

=>According to OperatingSystem,the program under execution is a

process.

=>According to Java Language,the application under execution is a

process.




define Task?

=>The part-of-process is known as Task.







define Multi Tasking?

=>Executing multiple tasks simultaneously is known as Multi

Tasking.(Simultaneously means at-a-time but not parallel)

=>Multi Tasking is categorized into two types:

(a)Process based Multi-Tasking

(b)Thread based Multi-Tasking




(a)Process based Multi-Tasking:

=>Executing Multiple tasks from multiple processes is known as

Process based Multi-Tasking.

=>Process based Multi-Tasking is used in OperatingSystem designs.




(b)Thread based Multi-Tasking:

=>Executing multiple tasks from the same application(process)

is known as Thread based Multi-Tasking.

=>Thread Based Multi-Tasking is used in application development.




---------------------------------------------------------

Note:

=>Each program in application is a Task,which means each Servlet

Program is a task.

---------------------------------------------------------

faq:

define Thread?

=>The part of task is known as Thread.

=>Thread is a LightWeight and Background process.

LightWeight - means consumes less execution time

Background process - means no separate identification

-------------------------------------------------------------

faq:

define Multi-threading?

=>Executing multiple threads simultaneously is known as Multi

Thrreading.

-------------------------------------------------------------

Diagrams:
































============================================================

Dt : 7/7/2023





































Creating and Executing Thread:

=>we use the following process to create and execute threads:

step-1 : The user defined class must be implemented from

java.lang.Runnable interface

Structure of Runnable:

public interface java.lang.Runnable

{

public abstract void run();

}


step-2 : The user defined class must implement "run()" method

(run() method will hold the required logic)




step-3 : Create object for User defined class




step-4 : Create object for Pre-defined class "Thread" and

while object creation pass user defined class object

reference as parameter.

(Thread-Class Object will hold the reference of User defined

Class-Object)




step-5 : Execute run() method using start() method

----------------------------------------------------------

Ex-Application:

Register.java

package p1;

import java.util.*;
public class Register implements Runnable{ @Override

public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Reg...by Alex.."+new
Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms

}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
}


Login.java

package p1;

import java.util.Date;
public class Login implements Runnable{ @Override

public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Log...by Raj.."+new
Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie) {ie.printStackTrace();}

}
}
}


DemoThread1.java(MainClass)

package p2;

import p1.*;
public class DemoThread1 {
public static void main(String[] args) { Register ob1 = new Register(); Login ob2 = new Login();

Thread t1 = new Thread(ob1);

Thread t2 = new Thread(ob2);

t1.start();
t2.start();

}
}


o/p:

Reg...by Alex..Fri Jul 07 20:06:00 IST 2023

Log...by Raj..Fri Jul 07 20:06:00 IST 2023

Reg...by Alex..Fri Jul 07 20:06:02 IST 2023

Log...by Raj..Fri Jul 07 20:06:02 IST 2023

Reg...by Alex..Fri Jul 07 20:06:04 IST 2023

Log...by Raj..Fri Jul 07 20:06:04 IST 2023

Reg...by Alex..Fri Jul 07 20:06:06 IST 2023

Log...by Raj..Fri Jul 07 20:06:06 IST 2023

Reg...by Alex..Fri Jul 07 20:06:08 IST 2023

Log...by Raj..Fri Jul 07 20:06:08 IST 2023

---------------------------------------------

Execution flow of above program:

ClassFiles:

Register.class

Login.class

DemoThread.class(MainClass)








































===========================================================

*imp

Creating threads using Anonymoys InnerClasses:

=>In this model User defined classes are declared as "Anonymous

InnerClasses as implemententation classes of Runnable"




Ex:

DemoThread2.java
package p2;

import java.util.Date;
public class DemoThread2 {
public static void main(String[] args) { Runnable ob1 = new Runnable()

{
@Override
public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Reg...by
Alex.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie) {ie.printStackTrace();}

}
}
};
Runnable ob2 = new Runnable()
{
@Override
public void run() {
for(int i =1;i<=5;i++) {
System.out.println("Log...by
Raj.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
};

Thread t1 = new Thread(ob1);

Thread t2 = new Thread(ob2);

t1.start();

t2.start();
}

}


==================================================

*imp

Creating threads using LambdaExpressions:(Java8)

=>In this model run() method is declared without name,which means

as LambdaExpression.




Ex:

DemoThread3.java

package p2;

import java.util.Date;
public class DemoThread3 {
public static void main(String[] args) { Runnable ob1 = ()->

{
for(int i=1;i<=5;i++) {
System.out.println("Reg...by
Alex.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie) {ie.printStackTrace();}

}
};
Runnable ob2 = ()->
{
for(int i=1;i<=5;i++) {
System.out.println("Log...by

Raj.."+new Date());
try {
Thread.sleep(2000);

//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
};

Thread t1 = new Thread(ob1);

Thread t2 = new Thread(ob2);

t1.start();

t2.start();
}
}


=========================================================

Dt : 8/7/2023

faq:

define start() method?

=>start() is a pre-defined method from java.lang.Thread class

and specify the following:

(i)creating separate thread-stack

(ii)calling run() method for execution,and this run() method

loaded to separate thread-stack.

(iii)Activating Thread Scheduler or Thread Manager to execute

thread




faq:

define Thread Scheduler?

=>Thread Scheduler is a pre-defined threading algorithm used to

control thread executions based on the following algorithms:

(i)Time Slicing Algorithm

(ii)Priority based Algorithm




(i)Time Slicing Algorithm:

=>In Time Slicing Algorithm all multiple threads are executed

simultaneously based on defined TimeSlice.

(ii)Priority based Algorithm:

=>In Priority based Algorithm the threads are executed based on

thread priorities.

=========================================================

faq:

define sleep() method?

=>sleep() is a pre-defined method from java.lang.Thread class to

stop the execution process temporarly on some time.

syntax:

Thread.sleep(milliseconds);

=========================================================

*imp

Creating Threads using Method references:

=>In this model run() method is attached with the body from a

class,where class is not related to "Runnable" interface.




Ex:

Display1.java

package p1;

public class Display1 { public static void dis1() {

for(int i=1;i<=5;i++) {
System.out.println("Display1...");
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();} }//end of loop

}
}


Display2.java

package p1;

public class Display2 { public static void dis2() {

for(int i=1;i<=5;i++) {
System.out.println("Display2...");
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}//end of loop
}
}


DemoThread4.java(MainClass)

package p2;

import p1.*;
public class DemoThread4 {
public static void main(String[] args) {

new Thread(Display1 :: dis1).start();

new Thread(Display2 :: dis2).start();

}

}


o/p:

Display1...


Display2...

Display1...

Display2...

Display1...

Display2...

Display1...

Display2...




Diagram:

====================================================

faq:

define UnSafe state of an application?

=>The process in which more than one user using the same resource

(Class or Object or Method) is known as UnSafe state of an

application and which generate Wrong results.




Note:

=>We use Thread Synchronization process to convert UnSafe state

application into Safe State application.

=========================================================

*imp

define Thread Synchronization?

=>The process of ordering the threads for execution is known as

Thread Synchronization process.

=>Thread Synchronization process can be performed in two ways:

1.Mutual Exclusion process

2.Thread Communication process




1.Mutual Exclusion process:

=>The process of locking the programming resources and ordering

the threads for execution is known as Mutual Exclusion process.

=>This Mutual Exclusion process can be perfored in three ways:

(a)Synchronized block - Object Locking process

(b)Synchronized method - Instance method Locking process

(c)Static synchronization - Static method Locking process

Dt : 10/7/2023

(a)Synchronized block - Object Locking process

=>The process of declaring set-of-statements with "synchronized"

keyword is known as synchronized block.

syntax:

synchronized(ref-var)

{

//set-of-statements

}

=>This synchronized block process is used to apply the lock on

the Object




Ex:

Available.java

package p1;

public class Available {
public static int available=1;
}


Selection.java

package p1;

public class Selection {
public void select(int n,String name) { if(n<=Available.available) {

System.out.println(n+" tickets booked by

"+name);
Available.available=Available.available-n; try {

Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}else {
System.out.println("Sorry Tickets not available for "+name);

}
}
}


User1.java

package p1;

public class User1 implements Runnable{ public Selection ob;

public User1(Selection ob) { this.ob=ob;

}
public void run() {
synchronized(ob) {
ob.select(1, "Alex");
}
}
}


User2.java

package p1;

public class User2 implements Runnable{ public Selection ob;

public User2(Selection ob) { this.ob=ob;

}
public void run() {
synchronized(ob) {
ob.select(1, "Raj");
}

}
}



DemoThread5.java(MainClass)

package p2;

import p1.*;
public class DemoThread5 {
public static void main(String[] args) { Selection ob = new Selection(); User1 u1 = new User1(ob);

User2 u2 = new User2(ob);

Thread t1 = new Thread(u1);

Thread t2 = new Thread(u2);

t1.start();

t2.start();

}

}


o/p:

1 tickets booked by Alex

Sorry Tickets not available for Raj




Diagram:



































-----------------------------------------------------------

Limitation of Object Locking process:

=>In Object Locking process all instance methods within the

object will be under the lock and all methods are available to

one user at-a-time and which is not preferable all the time.

-------------------------------------------------------------

(b)Synchronized method - Instance method Locking process

=>The process of declaring Instance method with synchronized

keyword is known as synchronized method.

=>These synchronized methods will be under the lock and which are

available to one user at-a-time.




Ex:

Available.java

package p1;

public class Available {
public static int available=1;
}


Selection.java

package p1;

public class Selection {
public synchronized void select(int n,String name)
{
if(n<=Available.available) {
System.out.println( n+" tickets booked by
"+name);
Available.available=Available.available-n; try {

Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}else {
System.out.println("Sorry Tickets not available for "+name);

}
}
}


User1.java

package p1;

public class User1 implements Runnable{ public Selection ob;

public User1(Selection ob) {
this.ob=ob;

}
public void run() {

ob.select(1, "Alex");

}

}


User2.java

package p1;

public class User2 implements Runnable{ public Selection ob;

public User2(Selection ob) { this.ob=ob;

}
public void run() {

ob.select(1, "Raj");

}

}


DemoThread6.java(MainClass)

package p2;

import p1.*;
public class DemoThread6 {
public static void main(String[] args) { Selection ob = new Selection(); User1 u1 = new User1(ob);

User2 u2 = new User2(ob);

Thread t1 = new Thread(u1);

Thread t2 = new Thread(u2);


t1.start();

t2.start();

}

}


------------------------------------------------------------

(c)Static synchronization - Static method Locking process

=>The process of declaring static methods with synchronized

keyword is known as static synchronization and in which the class

is under the lock and members of class are available to one user

at-a-time.




Ex:

Available.java

package p1;

public class Available {
public static int available=1;
}


Selection.java

package p1;

public class Selection {
public synchronized static void select(int n,String name) {

if(n<=Available.available) {
System.out.println(n+" tickets booked by
"+name);
Available.available=Available.available-n; try {

Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}else {

System.out.println("Sorry Tickets not available for "+name);

}
}
}


User1.java

package p1;

public class User1 implements Runnable{ public void run() {

Selection.select(1, "Alex");

}

}


User2.java

package p1;

public class User2 implements Runnable{ public void run() {

Selection.select(1, "Raj");

}

}


DemoThread7.java(MainClass)

package p2;

import p1.*;
public class DemoThread7 {
public static void main(String[] args) { User1 u1 = new User1();

User2 u2 = new User2();


Thread t1 = new Thread(u1);

Thread t2 = new Thread(u2);

t1.start();

t2.start();

}

}


===================================================

*imp

2.Thread Communication process:

=>The process of establishing Communication b/w threads using

the following methods from java.lang.Object class is known as

Thread Communication process or

Inter Thread Communication process(ITC).

(a)wait()

(b)notify()

(c)notifyAll()




(a)wait():

=>wait() method will block the thread execution temporarly until

it receives msg in the form of true or false.




(b)notify():

=>notify() method will unlock the resource and send the msg to

next waiting thread.


(c)notifyAll():

=>notifyAll() method also unlock the resource and send the msg

to all multiple waiting threads.

----------------------------------------------------

Dt : 11/7/2023

Ex-application:

(Demonstrating Producer-Consumer problem using Thread Communication

process)




Diagram:















































Ex-Application:

Producer.java

package p1;

public class Producer implements Runnable{ public StringBuffer sb = null;

public Producer() {
sb = new StringBuffer();
}
@Override
public void run() {
try {
synchronized(sb) {
for(int i=1;i<=10;i++) {
sb.append(i+" : ");
System.out.println("Producer
Appending data..."); Thread.sleep(2000);

}//end of loop
sb.notify();
//send message to next waiting thread }//end of lock

}catch(Exception e) {e.printStackTrace();}
}
}


Consumer.java

package p1;

public class Consumer implements Runnable{ public Producer prod=null;

public Consumer(Producer prod) { this.prod=prod;

}
@Override
public void run() {
try {
synchronized(prod.sb) {
System.out.println("Consumer started...but blocked..");

prod.sb.wait();
//block thread execution until it receives message

System.out.println("*****Display using Consumer****");

System.out.println(prod.sb); }//end of lock

}catch(Exception e) {e.printStackTrace();}
}
}


DemoThread8.java(MainClass)

package p2;

import p1.*;
public class DemoThread8 {
public static void main(String[] args) { Producer p = new Producer(); Consumer c = new Consumer(p);

Thread t1 = new Thread(p);

Thread t2 = new Thread(c);

t2.setPriority(Thread.MAX_PRIORITY);

t1.setPriority(Thread.MIN_PRIORITY);

t2.start();

t1.start();
}
}


o/p:

Consumer started...but blocked..

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

*****Display using Consumer****

1:2:3:4:5:6:7:8:9:10:




Execution flow of above program:



































==============================================================

*imp

Thread Life-Cycle:

=>Thread Life-Cycle demonstrates different states of thread from

Thread-Creation to Thread-Completion and Thread-Creation to

Thread-Termination

=>The following are different states of thread:

1.Thread Creation(New Thread)

2.Ready-to-run

3.Running(Executing thread)

(i)Thread Completion

(ii)Thread Blocked State

=>DeadLock




Diagram:





































===============================================================

Dt : 12/7/2023

1.Thread Creation(New Thread)

=>The process of creating new thread using start() method is known as

Thread-Creation process.


2.Ready-to-run:

=>The state of thread where thread is waiting for execution.




3.Running(Executing thread):

=>The state in which the thread is executing is known as Running State.




(i)Thread Completion:

=>The state in which the thread executed successfully and generated

result is known as Thread Completion.




(ii)Thread Blocked State:

=>The state in which the thread execution blocked temporarly is known

as Thread Blocked State or Thread Live-Lock

=>The thread will be under blocked state if any one of the following

event is raised:

(a)wait() -method will block the thread execution until it receives msg

(b)sleep()-method will block the thread execution based on time

(c)Blocked on IO - The thread execution is blocked for incomplete

IO operation

(d)Block to Join - In thread dependencies,some threads will for another

to complete is known as "Blocked to Join"

(e)Block to Lock - The thread execution is blocked for incomplete

locking operation.




Note:

=>If the raised events are completed from Blocked State then the threads

will join ready-to-run state




faq:

wt is the diff b/w

(i)wait()

(ii)sleep()

=>wait() will block the thread execution until it receives msg,but sleep()

will block the thread executed on some time.

=>wait() will release the locks on the resources,but sleep() will not release

the locks on the resources.

----------------------------------------------------------------

faq:

define DeadLock?

=>The permanent blockage of thread is known as Thread DeadLock

Note:

=>If any raised event occurs permanently then thread is under DeadLock

===================================================================

=

faq:

How can we know the thread is under LiveLock or DeadLock?

=>We use isAlive() method to check the thread is under LiveLock or DeadLock.

syntax:

boolean k = t1.isAlive();




faq:

Can we distrub the thread which is in wait() or sleep() state?

=>we use interrupt() method to dustrub the thread which is in wait() or

sleep() state.

syntax:

t1.interrupt();




faq:

define daemon thread?

=>The thread which executes contineously is known as daemon thread

=>All server service threads are daemon threads.

syntax:

t1.setDaemon(true);

Note:

=>isDaemon() method is used to check the thread is daemon thread or not




faq:

define join() method?

=>join() method will specify to complete the current thread and executed

reamining threads




Ex:

package maccess;

public class DemoThread9 {

public static void main(String[] args) {

Thread t1 = new Thread(()->

{

for(int i=1;i<=5;i++)

{

System.out.println("Task-1");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}


});


Thread t2 = new Thread(()->

{

for(int i=1;i<=5;i++)

{

System.out.println("Task-2");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}

});




Thread t3 = new Thread(()->

{

for(int i=1;i<=5;i++)

{

System.out.println("Task-3");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}

});

t1.start();

try {

t1.join();

}catch(Exception e) {e.printStackTrace();}

t2.start();

t3.start();

}

}

--------------------------------------------------

define yield() method?

=>yield() method will specify to stop the current thread and go for the

next thread for execution.

=========================================================

Application of Threads:

(i)Threads are used in Gaming Applications

(ii)Threads are used in Server development

(iii)Threads are used in Server Application development

===========================================================

*imp

IO Streams and Files:





define stream?

=>The contineous flow of data is known as Stream




Types of streams:

=>Streams in Java are categorized into two types:

1.Byte Stream

2.Character Stream




1.Byte Stream:

=>The contineous flow of data in the form of 8-bits is known as

Byte Stream or Binary Stream

=>Byte Stream supports all multimedia data formats like Text,Audio,Video,

Image and Animation




2.Character Stream:

=>The contineous flow of data in the form of 16-bits is known as Character

Stream

=>Character Stream is preferable for Text data and not preferable for

Audio,Video,Image and Animation data

----------------------------------------------------------------

define File Storage?

=>The smallest permanent storage of ComputerSystem which is controlled and

managed by the OperatingSystem is known as File Storage.

=>In the process of establishing Communication b/w JavaProgram and

File Storage,the Java program must be constructed using classes and Interfaces

available from java.io package.




Diagram:

-------------------------------------------------------------------

Dt : 13/7/2023

=>The following are some important classes related to Byte Stream or

Binary Stream:

1.FileInputStream

2.FileOutputStream

3.DataInputStream

4.DataOutputStream




1.FileInputStream:

=>FileInputStream class is from java.io package and which is used to

find the file and opens the file to read binarystream data.

syntax:

FileInputStream fis = new FileInputStream(fPath&fName);





2.FileOutputStream:

=>FileOutputStream class is from java.io package and which is used to

create a new file and opens the file to write binarystream data.

syntax:

FileOutputStream fos = new FileOutputStream("fPath&fName");




3.DataInputStream:

=>DataInputStream class is from java.io package and which is used to

read binarystream data into JavaProgram.

syntax:

DataInputStream dis = new DataInputStream(Source);




4.DataOutputStream:

=>DataOutputStream class is from java.io package and which is used to

send binarystream data outof JavaProgram.

syntax:

DataOutputStream dos = new DataOutputStream(Destination);

------------------------------------------------------------------

Ex-Program:

wap to copy the file from one location to another location?





DemoFile1.java(MainClass)

package maccess;

import java.util.*;

import java.io.*;

public class DemoFile1 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter the fPath&fName(Source)");

File f1 = new File(s.nextLine());

if(f1.exists()) {

FileInputStream fis = new FileInputStream(f1);

System.out.println("Enter the fPath&fName(Destination)");

File f2 = new File(s.nextLine());

FileOutputStream fos = new FileOutputStream(f2);

int k;

while((k=fis.read())!=-1) {

fos.write(k);

}

System.out.println("File Stored Successfully...");

fos.close();

fis.close();

}else {


System.out.println("Invalud file...");

}

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter the fPath&fName(Source)

C:\Images\IMG_4917.JPG

Enter the fPath&fName(Destination)

D:\Images\xyz.jpg

File Stored Successfully...




Diagram:

==============================================================

*imp

Object State onto File Storage:

=>When we want to store Object State onto file storage,then the object

must be available in the form of Stream(Binary Stream).





define Serialization process?

=>The process of converting Object state into binary stream is known as

Serialization process.

=>we use writeObject() method from java.io.ObjectOutputStream class to

perform Serialization process

syntax:

ObjectOutputStream oos = new ObjectOutputStream(fos);

oos.writeObject(objt_ref);




define De-Serialization process?

=>The process of converting binary Stream into Object-state is known as

De-Serialization process.

=>we use readObject() method from java.io.ObjectInputStream class to

perform De-Serialization process

syntax:

ObjectInputStream ois = new ObjectInputStream(fis);

Object ob = ois.readObject();




Note:

=>To perform Serialization and De-Serialization processes,the class must

be implemented from "java.io.Serializable" interface.

=>"Serializable" is a marker interface and which specify Serialization and

De-Serialization.

--------------------------------------------------------------------

Ex-Application:

UserRegistration.java

package test;

import java.util.*;

import java.io.*;

@SuppressWarnings("serial")

public class UserRegistration extends Object implements

Serializable{

public String uName,pWord,name,mId;

public long phNo;

public Date dateTime;

public UserRegistration(String uName,String pWord,String name,

String mId,long phNo,Date dateTime) {

this.uName=uName;

this.pWord=pWord;

this.name=name;

this.mId=mId;

this.phNo=phNo;

this.dateTime=dateTime;

}

@Override

public String toString() {


return "UserName:"+uName+"\nPassWord:"+pWord

+"\nName:"+name+"\nMailId:"+mId

+"\nPhoneNo:"+phNo+"\nDataTime:"+dateTime;

}

}

DemoFile2.java(Serialization-MainClass)

package maccess;

import java.util.*;

import test.*;

import java.io.*;

public class DemoFile2 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter the UserName:");

String uN = s.nextLine();

System.out.println("Enter the PassWord:");

String pW = s.nextLine();

System.out.println("Enter the Name:");

String name = s.nextLine();

System.out.println("Enter the MailId:");

String mId = s.nextLine();

System.out.println("Enter the PhoneNo:");

long phNo = s.nextLong();

UserRegistration ob1 =

new UserRegistration(uN,pW,name,mId,phNo,new Date());

File f = new File("D:\\Images\\Obj.txt");

FileOutputStream fos = new FileOutputStream(f);

ObjectOutputStream oos = new ObjectOutputStream(fos);

oos.writeObject(ob1);

System.out.println("Object Stored Successfully...");

oos.close();

}catch(Exception e) {e.printStackTrace();}

}

}

}

o/p:

Enter the UserName:

raj

Enter the PassWord:

raj

Enter the Name:

Raj Kumar

Enter the MailId:

raj@gmail.com

Enter the PhoneNo:

98989812345

Object Stored Successfully...

=============================================================

DT : 17/7/2023

DemoFile3.java(DeSerialization-MainClass)

package maccess;

import test.*;

import java.io.*;

public class DemoFile3 {

public static void main(String[] args) {

try {

File f = new File("D:\\Images\\Obj.txt");

FileInputStream fis = new FileInputStream(f);

ObjectInputStream ois = new ObjectInputStream(fis);

UserRegistration ob2 = (UserRegistration)ois.readObject();

System.out.println("****UserDetails****");

System.out.println(ob2.toString());

ois.close();

}catch(Exception e) {e.printStackTrace();}

}

}

o/p:

****UserDetails****

UserName:Alex

PassWord:mzu672

Name:Alex

MailId:a@gmail.com

PhoneNo:9898981234

DataTime:Mon Jul 17 20:02:55 IST 2023

===========================================================

Diagram:

============================================================

faq:

wt is the advantage of Serialization process?

=>Through Serialization process we can make Objects available in the form

of stream and can move on the network from one location to another

location.

===============================================================

=>Based on Serialization process the objects in Java are categorized into

two types:

(i)Serializable Objects

(ii)Non-Serializable Objects


(i)Serializable Objects:

=>The objects which are generated from the classes which are implemented

from "Serializable" interface are known as Serializable Objects.




(ii)Non-Serializable Objects:

=>The Objects which are generated from the classes which are not implemented

from "Serializable" interface are known as Non-Serializable Objects

===================================================================

CoreJava Objects:

1.User defined class Objects - Serializable

2.String Objects	- Serializable

3.WrapperClass Objects	- Serializable

4.Array Objects	- Serializable

5.Collection<E> Objects	- Serializable

6.Map<K,V> Objects	- Serializable

7.Enum<E> Objects	- Serializable

===================================================================

=====

=>The following are some important classes related to Character Stream or

Text Stream:

1.FileReader

2.FileWriter

3.BufferedReader




1.FileReader:

=>FileReader class is from java.io package and which is used to find the

file and opens the file to read Character Stream data.

syntax:

FileReader fr = new FileReader("fPath&fName");




2.FileWriter:

=>FileWriter class is from java.io package and which is used to create a

new file and opens the file to write Character Stream data.

syntax:

FileWriter fw = new FileWriter("fpath&fName");




3.BufferedReader:

=>BufferedReader class is from java.io package and which is used to read

character stream into JavaProgram.

syntax:

BufferedReader br = new BufferedReader(new InputStreamReader(Source));





Ex-program:

wap to read data from console and store the data to file?




DemoFile4.java

package maccess;

import java.io.*;
public class DemoFile4 {
public static void main(String[] args) { try {

BufferedReader br = new BufferedReader
(new InputStreamReader(System.in)); File f = new File("D:\\Images\\Text.txt"); FileWriter fw = new FileWriter(f); System.out.println("Enter the data(@ at

end):");
char ch1;
while((ch1=(char)br.read())!='@')
{
fw.write(ch1);
}
System.out.println("data stored to file successfully...");

fw.close();
br.close();

System.out.println("========================="); System.out.println("data from file....");

FileReader fr = new FileReader(f);
int k;
while((k=fr.read())!=-1)
{
System.out.print((char)k);
}
fr.close();
}catch(Exception e) {e.printStackTrace();}
}

}

o/p:

Enter the data(@ at end):

java is simpl

java is sec

tasking

threading

@

data stored to file successfully...

=========================

data from file....

java is simpl

java is sec

tasking

threading

===============================================================

faq:

define File class?

=>"File" class is from java.io package and which is used to find the

properties of file like file_length,file_path,file_exists or not,...

syntax:

File f = new File(fPath&fName);

================================================================

7/21/23, 11:21 AM	FileStoray.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
7/21/23, 11:21 AM	File2.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 18/7/2023

*imp

Networking in Java:(Socket programming in Java)




define Computer N/W?

=>The inter connection of autonomous computers is known as

Computer N/W.

=>Based on number of nodes in the N/W,the N/Ws are categorized in

to the following:

(1)LAN - Local Area N/W

(2)MAN - Metropolitan Area N/W

(3)WAN - Wide Area N/W

(4)WWW - World Wide Web

define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.

-------------------------------------------------------

=>The Computers in the N/w are categorized into two types:

(1)Server Computers

(2)Client Computers





(1)Server Computers:

=>The computers which are holding Server Applications are

known as Server Computers.

=>These Server Computers will accept the request and generate

response.

(2)Client Computers:

=>The computers which are holding client applications are

known as Client Computers

=>These Client Computers will generate request to Servers.




Diagrams:





































-----------------------------------------------------------

define N/W protocol?:

=>The set-of-rules used by computers in the N/W is known as

N/W protocol.

=>These N/w protocols are categorized into two types:

(1)Connection oriented protocols

(2)Connection less Protocols




(1)Connection oriented protocols:

=>In Connection Oriented Protocols the Sender will receive

ack from Receiver.

Ex:

TCP/IP

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive

ack from Receiver.

Ex:

UDP

-------------------------------------------------------

define IP Address?

=>The Unique identification number used by computer in the

N/W is known as IP Address.

=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified


into the following:

class A - 1.0.0.0 to 126.255.255.254

class B - 128.1.0.1 to 191.255.255.254 (65000)

class C - 192.0.1.1 to 223.255.254.254 (254)

class D - 224.0.0.0 to 239.255.255.255(multicast)

class E - 240.0.0.0 to 254.255.255.255(future)

note:

127.0.0.0 loopback network

255.255.255.255 - default network





(16 million)


============================================================

IPv4 Address. . . . . . . . . . . : 192.168.1.162

Subnet Mask . . . . . . . . . . . : 255.255.255.0

Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================

*imp

define Socket?

=>The logical connection established for communication is

known as Socket.

=>we use port number for Socket Connection.

Ex:

portNo : 0 to 65535


The following are the reserved port numbers:

13 - date and time services

21 - FTP which transfers files

23 - Telnet,which provides remote login

25 - SMTP,which delivers mails

- HTTP,which transfers web pages

- POP,which access mail boxes

------------------------------------------------------------

The following are the some network classes from "java.net" package:

(1)Socket,ServerSocket - used for TCP/IP connection

(2)DatagramPacket,DatagramSocket - used for UDP connection

(3)URL,URIConnection - used for read-write data from the

internet

(4)InetAddress - this class is used to get the

IP Address and hostname of the computer.




Note:

The communication b/w two Java Appls running on two diff JVMs

can be established using 'Socket' and 'ServerSocket' classes.

=>The JVMs can be in same ComputerSystem or different

ComputerSystems.


(1)Socket,ServerSocket Classes:

methods of Socket class:

InputStream getInputStream()

OutputStream getOutputStream()

synchronized void close()




methods of ServerSocket class:

Socket accept()

synchronized void close()

----------------------------------------------------------------

Diagram:




===============================================================




Program : Server.java

import java.io.*;

import java.net.*;

class Server

{

public static void main(String args[])

throws IOException

{

ServerSocket ss=new ServerSocket(888);

Socket s=ss.accept();

System.out.println("connection established");

PrintStream ps=new PrintStream

(s.getOutputStream());

DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=

new DataInputStream(System.in);

while(true)

{

String str,str1;

while((str=br.readLine())!=null)

{

System.out.println(str);

str1=kb.readLine();

ps.println(str1);

}

ps.close();

br.close();

kb.close();

ss.close();

s.close();

System.exit(0);

}

}

}

==============================================================

Program : Client.java

import java.io.*;

import java.net.*;

class Client

{

public static void main(String args[])

throws IOException

{

Socket s=new Socket("localhost",888);

DataOutputStream dos=new DataOutputStream

(s.getOutputStream());

DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=new DataInputStream

(System.in);

String str,str1;

while(!(str=kb.readLine()).equals("exit"))

{

dos.writeBytes(str+"\n");

str1=br.readLine();

System.out.println(str1);

}

dos.close();

br.close();

kb.close();

s.close();

}

}

==========================================================

Note:

=>Execute above two programs in two differnt CommandPrompts.

========================================================

Summary:

1.Socket Programming

2.RPC/RMI

3.CORBA

4.WebServices













































=============================================================

*imp

"java.lang.Object" class:

=>"java.lang.Object" class is the ParentClass of all the classes declared

in the application

=>The following are some important methods of Object Class:

1.hashCode()

2.toString()

3.clone()

4.equals()

5.wait()

6.notify()

7.notifyAll()

8.getClass()

9.finalize()
7/21/23, 11:22 AM	File3.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 18/7/2023

*imp

Networking in Java:(Socket programming in Java)




define Computer N/W?

=>The inter connection of autonomous computers is known as

Computer N/W.

=>Based on number of nodes in the N/W,the N/Ws are categorized in

to the following:

(1)LAN - Local Area N/W

(2)MAN - Metropolitan Area N/W

(3)WAN - Wide Area N/W

(4)WWW - World Wide Web

define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.

-------------------------------------------------------

=>The Computers in the N/w are categorized into two types:

(1)Server Computers

(2)Client Computers





(1)Server Computers:

=>The computers which are holding Server Applications are

known as Server Computers.

=>These Server Computers will accept the request and generate

response.

(2)Client Computers:

=>The computers which are holding client applications are

known as Client Computers

=>These Client Computers will generate request to Servers.




Diagrams:





































-----------------------------------------------------------

define N/W protocol?:

=>The set-of-rules used by computers in the N/W is known as

N/W protocol.

=>These N/w protocols are categorized into two types:

(1)Connection oriented protocols

(2)Connection less Protocols




(1)Connection oriented protocols:

=>In Connection Oriented Protocols the Sender will receive

ack from Receiver.

Ex:

TCP/IP

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive

ack from Receiver.

Ex:

UDP

-------------------------------------------------------

define IP Address?

=>The Unique identification number used by computer in the

N/W is known as IP Address.

=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified


into the following:

class A - 1.0.0.0 to 126.255.255.254

class B - 128.1.0.1 to 191.255.255.254 (65000)

class C - 192.0.1.1 to 223.255.254.254 (254)

class D - 224.0.0.0 to 239.255.255.255(multicast)

class E - 240.0.0.0 to 254.255.255.255(future)

note:

127.0.0.0 loopback network

255.255.255.255 - default network





(16 million)


============================================================

IPv4 Address. . . . . . . . . . . : 192.168.1.162

Subnet Mask . . . . . . . . . . . : 255.255.255.0

Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================

*imp

define Socket?

=>The logical connection established for communication is

known as Socket.

=>we use port number for Socket Connection.

Ex:

portNo : 0 to 65535


The following are the reserved port numbers:

13 - date and time services

21 - FTP which transfers files

23 - Telnet,which provides remote login

25 - SMTP,which delivers mails

- HTTP,which transfers web pages

- POP,which access mail boxes

------------------------------------------------------------

The following are the some network classes from "java.net" package:

(1)Socket,ServerSocket - used for TCP/IP connection

(2)DatagramPacket,DatagramSocket - used for UDP connection

(3)URL,URIConnection - used for read-write data from the

internet

(4)InetAddress - this class is used to get the

IP Address and hostname of the computer.




Note:

The communication b/w two Java Appls running on two diff JVMs

can be established using 'Socket' and 'ServerSocket' classes.

=>The JVMs can be in same ComputerSystem or different

ComputerSystems.


(1)Socket,ServerSocket Classes:

methods of Socket class:

InputStream getInputStream()

OutputStream getOutputStream()

synchronized void close()




methods of ServerSocket class:

Socket accept()

synchronized void close()

----------------------------------------------------------------

Diagram:




===============================================================




Program : Server.java

import java.io.*;

import java.net.*;

class Server

{

public static void main(String args[])

throws IOException

{

ServerSocket ss=new ServerSocket(888);

Socket s=ss.accept();

System.out.println("connection established");

PrintStream ps=new PrintStream

(s.getOutputStream());

DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=

new DataInputStream(System.in);

while(true)

{

String str,str1;

while((str=br.readLine())!=null)

{

System.out.println(str);

str1=kb.readLine();

ps.println(str1);

}

ps.close();

br.close();

kb.close();

ss.close();

s.close();

System.exit(0);

}

}

}

==============================================================

Program : Client.java

import java.io.*;

import java.net.*;

class Client

{

public static void main(String args[])

throws IOException

{

Socket s=new Socket("localhost",888);

DataOutputStream dos=new DataOutputStream

(s.getOutputStream());

DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=new DataInputStream

(System.in);

String str,str1;

while(!(str=kb.readLine()).equals("exit"))

{

dos.writeBytes(str+"\n");

str1=br.readLine();

System.out.println(str1);

}

dos.close();

br.close();

kb.close();

s.close();

}

}

==========================================================

Note:

=>Execute above two programs in two differnt CommandPrompts.

========================================================

Summary:

1.Socket Programming

2.RPC/RMI

3.CORBA

4.WebServices













































=============================================================

*imp

"java.lang.Object" class:

=>"java.lang.Object" class is the ParentClass of all the classes declared

in the application

=>The following are some important methods of Object Class:

1.hashCode()

2.toString()

3.clone()

4.equals()

5.wait()

6.notify()

7.notifyAll()

8.getClass()

9.finalize()

Dt : 11/7/2023

Ex-application:

(Demonstrating Producer-Consumer problem using Thread Communication process)


Diagram:















































Ex-Application:

Producer.java

package p1;

public class Producer implements Runnable{ public StringBuffer sb = null;

public Producer() {
sb = new StringBuffer();
}
@Override
public void run() {
try {
synchronized(sb) {
for(int i=1;i<=10;i++) {
sb.append(i+" : ");
System.out.println("Producer
Appending data..."); Thread.sleep(2000);

}//end of loop
sb.notify();
//send message to next waiting thread }//end of lock

}catch(Exception e) {e.printStackTrace();}
}
}


Consumer.java

package p1;

public class Consumer implements Runnable{ public Producer prod=null;

public Consumer(Producer prod) { this.prod=prod;

}
@Override
public void run() {
try {
synchronized(prod.sb) {
System.out.println("Consumer started...but blocked..");

prod.sb.wait();
//block thread execution until it receives message

System.out.println("*****Display using Consumer****");

System.out.println(prod.sb); }//end of lock

}catch(Exception e) {e.printStackTrace();}
}
}


DemoThread8.java(MainClass)

package p2;

import p1.*;
public class DemoThread8 {
public static void main(String[] args) { Producer p = new Producer(); Consumer c = new Consumer(p);

Thread t1 = new Thread( p);

Thread t2 = new Thread( c);

t2.setPriority(Thread.MAX_PRIORITY);

t1.setPriority(Thread.MIN_PRIORITY);

t2.start();

t1.start();
}
}


o/p:

Consumer started...but blocked..

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

Producer Appending data...

*****Display using Consumer****

1:2:3:4:5:6:7:8:9:10:




Execution flow of above program:



































==============================================================

*imp

Thread Life-Cycle:

=>Thread Life-Cycle demonstrates different states of thread from Thread-Creation to Thread-Completion and Thread-Creation to Thread-Termination

=>The following are different states of thread:

1.Thread Creation(New Thread)

2.Ready-to-run

3.Running(Executing thread)

(i)Thread Completion

(ii)Thread Blocked State

=>DeadLock




Diagram:





































===============================================================

Dt : 12/7/2023

1.Thread Creation(New Thread)

=>The process of creating new thread using start() method is known as Thread-Creation process.


2.Ready-to-run:

=>The state of thread where thread is waiting for execution.




3.Running(Executing thread):

=>The state in which the thread is executing is known as Running State.




(i)Thread Completion:

=>The state in which the thread executed successfully and generated result is known as Thread Completion.


(ii)Thread Blocked State:

=>The state in which the thread execution blocked temporarly is known as Thread Blocked State or Thread Live-Lock

=>The thread will be under blocked state if any one of the following event is raised:

(a)wait() -method will block the thread execution until it receives msg (b)sleep()-method will block the thread execution based on time (c)Blocked on IO - The thread execution is blocked for incomplete

IO operation

(d)Block to Join - In thread dependencies,some threads will for another to complete is known as "Blocked to Join"

(e)Block to Lock - The thread execution is blocked for incomplete locking operation.


Note:

=>If the raised events are completed from Blocked State then the threads will join ready-to-run state


faq:

wt is the diff b/w

(i)wait()

(ii)sleep()

=>wait() will block the thread execution until it receives msg,but sleep() will block the thread executed on some time.

=>wait() will release the locks on the resources,but sleep() will not release the locks on the resources.

----------------------------------------------------------------

faq:

define DeadLock?

=>The permanent blockage of thread is known as Thread DeadLock Note:

=>If any raised event occurs permanently then thread is under DeadLock

=================================================================== =



faq:

How can we know the thread is under LiveLock or DeadLock?

=>We use isAlive() method to check the thread is under LiveLock or DeadLock.

syntax:

boolean k = t1.isAlive();




faq:

Can we distrub the thread which is in wait() or sleep() state?

=>we use interrupt() method to dustrub the thread which is in wait() or

sleep() state.

syntax:

t1.interrupt();




faq:

define daemon thread?

=>The thread which executes contineously is known as daemon thread =>All server service threads are daemon threads.

syntax:

t1.setDaemon(true);

Note:

=>isDaemon() method is used to check the thread is daemon thread or not




faq:

define join() method?

=>join() method will specify to complete the current thread and executed reamining threads


Ex:

package maccess;

public class DemoThread9 {

public static void main(String[] args) { Thread t1 = new Thread(()-> {


for(int i=1;i<=5;i++)

{

System.out.println("Task-1");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}


});


Thread t2 = new Thread(()->

{

for(int i=1;i<=5;i++)

{

System.out.println("Task-2");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}

});




Thread t3 = new Thread(()->

{

for(int i=1;i<=5;i++)

{

System.out.println("Task-3");

try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}

}

});

t1.start();

try {

t1.join();

}catch(Exception e) {e.printStackTrace();}

t2.start();

t3.start();

}

}

--------------------------------------------------

define yield() method?

=>yield() method will specify to stop the current thread and go for the

next thread for execution.

=========================================================

Application of Threads:

(i)Threads are used in Gaming Applications (ii)Threads are used in Server development (iii)Threads are used in Server Application development

===========================================================

*imp

IO Streams and Files:





define stream?

=>The contineous flow of data is known as Stream




Types of streams:

=>Streams in Java are categorized into two types:

1.Byte Stream

2.Character Stream




1.Byte Stream:

=>The contineous flow of data in the form of 8-bits is known as Byte Stream or Binary Stream

=>Byte Stream supports all multimedia data formats like Text,Audio,Video, Image and Animation


2.Character Stream:

=>The contineous flow of data in the form of 16-bits is known as Character Stream

=>Character Stream is preferable for Text data and not preferable for Audio,Video,Image and Animation data

----------------------------------------------------------------

define File Storage?

=>The smallest permanent storage of ComputerSystem which is controlled and managed by the OperatingSystem is known as File Storage.

=>In the process of establishing Communication b/w JavaProgram and

File Storage,the Java program must be constructed using classes and Interfaces available from java.io package.


Diagram:

-------------------------------------------------------------------

Dt : 13/7/2023

=>The following are some important classes related to Byte Stream or

Binary Stream:

1.FileInputStream

2.FileOutputStream

3.DataInputStream

4.DataOutputStream




1.FileInputStream:

=>FileInputStream class is from java.io package and which is used to find the file and opens the file to read binarystream data. syntax:


FileInputStream fis = new FileInputStream(fPath&fName);





2.FileOutputStream:

=>FileOutputStream class is from java.io package and which is used to

create a new file and opens the file to write binarystream data.

syntax:

FileOutputStream fos = new FileOutputStream("fPath&fName");




3.DataInputStream:

=>DataInputStream class is from java.io package and which is used to read binarystream data into JavaProgram. syntax:


DataInputStream dis = new DataInputStream(Source);




4.DataOutputStream:

=>DataOutputStream class is from java.io package and which is used to send binarystream data outof JavaProgram. syntax:


DataOutputStream dos = new DataOutputStream(Destination);

------------------------------------------------------------------

Ex-Program:

wap to copy the file from one location to another location?





DemoFile1.java(MainClass)

package maccess;

import java.util.*;

import java.io.*;

public class DemoFile1 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter the fPath&fName(Source)"); File f1 = new File(s.nextLine()); if(f1.exists()) {


FileInputStream fis = new FileInputStream(f1); System.out.println("Enter the fPath&fName(Destination)"); File f2 = new File(s.nextLine());

FileOutputStream fos = new FileOutputStream(f2);

int k;

while((k=fis.read())!=-1) {

fos.write(k);

}

System.out.println("File Stored Successfully...");

fos.close();

fis.close();

}else {


System.out.println("Invalud file...");

}

}catch(Exception e) {e.printStackTrace();} }//end of try with resource

}

}

o/p:

Enter the fPath&fName(Source)

C:\Images\IMG_4917.JPG

Enter the fPath&fName(Destination)

D:\Images\xyz.jpg

File Stored Successfully...




Diagram:

==============================================================

*imp

Object State onto File Storage:

=>When we want to store Object State onto file storage,then the object must be available in the form of Stream(Binary Stream).



define Serialization process?

=>The process of converting Object state into binary stream is known as Serialization process.

=>we use writeObject() method from java.io.ObjectOutputStream class to

perform Serialization process

syntax:

ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(objt_ref);


define De-Serialization process?

=>The process of converting binary Stream into Object-state is known as De-Serialization process.

=>we use readObject() method from java.io.ObjectInputStream class to

perform De-Serialization process

syntax:

ObjectInputStream ois = new ObjectInputStream(fis); Object ob = ois.readObject();


Note:

=>To perform Serialization and De-Serialization processes,the class must be implemented from "java.io.Serializable" interface.

=>"Serializable" is a marker interface and which specify Serialization and De-Serialization.

--------------------------------------------------------------------

Ex-Application:

UserRegistration.java

package test;

import java.util.*;

import java.io.*;

@SuppressWarnings("serial")

public class UserRegistration extends Object implements Serializable{

public String uName,pWord,name,mId;

public long phNo;

public Date dateTime;

public UserRegistration(String uName,String pWord,String name, String mId,long phNo,Date dateTime) {

this.uName=uName;

this.pWord=pWord;

this.name=name;

this.mId=mId;

this.phNo=phNo;

this.dateTime=dateTime;

}

@Override

public String toString() {


return "UserName:"+uName+"\nPassWord:"+pWord

+"\nName:"+name+"\nMailId:"+mId

+"\nPhoneNo:"+phNo+"\nDataTime:"+dateTime;

}

}

DemoFile2.java(Serialization-MainClass)

package maccess;

import java.util.*;

import test.*;

import java.io.*;

public class DemoFile2 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

try(s;){

try {

System.out.println("Enter the UserName:");

String uN = s.nextLine();

System.out.println("Enter the PassWord:");

String pW = s.nextLine();

System.out.println("Enter the Name:");

String name = s.nextLine();

System.out.println("Enter the MailId:");

String mId = s.nextLine();

System.out.println("Enter the PhoneNo:"); long phNo = s.nextLong(); UserRegistration ob1 =

new UserRegistration(uN,pW,name,mId,phNo,new Date()); File f = new File("D:\\Images\\Obj.txt"); FileOutputStream fos = new FileOutputStream(f); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(ob1);


System.out.println("Object Stored Successfully..."); oos.close();

}catch(Exception e) {e.printStackTrace();}

}

}

}

o/p:

Enter the UserName:

raj

Enter the PassWord:

raj

Enter the Name:

Raj Kumar

Enter the MailId:

raj@gmail.com

Enter the PhoneNo:

98989812345

Object Stored Successfully...

=============================================================

DT : 17/7/2023

DemoFile3.java(DeSerialization-MainClass)

package maccess;

import test.*;

import java.io.*;

public class DemoFile3 {

public static void main(String[] args) {

try {

File f = new File("D:\\Images\\Obj.txt"); FileInputStream fis = new FileInputStream(f); ObjectInputStream ois = new ObjectInputStream(fis); UserRegistration ob2 = (UserRegistration)ois.readObject(); System.out.println("****UserDetails****"); System.out.println(ob2.toString()); ois.close();


}catch(Exception e) {e.printStackTrace();}

}

}

o/p:

****UserDetails****

UserName:Alex

PassWord:mzu672

Name:Alex

MailId:a@gmail.com

PhoneNo:9898981234

DataTime:Mon Jul 17 20:02:55 IST 2023

===========================================================

Diagram:

============================================================

faq:

wt is the advantage of Serialization process?

=>Through Serialization process we can make Objects available in the form of stream and can move on the network from one location to another location.

===============================================================

=>Based on Serialization process the objects in Java are categorized into two types:

(i)Serializable Objects

(ii)Non-Serializable Objects


(i)Serializable Objects:

=>The objects which are generated from the classes which are implemented from "Serializable" interface are known as Serializable Objects.


(ii)Non-Serializable Objects:

=>The Objects which are generated from the classes which are not implemented

from "Serializable" interface are known as Non-Serializable Objects

===================================================================

CoreJava Objects:

1.User defined class Objects - Serializable

2.String Objects	- Serializable

3.WrapperClass Objects	- Serializable

4.Array Objects	- Serializable

5.Collection<E> Objects	- Serializable

6.Map<K,V> Objects	- Serializable

7.Enum<E> Objects	- Serializable

=================================================================== =====

=>The following are some important classes related to Character Stream or

Text Stream:

1.FileReader

2.FileWriter

3.BufferedReader




1.FileReader:

=>FileReader class is from java.io package and which is used to find the file and opens the file to read Character Stream data. syntax:


FileReader fr = new FileReader("fPath&fName");




2.FileWriter:

=>FileWriter class is from java.io package and which is used to create a new file and opens the file to write Character Stream data. syntax:


FileWriter fw = new FileWriter("fpath&fName");




3.BufferedReader:

=>BufferedReader class is from java.io package and which is used to read

character stream into JavaProgram.

syntax:

BufferedReader br = new BufferedReader(new InputStreamReader(Source));





Ex-program:

wap to read data from console and store the data to file?




DemoFile4.java

package maccess;

import java.io.*;
public class DemoFile4 {
public static void main(String[] args) { try {

BufferedReader br = new BufferedReader
(new InputStreamReader(System.in)); File f = new File("D:\\Images\\Text.txt"); FileWriter fw = new FileWriter(f); System.out.println("Enter the data(@ at

end):");
char ch1;
while((ch1=(char)br .read())!='@')
{
fw.write(ch1);
}
System.out.println("data stored to file successfully...");

fw.close();
br.close();

System.out.println("========================="); System.out.println("data from file....");

FileReader fr = new FileReader(f);
int k;
while((k=fr.read())!=-1)
{
System.out.print((char)k);
}
fr.close();
}catch(Exception e) {e.printStackTrace();}
}

}

o/p:

Enter the data(@ at end):

java is simpl

java is sec

tasking

threading

@

data stored to file successfully...

=========================

data from file....

java is simpl

java is sec

tasking

threading

===============================================================

faq:

define File class?

=>"File" class is from java.io package and which is used to find the

properties of file like file_length,file_path,file_exists or not,...

syntax:

File f = new File(fPath&fName);

================================================================

7/21/23, 11:21 AM	FileStoray.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
7/21/23, 11:22 AM	File3.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
7/21/23, 11:21 AM	File2.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1
7/21/23, 11:22 AM	File3.png












































































https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all	1/1

Dt : 18/7/2023

*imp

Networking in Java:(Socket programming in Java)




define Computer N/W?

=>The inter connection of autonomous computers is known as Computer N/W.

=>Based on number of nodes in the N/W,the N/Ws are categorized in to the following:

(1)LAN - Local Area N/W

(2)MAN - Metropolitan Area N/W

(3)WAN - Wide Area N/W

(4)WWW - World Wide Web

define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.

-------------------------------------------------------

=>The Computers in the N/w are categorized into two types:

(1)Server Computers

(2)Client Computers





(1)Server Computers:

=>The computers which are holding Server Applications are

known as Server Computers.

=>These Server Computers will accept the request and generate response.

(2)Client Computers:

=>The computers which are holding client applications are known as Client Computers

=>These Client Computers will generate request to Servers.




Diagrams:





































-----------------------------------------------------------

define N/W protocol?:

=>The set-of-rules used by computers in the N/W is known as N/W protocol.

=>These N/w protocols are categorized into two types:

(1)Connection oriented protocols

(2)Connection less Protocols




(1)Connection oriented protocols:

=>In Connection Oriented Protocols the Sender will receive ack from Receiver.

Ex:

TCP/IP

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive ack from Receiver.

Ex:

UDP

-------------------------------------------------------

define IP Address?

=>The Unique identification number used by computer in the N/W is known as IP Address.

=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified


into the following:

class A - 1.0.0.0 to 126.255.255.254

class B - 128.1.0.1 to 191.255.255.254 (65000)

class C - 192.0.1.1 to 223.255.254.254 (254)

class D - 224.0.0.0 to 239.255.255.255(multicast)

class E - 240.0.0.0 to 254.255.255.255(future)

note:

127.0.0.0 loopback network

255.255.255.255 - default network





(16 million)


============================================================

IPv4 Address. . . . . . . . . . . : 192.168.1.162

Subnet Mask . . . . . . . . . . . : 255.255.255.0

Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================

*imp

define Socket?

=>The logical connection established for communication is known as Socket.

=>we use port number for Socket Connection.

Ex:

portNo : 0 to 65535


The following are the reserved port numbers:

13 - date and time services

21 - FTP which transfers files

23 - Telnet,which provides remote login

25 - SMTP,which delivers mails

- HTTP,which transfers web pages

- POP,which access mail boxes

------------------------------------------------------------

The following are the some network classes from "java.net" package:

(1)Socket,ServerSocket - used for TCP/IP connection

(2)DatagramPacket,DatagramSocket - used for UDP connection

(3)URL,URIConnection - used for read-write data from the internet

(4)InetAddress - this class is used to get the

IP Address and hostname of the computer.




Note:

The communication b/w two Java Appls running on two diff JVMs can be established using 'Socket' and 'ServerSocket' classes. =>The JVMs can be in same ComputerSystem or different ComputerSystems.


(1)Socket,ServerSocket Classes:

methods of Socket class:

InputStream getInputStream()

OutputStream getOutputStream()

synchronized void close()




methods of ServerSocket class:

Socket accept()

synchronized void close()

----------------------------------------------------------------

Diagram:




===============================================================




Program : Server.java

import java.io.*;

import java.net.*;

class Server

{

public static void main(String args[])

throws IOException

{

ServerSocket ss=new ServerSocket(888);

Socket s=ss.accept();

System.out.println("connection established");

PrintStream ps=new PrintStream

(s.getOutputStream()); DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=

new DataInputStream(System.in);

while(true)

{

String str,str1;

while((str=br.readLine())!=null)

{

System.out.println(str);

str1=kb.readLine();

ps.println(str1);

}

ps.close();

br.close();

kb.close();

ss.close();

s.close();

System.exit(0);

}

}

}

==============================================================

Program : Client.java

import java.io.*;

import java.net.*;

class Client

{

public static void main(String args[])

throws IOException

{

Socket s=new Socket("localhost",888);

DataOutputStream dos=new DataOutputStream

(s.getOutputStream()); DataInputStream br=new DataInputStream

(s.getInputStream());

DataInputStream kb=new DataInputStream

(System.in);

String str,str1;

while(!(str=kb.readLine()).equals("exit"))

{

dos.writeBytes(str+"\n");

str1=br.readLine();

System.out.println(str1);

}

dos.close();

br.close();

kb.close();

s.close();

}

}

==========================================================

Note:

=>Execute above two programs in two differnt CommandPrompts.

========================================================

Summary:

1.Socket Programming

2.RPC/RMI

3.CORBA

4.WebServices













































=============================================================

*imp

"java.lang.Object" class:

=>"java.lang.Object" class is the ParentClass of all the classes declared

in the application

=>The following are some important methods of Object Class:

1.hashCode()

2.toString()

3.clone()

4.equals()

5.wait()

6.notify()

7.notifyAll()

8.getClass()

9.finalize()

Dt : 19/7/2023

1.hashCode():

=>The unique numeric number which is generated while object creation process is known as hashCode.

=>we use hashCode() method to display the hashCode on an Object.

syntax:

int hc = obj.hashCode();




2.toString():

=>toString() method is used to display the content from the object and this method is executed automatically when we display object reference. syntax:

String dt = obj.toString();




*imp

3.clone():

=>The process of creating the duplicate copy of an Object is known as Cloning process.

=>we use clone() method to perform cloning process.





Method signature of clone():

protected native java.lang.Object clone()

throws java.lang.CloneNotSupportedException;




syntax:

Object ob = obj.clone();















































=>we use the following steps to perform cloning process:

Step-1 : The user defined class must be implemented from "Cloneable" interface.

Step-2 : The user defined class must be declared with one user defined Object-return-type method

Step-3 : This user defined Object-return-type method must call "clone()" method to perform cloning process

Step-4 : Call User defined Object-return-type method to start cloning process.

-----------------------------------------------------------

Types of Cloning process:

=>Cloning process in Java can be perfomed in two ways:

(a)Shallow Cloning process

(b)Deep Cloning process




(a)Shallow Cloning process:

=>The process of cloning only Outer-Objects is known as Shallow Cloning.




(b)Deep Cloning process:

=>The process of cloning Outer-Objects and reffered-Objects is known as Deep Cloning process.

=================================================================== =



Ex-program-1:(Demonstrating Shallow Cloning process)

Address1.java

package p1;

public class Address1 extends Object
{
public String city,state;
public int pinCode;
@Override
public String toString()
{
return
"City:"+city+"\nState:"+state+"\nPinCode:"+pinCode;

}
}


Employee1.java

package p1;

public class Employee1 extends Object implements
Cloneable
{
public String id,name;
public Address1 ad = new Address1(); @Override

public String toString()
{
return "EmpId:"+id+"\nName:"+name;
}
public Object getRef1()
{
Object ob=null;
try {
ob = super.clone();
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}

}

DemoClone1.java(MainClass)

package p2;

import java.util.*;

import p1.*;

public class DemoClone1 {

public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {

//Original Object

Employee1 ob1 = new Employee1();

System.out.println("Enter the EmpId:");

ob1.id = s.nextLine();

System.out.println("Enter the EmpName:");

ob1.name = s.nextLine();

System.out.println("Enter the EmpCity:");

ob1.ad.city = s.nextLine();

System.out.println("Enter the EmpState:");

ob1.ad.state = s.nextLine();

System.out.println("Enter the EmpPinCode:");

ob1.ad.pinCode = s.nextInt();

System.out.println("****Original Object*****");

System.out.println(ob1.toString());

System.out.println(ob1.ad.toString());

System.out.println("----hashCodes----");

System.out.println("ob1 : "+ob1.hashCode());

System.out.println("ob1.ad : "+ob1.ad.hashCode()); //Cloned Object

Employee1 ob2 = (Employee1)ob1.getRef1();

//Specialization process System.out.println("****Cloned Object*****"); System.out.println(ob2.toString()); System.out.println(ob2.ad.toString()); System.out.println("----hashCodes----"); System.out.println("ob2 : "+ob2.hashCode());

System.out.println("ob2.ad : "+ob2.ad.hashCode()); }catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter the EmpId:

A121

Enter the EmpName:

Alex

Enter the EmpCity:

Hyd

Enter the EmpState:

TS

Enter the EmpPinCode:

612345

****Original Object*****

EmpId:A121

Name:Alex

City:Hyd

State:TS

PinCode:612345

----hashCodes----

ob1 : 2074407503

ob1.ad : 999966131

****Cloned Object*****

EmpId:A121

Name:Alex

City:Hyd

State:TS

PinCode:612345

----hashCodes----

ob2 : 1989780873

ob2.ad : 999966131




Diagram:

























=================================================================== =



Ex-program-2:(Demonstrating Deep Cloning Process)

Note:

=>To perform Deep Cloning process,the reffered classes must be implemented from "Cloneable" interface and the classes must be declared with user defined Object-return-type method to call "clone()" method to perform cloning process.



Address2.java
package p1;

public class Address2 extends Object implements
Cloneable
{
public String city,state;
public int pinCode;
@Override
public String toString()
{
return
"City:"+city+"\nState:"+state+"\nPinCode:"+pinCode;

}
public Object getRef2()
{
Object ob = null;
try {
ob = super.clone();
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}
}


Employee2.java

package p1;

public class Employee2 extends Object implements
Cloneable
{
public String id,name;
public Address2 ad = new Address2(); @Override

public String toString()
{
return "EmpId:"+id+"\nName:"+name;
}
public Object getRef1()
{

Employee2 ob=null;

try {
ob = (Employee2)super.clone(); //Employee2 object ob.ad = (Address2)ob.ad.getRef2();//Reference of

Address2
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}
}


DemoClone2.java(MainClass)

package p2;

import java.util.*;

import p1.*;

public class DemoClone2 {

public static void main(String[] args) { Scanner s = new Scanner(System.in); try(s;){

try {

//Original Object

Employee2 ob1 = new Employee2();

System.out.println("Enter the EmpId:");

ob1.id = s.nextLine();

System.out.println("Enter the EmpName:");

ob1.name = s.nextLine();

System.out.println("Enter the EmpCity:");

ob1.ad.city = s.nextLine(); System.out.println("Enter the EmpState:"); ob1.ad.state = s.nextLine(); System.out.println("Enter the EmpPinCode:"); ob1.ad.pinCode = s.nextInt(); System.out.println("****Original Object*****"); System.out.println(ob1.toString()); System.out.println(ob1.ad.toString()); System.out.println("----hashCodes----"); System.out.println("ob1 : "+ob1.hashCode());

System.out.println("ob1.ad : "+ob1.ad.hashCode()); //Cloned Object

Employee2 ob2 = (Employee2)ob1.getRef1();

//Specialization process System.out.println("****Cloned Object*****"); System.out.println(ob2.toString()); System.out.println(ob2.ad.toString()); System.out.println("----hashCodes----"); System.out.println("ob2 : "+ob2.hashCode());

System.out.println("ob2.ad : "+ob2.ad.hashCode()); }catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter the EmpId:

A345

Enter the EmpName:

Ram

Enter the EmpCity:

Hyd

Enter the EmpState:

TS

Enter the EmpPinCode:

675634

****Original Object*****

EmpId:A345

Name:Ram

City:Hyd

State:TS

PinCode:675634

----hashCodes----

ob1 : 2074407503

ob1.ad : 999966131

****Cloned Object*****

EmpId:A345

Name:Ram

City:Hyd

State:TS

PinCode:675634

----hashCodes----

ob2 : 1989780873

ob2.ad : 1480010240

=================================================================== ===

=================================================================== ===

Dt : 20/7/2023

Diagram:












































===================================================================

faq:


define Cloneable?

=>Cloneable is an interface from java.lang package and which is marker interface

or Empty interface.

=>This Cloneable interface will initiate Cloning process.

=================================================================== ===

faq:

wt is the advantage of Cloning process?

=>Through Cloning process we can take the backup of Objects part of Protection

and Security.

=================================================================== ===

4.equals():

=>equals() method is used to compare two objects and generate boolean result.

syntax:

booleab k = ob1.equals(ob2);




5.wait()

6.notify()

7.notifyAll():


=>These methods are used to perform thread communication process.


8.getClass():

=>getClass() method is used to display the class name of an Object.

syntax:

Class nm = obj.getClass();




9.finalize():

=>finalize() method is used to finalize the objects are eligible for garbage Collection process or not.

=================================================================== =======

faq:

define Garbage Collection Process?

=>The process of identifying the anonymous objects and destroying is known as Garbage Collection Process.

=>To perform Garbage Collection process,the ExecutionEngine internally uses "gc()"

method.

=>This gc() method will identify all anonymous objects and calls finalize() method

to finalize objects for garbage colection and they are destroyed.

=>This gc() method is available from "System" and "Runtime" classes.

=>This gc() method is executed like daemon-thread.

=================================================================== ========

Note:(Components of JVM)

PC Register Area:

=>Program Counter(PC) registers will hold the status of method executions in

JavaStackArea.

=>Every method which is executing in Java Stack Area will have its own Program

Counter Register(PCR)

=>All Program Counter Registers are opened in a Separate memory block known as

PC-Register Area.




Native method Area:

=>The methods from the JavaLib which are declared with "native" keyword are known

as native methods

=>These native methods internally having c/c++ codes.

=>when Native methods are used in the application,then Class Loader SubSystem will

identify the Native methods and loads onto a separate location known as Native

method Area.

=>ExecutionEngine internally uses JNI(Java Native method Interface) to execute

Native methods.

----------------------------------------------------------------------

Execution Engine:

=>Execution Engine is executor or processor of JVM and which starts execution with main() method available in Java Stack Area.

=>This Execution Engine internally having two translators:

(i)Interpreter

(ii)JIT Compiler




Diagram:


=================================================================== ======
