Dt : 17/3/2023(Day-1)(Friday)
Course : Full Stack Java Developer

Modules:

thi
i

1.Programming Module
(CoreJava,AdvJava,Spring)
2.UI Module

ipa

(HTML/CSS/JS - Anguler)

(Oracle)
4.Testing Module

Ve
nk
ate
sh

(Testing Basics - Selenium)

Ma

3.Database Module

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM
(ii)Project

-----------------------------------------------------------Language:

(i)Alphabets
(ii)Grammer
(iii)Construction Rules

thi
i

Note:
=>Every language will have its own Alphabets,Grammer and
Contruction Rules.

ipa

==================================================================

Part-1 : CoreJava

Ve
nk
ate
sh

Part-2 : AdvJava

Ma

Java:

Part-1 : CoreJava

1.Programming Components(Java Alphabets)
2.Programming Concepts

3.Object Oriented Programming features

1.Programming Components(Java Alphabets)
(a)Variables
(b)Methods
(c)Blocks
(d)Constructors

(e)Classes
(f)Interfaces
(g)AbstractClasses

thi
i

2.Programming Concepts
(a)Object Oriented Programming

(c)Java Collection Framework(JCF)

(d)Multi-Threading
(e)IO Streams and Files

Ve
nk
ate
sh

(f)Networking in Java

Ma

(Data Structures in Java)

ipa

(b)Exception handling

3.Object Oriented Programming features
(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism
(f)Inheritance

-----------------------------------------------------------------Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava
=>AdvJava provides the following technologies to construct
WebApplications:
(a)JDBC

thi
i

(b)Servlet
(c)JSP
faq:

ipa

define Web Applications?

Ma

=>The applications which are executed in Web-Environment or Internet
Environment are known as Web Applications.

Ve
nk
ate
sh

Architecture of Web Application:

(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to
establish communication to DB-Product

(b)Servlet:

=>Servlet means "server program" and which accepts request from the
User.

(c)JSP:

=>JSP stands for "Java Server Page" and which is response from
WebApplications
===================================================================
Dt : 23/3/2023(day-3)

thi
i

faq:
wt is the diff b/w
(i)Language

ipa

(ii)Technology

(i)Language:

Ma

(iii)Framework

Ve
nk
ate
sh

=>Language will provide Components and Concepts used in
contructing programs.

Ex:

CoreJava

(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.
Ex:
AdvJava

(iii)Framework:
=>The structure which is ready for application development
is known as Framework.
Ex:

thi
i

Spring,WebServices
================================================================
Summary:

Ma

Level-2 : AdvJava ------------->WebApplications

ipa

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-3 : Frameworks----------->Enterprise Applications
(Spring,WebServices)

Ve
nk
ate
sh

==================================================================
faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs
actions in the same computer are known as Stand-Alone applications
or DeskTop Applications or Windows Applications.
=>Stand-Alone applications means,
No html input

No Server Environment
No Database storage
===============================================================

faq:
define Enterprise Applications?
=>The applications which are executing in distributed environment
and depending on the features like "Security","Load Balancing"

thi
i

and "Clustering" are known as Enterprise applications or Enterprise
Distributed applications.

Ve
nk
ate
sh

Ma

ipa

================================================================

Dt:27/3/2023
faq:
wt is the diff b/w
1.JDK

thi
i

2.JRE
3.JVM

ipa

1.JDK:

of the following:
(i)Java Compiler

Ve
nk
ate
sh

(ii)Java Library

Ma

=>JDK stands for "Java Development Kit" and which is collection

(iii)JVM

Diagram:

thi
i
ipa
Ma

Ve
nk
ate
sh

(i)Java Compiler:

=>Java Compiler will compile the source code and if the

compilation Process is successfull then Byte code is generated.

(Java Compiler will compile the Source code and generate Byte code)

(ii)Java Library:

=>Java Library will provide pre-defined ready constructed

components which are used in application development.

(iii)JVM:
=>JVM stands for "Java Virtual Machine" and which is used to

execute Java Byte Code.
--------------------------------------------------------2.JRE:
=>JRE stands for "Java Runtime Environment" and which is collection

-----------------------------------------------------------3.JVM:

Ma

=>JVM will execute Java Byte Code.

ipa

=>JRE is internal partition of JDK.

thi
i

of JavaLib and JVM.

========================================================
faq:

Ve
nk
ate
sh

define Virtual Machine?

=>The s/w component which internally having the behaviour like

machine is knonw as Virtual Machine.

=========================================================

Dt : 17/3/2023(Day-1)(Friday)
Course : Full Stack Java Developer

Modules:

thi
i

1.Programming Module
(CoreJava,AdvJava,Spring)
2.UI Module

ipa

(HTML/CSS/JS - Anguler)

(Oracle)
4.Testing Module

Ve
nk
ate
sh

(Testing Basics - Selenium)

Ma

3.Database Module

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM
(ii)Project

-----------------------------------------------------------Language:

(i)Alphabets
(ii)Grammer
(iii)Construction Rules

thi
i

Note:
=>Every language will have its own Alphabets,Grammer and
Contruction Rules.

ipa

==================================================================

Part-1 : CoreJava

Ve
nk
ate
sh

Part-2 : AdvJava

Ma

Java:

Part-1 : CoreJava

1.Programming Components(Java Alphabets)
2.Programming Concepts

3.Object Oriented Programming features

1.Programming Components(Java Alphabets)
(a)Variables
(b)Methods
(c)Blocks
(d)Constructors

(e)Classes
(f)Interfaces
(g)AbstractClasses

thi
i

2.Programming Concepts
(a)Object Oriented Programming

(c)Java Collection Framework(JCF)

(d)Multi-Threading
(e)IO Streams and Files

Ve
nk
ate
sh

(f)Networking in Java

Ma

(Data Structures in Java)

ipa

(b)Exception handling

3.Object Oriented Programming features
(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism
(f)Inheritance

-----------------------------------------------------------------Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava
=>AdvJava provides the following technologies to construct
WebApplications:
(a)JDBC

thi
i

(b)Servlet
(c)JSP
faq:

ipa

define Web Applications?

Ma

=>The applications which are executed in Web-Environment or Internet
Environment are known as Web Applications.

Ve
nk
ate
sh

Architecture of Web Application:

(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to
establish communication to DB-Product

(b)Servlet:

=>Servlet means "server program" and which accepts request from the
User.

(c)JSP:

=>JSP stands for "Java Server Page" and which is response from
WebApplications
===================================================================
Dt : 23/3/2023(day-3)

thi
i

faq:
wt is the diff b/w
(i)Language

ipa

(ii)Technology

(i)Language:

Ma

(iii)Framework

Ve
nk
ate
sh

=>Language will provide Components and Concepts used in
contructing programs.

Ex:

CoreJava

(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.
Ex:
AdvJava

(iii)Framework:
=>The structure which is ready for application development
is known as Framework.
Ex:

thi
i

Spring,WebServices
================================================================
Summary:

Ma

Level-2 : AdvJava ------------->WebApplications

ipa

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-3 : Frameworks----------->Enterprise Applications
(Spring,WebServices)

Ve
nk
ate
sh

==================================================================
faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs
actions in the same computer are known as Stand-Alone applications
or DeskTop Applications or Windows Applications.
=>Stand-Alone applications means,
No html input

No Server Environment
No Database storage
===============================================================

faq:
define Enterprise Applications?
=>The applications which are executing in distributed environment
and depending on the features like "Security","Load Balancing"

thi
i

and "Clustering" are known as Enterprise applications or Enterprise
Distributed applications.

Ve
nk
ate
sh

Ma

ipa

================================================================

5/20/23, 9:32 AM

6 PM CoreJava145-Dia1.png

https://classroom.google.com/c/NTE3NTIyNTA2MzQ4/m/NjAxMDI5NzgxNTk4/details

1/1

dt : 24/3/2023(Day-4)(Syllabus)
*imp
define Program?

thi
i

=>Program is a set-of-Instructions

define Programming?

ipa

=>The process of constructing programs is known as Programming.

Ma

Note:

=>After writing programs,we save the programs with language
extentions

Ve
nk
ate
sh

Test.c

Test.cpp

Test.java

=>After writing and saving the programs,the programs will have

the following two stages:
1.Compilation
2.Execution

1.Compilation:
=>The process of checking the program constructed according to
the rules of language or not,is known as Compilation process.

=>If the Compilation process is successfull,then sourceCode is
converted into Compiled code.
=>c and c++ languages generate "Objective Code" and JavaLang

thi
i

generate "Byte Code",after Compilation process.

2.Execution:

=>The process of running compiled codes and checking the required

ipa

output is generated or not,is known as Execution process.

Ma

=>In C and c++ languages,the Objective Code is converted into

Executable code after loading and linking process,and generate
result.

Ve
nk
ate
sh

=>In JavaLang,the ByteCode is executed on JVM(Java Virtual Machine)

Diagram:

=================================================

faq:

define Loading process?

=>The process of loading the required components into current

running program is known as "Loading process".
=>This loding process is performed using internal Loaders.

faq:

define Linking process?
=>The process of linking the loaded components into current running
program where they are needed,is known as "Linking Process".
=>This Linking process is performed using internal Linkers.

thi
i

===========================================================
faq:
wt is the diff b/w

ipa

(a)Objective Code

(a)Objective Code:

Ma

(b)Byte Code

Ve
nk
ate
sh

=>The Compiled code generated from c and c++ programs is known

as Objective Code.

=>while Objective Code generation,OperatingSystem is participated

and,because if this reason Objective code is PlatForm dependent
code.

DisAdvantage:

=>The Objective Code which is generated from one PlatForm cannot

be executed on other PlatForms.

Note:

=>C and c++ languages which are generating Objective Code are
Platform dependent languages.

(b)Byte Code:

thi
i

=>The Compiled code generated from JavaPrograms is known as
ByteCode.

=>While ByteCode generation,OperatingSystem is not participated

Advantage:

Ma

ipa

and,because of this reason ByteCode is PlatForm independent code

=>The ByteCode which is generated from one PlatForm can be

Ve
nk
ate
sh

executed on all PlatForms based on JVM.

Note:

=>The JavaLang which is generating ByteCode is PlatForm

independent language.

Diagram:

=============================================================

5/20/23, 9:33 AM

https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all

6 PM CoreJava146-Dia2.png

1/1

Dt : 25/3/2023(Day-5)
faq:
define High Level Languages?
=>The language programs which are constructed from the format

thi
i

which is understandable by the users,are known as High Level
languages
Ex:

define Low Level Languages?

Ma

faq:

ipa

C,C++,Java

Ve
nk
ate
sh

=>The Language programs which are constructed from the format

which is not understandable by the users,are known as Low Level
Languages.
Ex:

Machine Languages

faq:

define Translators?

=>Translators are used to translate High Level Language formats
into Low Level Language formats and Low Level Language formats into
High Level Language formats

=>These Translators are categorized into two types:
(i)Compilers

- translates the total program at-a-time

Ve
nk
ate
sh

Ma

ipa

thi
i

(ii)Interpreters - translates the program line-by-line

==============================================================
*imp
History of Java:
"James Gosling" - Sun Micro Systems - 1991 - Code Writer(Programmer)

WORA - Write Once and Run Anywhere
Virtual Machine

thi
i

Test.gt (Green Talk)

ipa

OAK

1995

Ma

"SILK" "DNA" ... "JAVA"

Ve
nk
ate
sh

--------------------------------------------------

Java Versions:

1995 - Java Alpha&Beta
1996 - JDK 1.0
1997 - JDK 1.1
1998 - JDK 1.2
2000 - JDK 1.3
2002 - JDK 1.4

----------------------------2004 - Java5
2006 - Java6

2011 - Java7
2014 - Java8
2017 - Java9
2018 - Java10,Java11

thi
i

2019 - Java12,Java13
2020 - Java14,Java15
2021 - Java16,Java17

ipa

2022 - Java18,Java19

Ma

2023 - Java20(March 21st)

=====================================================
LTS(Long Term Support) products:

Ve
nk
ate
sh

Java8

Java11
Java17

======================================================

Dt : 28/3/2023
*imp
Installing Java s/w and Setting path:

thi
i

step-1 : Download Java s/w(JDK) from Oracle WebSite

step-2 : Install JDK(Java s/w)

Ve
nk
ate
sh

Note:

Ma

ipa

https://www.oracle.com/in/java/technologies/downloads/

=>After installation process is successfull,we can find one

folder with name "java" in "programfiles"
C:\Program Files\Java

step-3 : Set Java path in "Environment Variables"

RightClick on MyComputer->Properties->Advanced System Settings->
Environment Variables->Click "new" from System Variables,

Variable name : path

Variable value : C:\Program Files\Java\jdk-17.0.4.1\bin;

step-4 : Click "ok" for three times
===========================================================

thi
i

Note:
=>Open CommandPrompt and check the following commands are working

javac - Command for Compilation process

Ma

java - Command Execution process

ipa

or not:

=============================================================
Note:

Ve
nk
ate
sh

=>Use the following syntax in CommandPrompt to know the Version

available in ComputerSystem:
java -version

============================================================
*imp

Writing,Saving,Compiling and Executing Java program:
=>In Java language writing program means constructing "class".

define "class"?
=>class in Java is a "Structured layout" generating "Objects".
=>Class in Java is a Collection of Variables,Methods,Blocks,

Constructors and main()
=>we use "class" keyword in Java to construct Classes

thi
i

structure of "class" in Java:

class Class_name
{

ipa

Variables

Blocks
Constructors

Ve
nk
ate
sh

main()

Ma

Methods

}

=>main() in Java will have the following pre-defined built-in

format:

public static void main(String args[])

--------------------------------------------------------

Ex-program :
Wap to display the msg as "Welcome to Java"?

class Display
{
public static void main(String args[])
{

thi
i

System.out.print("Welcome to Java");
}
}

Ve
nk
ate
sh

Ma

ipa

=======================================================

Dt : 29/3/2023
Executing Java Program:

step-1 : Create one folder in any drive

ipa

step-2 : Open notepad and type the program

thi
i

D:\Demo146

syntax:
Class_name.java

Ve
nk
ate
sh

Ex:

Ma

step-3 : Save the program in folder with language extention

Display.java

To save the program,click on File->Save->Browse the folder->
name the file as "Display.java"->save as type must be "All files"->
click "Save".

Note:

=>Open CommandPrompt to perform Compilation and execution process
=>To open CommandPrompt->goto folder->type "cmd" in AddressBar and
press enter.

step-4 : Compile the program as follows
syntax:
javac Class_name.java

thi
i

Ex:

step-5 : Execute the program as follows

java Class_name
Ex:

Ve
nk
ate
sh

java Display

Ma

syntax:

ipa

javac Display.java

================================================================
Ex-2 :

wap to add two numbers and display the result?

class Addition
{

public static void main(String args[])
{
int a=11,b=12;
int c = a+b;

System.out.println("a value="+a);
System.out.println("b value="+b);
System.out.print("c value="+c);
}

thi
i

}

o/p:

ipa

a value=11

c value=23

Ma

b value=12

=======================================================

Ve
nk
ate
sh

Assignment-1:

wap to display the following:
int empId

int empPhNo
int empSal

float totSal = empSal+(0.93F*empSal)+(0.63F*empSal);

Assignment-2:

wap to display the following:
int s1
int s2

...
int s6
int totMarks =
float per =

Ve
nk
ate
sh

Ma

ipa

thi
i

========================================================

Dt : 30/3/2023
faq:
define Environment Variables?
=>The variables part of OperatingSystem holding information about softwares

thi
i

installed in ComputerSystem are known as "Environment Variables"
=>These Environment Variables are categorized into two types:
(i)User Variables

Ma

(i)User Variables:

ipa

(ii)System Variables

=>The variables which are related to individual users of ComputerSystem

Ve
nk
ate
sh

are known as User Variables.

=>The information available in User variables can be used by only the

indvidual User.

(ii)System Variables:

=>The variables which are related to ComputerSystem are known as System

Variables.

=>The information available in System Variables can be used by all users

of ComputerSystem.
===================================================================
===

faq:
wt is the advantage of having JavaPath in Environment Variables?
=>When we have JavaPath in Environment Variables,then we can Compile and
Execute Java Programs from any location of ComputerSystem.

thi
i

===================================================================
====

Ve
nk
ate
sh

Ma

ipa

Diagram:

===================================================================
====
Flow of Syllabus Content:

1.Naming Conventions in Java
2.Datatypes in Java
3.Variables in Java

4.Methods in Java
5.JVM Architecture with internals
6.Constructors in Java
7.Blocks in Java

thi
i

8.Packages in Java
9.Creating Java Project using IDE
10.Relations in Java(Introduction)

ipa

11.References in Java

13.Interfaces in Java
14.AbstractClasses in Java

Ve
nk
ate
sh

15.InnerClasses in Java

Ma

12.Inheritance in Java

16.PolyMorphism in Java

17.Conclusion of Object Oriented features
(Abstraction and Encapsulation)

18.Exception Handling in Java
19.String in Java

20.WrapperClasses in Java
21.Arrays in Java

22.Java Collection Framework
(Data structures in Java)
23.Enum in Java

24.MultiThreading in Java
25.IO Streams and Files in Java
26.Networking in Java
27.Introduction GUI Programming

thi
i

28.Object Class(Object Cloning)
29.Conclusion

======================================================

ipa

*imp

Ma

Naming Conventions in Java:

=>The rules followed by the programmer in writing Java Programs are

Ve
nk
ate
sh

known as Naming Conventions in Java.

packages :

def : packages are collection of "Classes and Interfaces".
rule : packages must be in LowerCase.

Classes and Interfaces:

def : Classes and Interfaces are collection of "Variables and Methods"

rule : In Classes and Interfaces the starting letter of every word must
be Capital letter or UpperCase.
Ex:
InputStream

InputStreamReader

Variables and Methods:
def : Variables are data holders and Methods are actions

thi
i

rule : In Variables and Methods the first word must be lowercase and
from second word onwards the starting letter must be capital
Ex-Variables:

ipa

panCardNo

Ex-Methods:
getSalary()

Ve
nk
ate
sh

calculateTot()

Ma

rollNo

Keywords :

def : Pre-defined Built-in words are known as Keywords

rule : Keywords must be LowerCase
Ex:

static
void

public
class
...

===================================================================
==
faq:
define Identifiers?
=>The names which are used to identify the programming components are

thi
i

known as Identifiers.

Ve
nk
ate
sh

Ma

ipa

===================================================================
=

Dt : 31/3/2023
*imp
DataTypes in Java:
=>The types of data which we are expecting as input to

=>Datatypes in Java are categorized into two types:
1.Primitive datatypes

Ma

1.Primitive datatypes:

ipa

2.NonPrimitive datatypes

thi
i

JavaPrograms are known as Datatypes in Java.

=>The "Single valued data formats" are known as Primitive

Ve
nk
ate
sh

datatypes.

=>Primitive datatypes are categorized into four types:
(a)Integer datatypes
(b)Float datatypes

(c)Character datatype
(d)Boolean datatype

(a)Integer datatypes:

=>The numeric data without decimal point representation are
known as Integer datatypes.
=>Integer datatypes are categorized into four types:

(i)byte - 1 byte(8 bits)
(ii)short - 2 bytes
(iii)int - 4 bytes
(iv)long - 8 bytes

Multi-media data.
=>"int" datatype is used in normal programming.

thi
i

=>"byte" and "short" datatypes are used for stream-data or

ipa

=>"long" datatype is used to hold lagest numeric value without

Ma

decimal point,which means holding PhoneNO,CardNo,...

=>In the process of assigning long-data-value we must use "L"
(or) "l" in the RHS of declaration.

Ve
nk
ate
sh

Ex:

long p = 9898981234L;

(b)Float datatypes:

=>The numeric data with decimal point representation are known

as Float datatypes.

=>Float datatypes are categorized into two types:
(i)float - 4 bytes

(ii)double - 8 bytes
=>"float" datatype is used in normal programming.
=>"double" datatype is used to hold lagest scientic calculated

values
=>In the process of assigning float-data-value we must use "F"
(or) "f" in the RHS of declaration.
Ex:

thi
i

float k = 123.56F;

(c)Character datatype:

Ex:
'h','y','k',...

Ve
nk
ate
sh

=>Types:

Ma

quotes is known as Character datatype.

ipa

=>The "single valued character" which is represented in single

char - 2 bytes

(d)Boolean datatype:

=>The datatype which is represented in the form of true or false

is known as Boolean datatype.
=>Types:

boolean - 1 bit

--------------------------------------------Ex-program:

DataTypes1.java
class DataTypes1
{
public static void main(String args[])

thi
i

{
byte b = 127;
short s = 32767;

ipa

int i = 45673467;

float k = 123.56F;
double z = 2345.67;

Ve
nk
ate
sh

char ch = 'h';

Ma

long p = 9898981234L;

boolean bl = true;

System.out.println("byte value="+b);

System.out.println("short value="+s);
System.out.println("int value="+i);

System.out.println("long value="+p);

System.out.println("float value="+k);

System.out.println("double value="+z);
System.out.println("char value="+ch);

System.out.println("boolean value="+bl);
}

}
o/p:
byte value=127
short value=32767

thi
i

int value=45673467
long value=9898981234
float value=123.56

ipa

double value=2345.67

boolean value=true

Ma

char value=h

========================================================

Ve
nk
ate
sh

*imp

2.NonPrimitive datatypes:

=>The "Group valued data formats" are known as NonPrimitive

datatypes or Referential datatypes.

=>These NonPrimitive datatypes are categorized into four types:
(a)Class

(b)Interface
(c)Array

(d)Enum
==========================================================
faq:

define "String" datatype?
=>In Java,"String" is a Pre-defined class from JavaLib and which
is NonPrimitive datatype or Referential data type.

=>The string-data is represented in double quotes
Ex:

ipa

String city = "hyd";

Ma

String branch = "CSE";
String name = "Alex";

thi
i

Note:

============================================================

Ve
nk
ate
sh

Assignment:

wap to display UserDetails?
userName
passWord
firstName
lastName
hNo

sName
city
state

pinCode

mailId
phNo

Ve
nk
ate
sh

Ma

ipa

thi
i

=============================================================

Dt : 1/4/2023
Assignment:(Solution)
wap to display UserDetails?

{
public static void main(String args[])

String userName="nit.v";
String passWord="mzu672";

Ve
nk
ate
sh

String firstName="Raj";

Ma

{

ipa

class UserDetails

thi
i

Prog : UserDetails.java

String lastName="Kumar";
String hNo="12-34/h";

String sName="SR-Nagar";
String city="Hyd";
String state="TS";

int pinCode=612345;

String mailId="raj@gmail.com";
long phNo=9898981234L;

System.out.println("****UserDetails****");
System.out.println("UName="+userName);

System.out.println("PWord="+passWord);
System.out.println("FName="+firstName);
System.out.println("LName="+lastName);
System.out.println("HNO="+hNo);

System.out.println("State="+state);
System.out.println("PinCode="+pinCode);

Ma

System.out.println("MailId="+mailId);
System.out.println("PhoneNO="+phNo);
}

Ve
nk
ate
sh

}

o/p:

****UserDetails****
UName=nit.v

PWord=mzu672
FName=Raj

LName=Kumar
HNO=12-34/h

StreetName=SR-Nagar
City=Hyd
State=TS

ipa

System.out.println("City="+city);

thi
i

System.out.println("StreetName="+sName);

PinCode=612345
MailId=raj@gmail.com
PhoneNO=9898981234
=============================================================

thi
i

faq:
wt is the diff b/w
(i)print()

Ma

(i)print():

ipa

(ii)println()

=>print() method will display the data and the cursor waits in

Ve
nk
ate
sh

the same line.

(ii)println():

=>println() method also display the data,but the cursor moved
to the new line or next line.

=========================================================
Note:

=>"+" symbol in print() method will specify concatenating msg with

result.

=========================================================
Assignment:
wap to display CustomerDetails?

custId
accNo
custName
balance

thi
i

accType
hNo
sName

ipa

city

pinCode
mailId

Ve
nk
ate
sh

phNo

Ma

state

==========================================================

Dt : 3/4/2023
*imp
Object Oriented Programming:
=>The process of constructing programs using Class-Object concept

thi
i

is known as Object Oriented Programming.
=>In Object Oriented programming we work with NonPrimitive
datatypes or Referential datatypes.

ipa

=>The following are the levels in Object Oriented Programming:

2.Object creation
3.Object location

Ve
nk
ate
sh

4.Object components

Ma

1.Object definition

5.Object types

(a)User defined class objects
(b)String object

(c)WrapperClass objects
(d)Array Objects

(e)Collection<E> objects
(f)Map<K,V> objects
(g)Enum<E> Objects

6.Object Locking
7.Object Collection(Objects grouping)

8.Object Sorting
9.Object Serializable
10.Object Cloning
-----------------------------------------------------------

define Object?

thi
i

faq:

=>Object is a storage related to a class holding members of class.

ipa

=>we use "new" keyword in Java to create objects.

Ma

syntax:

Class_name object_name = new Class_name();

========================================================

Ve
nk
ate
sh

*imp

(a)Class:

=>Class is a "Structured Layout" generating Objects.
=>Classes in Java are categorized into two types:
(i)Pre-defined classes

(ii)User defined classes

(i)Pre-defined classes:

=>The classes which are ready constructed and available from
JavaLib are known as Pre-defined classes or Built-in classes.
Ex:

String
System

(ii)User defined classes:

thi
i

=>The classes which are defined by the programmer are known as
User defined classes
Ex:

ipa

Display

DataTypes1
UserDetails

Ma

Addition

Ve
nk
ate
sh

===============================================================
Note:

=>Classes are collection Variables,Methods,Blocks and

Constructors

===============================================================
*imp

Variables in Java:

=>Variables are the data holders in the program.
=>Based on datatypes in Java,the variables are categorized into
two types:
1.Primitive datatype variables

2.NonPrimitive datatype variables

1.Primitive datatype variables:
=>The variables which are declared with primitive datatypes like

datatype variables.

ipa

=>These primitive datatype variables will hold values.

thi
i

byte,short,int,long,float,double,char,boolean are known as Primitive

Ma

2.NonPrimitive datatype variables:

=>The variables which are declared with NonPrimitive datatypes
like class,interface,array,enum are known as NonPrimitive datatype

Ve
nk
ate
sh

variables or referential datatype variables.

=>These NonPrimitive datatype variables will hold Object

references or Object addresses.

---------------------------------------------------------

*imp

define "static" keyword?

=>"static" keyword in Java will decide the location of memory

for Programming Components.

static - means memory in class
NonStatic - means memory in Object
===============================================================

*imp
=>Based on "static" keyword the variables in Java are categorized
into two types:
1.static variables

thi
i

2.NonStatic variables

1.static variables:

ipa

=>The Variables which are declared with "static" keyword are

Ma

known as "static variables" or "Class variables".

=>These static variables will get the memory within the class

Ve
nk
ate
sh

while class loading and can be accessed with class_name.

2.NonStatic variables:

=>The variables which are declared without "static" keyword are

known as NonStatic variables.

=>These NonStatic variables are categorized into two types:
(a)Instance variables
(b)Local variables

(a)Instance variables:
=>The NonStatic variables which are declared outside the methods
are known as Instance variables or Object Variables.

=>These Instance variables will get the memory within the Object
while Object creatin process and can be accessed with Object_name.

(b)Local variables:

thi
i

=>The NonStatic variables which are declared inside the methods
are known as Local variables.

=>These Local variables will get the memory within the method

ipa

while method execution.

methods.

Ve
nk
ate
sh

Ex : DemoVariables.java

Ma

=>These Local variables can be accessed directly inside the

class DemoVariables
{

static int a=10;
int b=20;

public static void main(String args[])
{

int c=30;

System.out.println("a value="+DemoVariables.a);
DemoVariables ob = new DemoVariables();
System.out.println("b value="+ob.b);

System.out.println("c value="+c);
}
}
o/p:

thi
i

a value=10
b value=20
c value=30

Ve
nk
ate
sh

Ma

ipa

==========================================================

5/20/23, 9:37 AM

https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all

6 PM CoreJava146-Dia8.png

1/1

Dt : 4/4/2023
*imp
Methods in Java:
=>Methods are the actions which are executed to generate results.

thi
i

=>Based on "static" keyword the methods are categorized into
two types:
1.static methods

Ma

1.static methods:

ipa

2.NonStatic methods

=>The methods which are declared with "static" keyword are known

Ve
nk
ate
sh

as static methods.

=>These static methods will get the memory within the class

while class loading and can be accessed with Class_name.

structure of "static" method:

static return_type method_name(para_list)
{

//method_body

}

Coding Rule:

=>Static methods can access static variables from the same class
directly,but cannot access Instance variables directly.
------------------------------------=>These static methods are categorized into two types:

thi
i

(i)pre-defined static methods
(ii)User defined static methods

ipa

(i)pre-defined static methods:

Ma

=>The static methods which are ready constructed and available
from JavaLib are known as pre-defined static methods or Built-in

Ve
nk
ate
sh

static methods.

(ii)User defined static methods:

=>The static methods which are defined by the programmer are

known as User defined static methods.

====================================================

2.NonStatic methods:

=>The methods which are declared without "static" keyword are

known as NonStatic methods.

=>These NonStatic methods are known as Instance methods,because
there are no Local methods.
=>These Instance methods will get the memory within the object

while Object creation process and can be accessed with Object_name.

structure of instance methods:

thi
i

return_type method_name(para_list)
{
//method_body

Coding Rule:

Ma

ipa

}

=>Instance methods can access both "Instance variables and Static

Ve
nk
ate
sh

variables" directly.

(Object generated from the class,which means object belongs to
class and members of Object can access members of class directly)
------------------------------------------------------

=>These Instance methods are categorized into two types:
(i)Pre-defined Instance methods

(ii)User defined Instance methods

(i)Pre-defined Instance methods:
=>The Instance methods which are ready constructed and available
from JavaLib are known as Pre-defined Instance methods or Built-in

Instance methods

(ii)User defined Instance methods:
=>The Instance methods which are defined by the programmer are

thi
i

known as User defined Instance methods.
=========================================================
EX : DemoMethods1.java

ipa

class DemoMethods1

static int x=10;
int y=20;

Ve
nk
ate
sh

static void dis1()

Ma

{

{

int z = 200;

System.out.println("****dis1()****");
System.out.println("x value="+x);
System.out.println("z value="+z);

}

void dis2()
{

int z=300;
System.out.println("****dis2()****");

System.out.println("x value="+x);
System.out.println("y value="+y);
System.out.println("z value="+z);
}

thi
i

public static void main(String args[])
{
int z = 100;

ipa

DemoMethods1.dis1();

ob.dis2();

Ma

DemoMethods1 ob = new DemoMethods1();

System.out.println("****main()***");

Ve
nk
ate
sh

System.out.println("z value="+z);

}

}

o/p:

****dis1()****
x value=10

z value=200
****dis2()****
x value=10

y value=20
z value=300
****main()***

thi
i

z value=100

=====================================================

Ve
nk
ate
sh

Ma

ipa

Diagram:

======================================================

Dt : 5/4/2023
Note:
=>Based on memory location the variables are categorized into
three types:

thi
i

1.Class variables
2.Object variables

ipa

3.Method variables

Ma

1.Class variables:

=>static variables are known as Class variables,because the

Ve
nk
ate
sh

variables will get the memory within the class.

2.Object variables:

=>Instance variables are known as Object variables,because the
variables will get the memory within the Object.

3.Method variables:

=>Local variables are known as Method variables,because the
variables will get the memory within the methods while method
execution.

==========================================================
faq:

define Global Variables?
=>There is no concept of Global variables in Java,because we
cannot declare variables outside the class.
============================================================

thi
i

faq:
define Static local variables?

=>There is no concept of static local variables in Java,because

ipa

static variables means memory in class and cannot be a local

Ma

variables.(Compiler ambiguity)

============================================================
faq:

Ve
nk
ate
sh

wt is the advantage of having static programming components memory
in Class?

=>The static programming components can be shared by multiple

objects generated from the class.

==============================================================

Assignment:

Construct the program for the following Layout:

===============================================================
*imp
define parameters?

=>parameters are the variables which are used to transfer the
data from one method to another method.
=>Based on parameters the methods are categorized into two types:
(i)Methods without parameters

thi
i

(ii)Methods with parameters

(i)Methods without parameters:

ipa

=>The methods which are declared without parameters are known as

(ii)Methods with parameters:

Ma

0-parameter methods or Methods without parameters.

Ve
nk
ate
sh

=>The methods which are declared with parameters are known as

parameterized methods or Methods with parameters.
==============================================================

*imp

define return_type?

=>return_type specify the methods will return the value after

method execution.

=>Based on return_type methods are categorized into two types:
(i)Non-return_type methods
(ii)return_type methods

(i)Non-return_type methods:
=>The methods which will not return any value after method
execution are known as Non-return_type methods.
=>The methods which are declared with "void" are known as

thi
i

Non-return_type methods.

(ii)return_type methods :

ipa

=>The methods which return the value after method execution are

Ma

known as return_type methods.

=>The methods which are declared without "void" are known as
return_type methods.

Ve
nk
ate
sh

=>we use "return" statement to return the value after method

execution

==============================================================

5/20/23, 9:39 AM

https://classroom.google.com/w/NTE3NTIyNTA2MzQ4/t/all

Methods2.png

1/1

Dt : 17/3/2023(Day-1)(Friday)
Course : Full Stack Java Developer

Modules:

thi
i

1.Programming Module
(CoreJava,AdvJava,Spring)
2.UI Module

ipa

(HTML/CSS/JS - Anguler)

(Oracle)
4.Testing Module

Ve
nk
ate
sh

(Testing Basics - Selenium)

Ma

3.Database Module

5.Tools Module

(DevSecOpps - tools)

---------------------------------------------------------

Duration : 5 - 6 Months

---------------------------------------------------------

Advantage:

(i)NASSCOM
(ii)Project

-----------------------------------------------------------Language:

(i)Alphabets
(ii)Grammer
(iii)Construction Rules

thi
i

Note:
=>Every language will have its own Alphabets,Grammer and
Contruction Rules.

ipa

==================================================================

Part-1 : CoreJava

Ve
nk
ate
sh

Part-2 : AdvJava

Ma

Java:

Part-1 : CoreJava

1.Programming Components(Java Alphabets)
2.Programming Concepts

3.Object Oriented Programming features

1.Programming Components(Java Alphabets)
(a)Variables
(b)Methods
(c)Blocks
(d)Constructors

(e)Classes
(f)Interfaces
(g)AbstractClasses

thi
i

2.Programming Concepts
(a)Object Oriented Programming

(c)Java Collection Framework(JCF)

(d)Multi-Threading
(e)IO Streams and Files

Ve
nk
ate
sh

(f)Networking in Java

Ma

(Data Structures in Java)

ipa

(b)Exception handling

3.Object Oriented Programming features
(a)Class

(b)Object

(c)Abstraction

(d)Encapsulation

(e)PolyMorphism
(f)Inheritance

-----------------------------------------------------------------Dt: 21/3/2023(day-2)(Tuesday)

Part-2 : AdvJava
=>AdvJava provides the following technologies to construct
WebApplications:
(a)JDBC

thi
i

(b)Servlet
(c)JSP
faq:

ipa

define Web Applications?

Ma

=>The applications which are executed in Web-Environment or Internet
Environment are known as Web Applications.

Ve
nk
ate
sh

Architecture of Web Application:

(a)JDBC:

=>JDBC stands for "Java DataBase Connectivity" and which is used to
establish communication to DB-Product

(b)Servlet:

=>Servlet means "server program" and which accepts request from the
User.

(c)JSP:

=>JSP stands for "Java Server Page" and which is response from
WebApplications
===================================================================
Dt : 23/3/2023(day-3)

thi
i

faq:
wt is the diff b/w
(i)Language

ipa

(ii)Technology

(i)Language:

Ma

(iii)Framework

Ve
nk
ate
sh

=>Language will provide Components and Concepts used in
contructing programs.

Ex:

CoreJava

(ii)Technology:

=>The process of converting Knowledge into realtime world

application development is known as Technology.
Ex:
AdvJava

(iii)Framework:
=>The structure which is ready for application development
is known as Framework.
Ex:

thi
i

Spring,WebServices
================================================================
Summary:

Ma

Level-2 : AdvJava ------------->WebApplications

ipa

Level-1 : CoreJava ------------>Stand-Alone Applications

Level-3 : Frameworks----------->Enterprise Applications
(Spring,WebServices)

Ve
nk
ate
sh

==================================================================
faq:

define Stand-Alone applications?

=>The applications which are installed in one computer and performs
actions in the same computer are known as Stand-Alone applications
or DeskTop Applications or Windows Applications.
=>Stand-Alone applications means,
No html input

No Server Environment
No Database storage
===============================================================

faq:
define Enterprise Applications?
=>The applications which are executing in distributed environment
and depending on the features like "Security","Load Balancing"

thi
i

and "Clustering" are known as Enterprise applications or Enterprise
Distributed applications.

Ve
nk
ate
sh

Ma

ipa

================================================================

Dt : 3/4/2023
*imp
Object Oriented Programming:
=>The process of constructing programs using Class-Object concept

thi
i

is known as Object Oriented Programming.
=>In Object Oriented programming we work with NonPrimitive
datatypes or Referential datatypes.

ipa

=>The following are the levels in Object Oriented Programming:

2.Object creation
3.Object location

Ve
nk
ate
sh

4.Object components

Ma

1.Object definition

5.Object types

(a)User defined class objects
(b)String object

(c)WrapperClass objects
(d)Array Objects

(e)Collection<E> objects
(f)Map<K,V> objects
(g)Enum<E> Objects

6.Object Locking
7.Object Collection(Objects grouping)

8.Object Sorting
9.Object Serializable
10.Object Cloning
-----------------------------------------------------------

define Object?

thi
i

faq:

=>Object is a storage related to a class holding members of class.

ipa

=>we use "new" keyword in Java to create objects.

Ma

syntax:

Class_name object_name = new Class_name();

========================================================

Ve
nk
ate
sh

*imp

(a)Class:

=>Class is a "Structured Layout" generating Objects.
=>Classes in Java are categorized into two types:
(i)Pre-defined classes

(ii)User defined classes

(i)Pre-defined classes:

=>The classes which are ready constructed and available from
JavaLib are known as Pre-defined classes or Built-in classes.
Ex:

String
System

(ii)User defined classes:

thi
i

=>The classes which are defined by the programmer are known as
User defined classes
Ex:

ipa

Display

DataTypes1
UserDetails

Ma

Addition

Ve
nk
ate
sh

===============================================================
Note:

=>Classes are collection Variables,Methods,Blocks and

Constructors

===============================================================
*imp

Variables in Java:

=>Variables are the data holders in the program.
=>Based on datatypes in Java,the variables are categorized into
two types:
1.Primitive datatype variables

2.NonPrimitive datatype variables

1.Primitive datatype variables:
=>The variables which are declared with primitive datatypes like

datatype variables.

ipa

=>These primitive datatype variables will hold values.

thi
i

byte,short,int,long,float,double,char,boolean are known as Primitive

Ma

2.NonPrimitive datatype variables:

=>The variables which are declared with NonPrimitive datatypes
like class,interface,array,enum are known as NonPrimitive datatype

Ve
nk
ate
sh

variables or referential datatype variables.

=>These NonPrimitive datatype variables will hold Object

references or Object addresses.

---------------------------------------------------------

*imp

define "static" keyword?

=>"static" keyword in Java will decide the location of memory

for Programming Components.

static - means memory in class
NonStatic - means memory in Object
===============================================================

*imp
=>Based on "static" keyword the variables in Java are categorized
into two types:
1.static variables

thi
i

2.NonStatic variables

1.static variables:

ipa

=>The Variables which are declared with "static" keyword are

Ma

known as "static variables" or "Class variables".

=>These static variables will get the memory within the class

Ve
nk
ate
sh

while class loading and can be accessed with class_name.

2.NonStatic variables:

=>The variables which are declared without "static" keyword are

known as NonStatic variables.

=>These NonStatic variables are categorized into two types:
(a)Instance variables
(b)Local variables

(a)Instance variables:
=>The NonStatic variables which are declared outside the methods
are known as Instance variables or Object Variables.

=>These Instance variables will get the memory within the Object
while Object creatin process and can be accessed with Object_name.

(b)Local variables:

thi
i

=>The NonStatic variables which are declared inside the methods
are known as Local variables.

=>These Local variables will get the memory within the method

ipa

while method execution.

methods.

Ve
nk
ate
sh

Ex : DemoVariables.java

Ma

=>These Local variables can be accessed directly inside the

class DemoVariables
{

static int a=10;
int b=20;

public static void main(String args[])
{

int c=30;

System.out.println("a value="+DemoVariables.a);
DemoVariables ob = new DemoVariables();
System.out.println("b value="+ob.b);

System.out.println("c value="+c);
}
}
o/p:

thi
i

a value=10
b value=20
c value=30

Ve
nk
ate
sh

Ma

ipa

==========================================================

Dt : 5/4/2023
Note:
=>Based on memory location the variables are categorized into
three types:

thi
i

1.Class variables
2.Object variables

ipa

3.Method variables

Ma

1.Class variables:

=>static variables are known as Class variables,because the

Ve
nk
ate
sh

variables will get the memory within the class.

2.Object variables:

=>Instance variables are known as Object variables,because the
variables will get the memory within the Object.

3.Method variables:

=>Local variables are known as Method variables,because the
variables will get the memory within the methods while method
execution.

==========================================================
faq:

define Global Variables?
=>There is no concept of Global variables in Java,because we
cannot declare variables outside the class.
============================================================

thi
i

faq:
define Static local variables?

=>There is no concept of static local variables in Java,because

ipa

static variables means memory in class and cannot be a local

Ma

variables.(Compiler ambiguity)

============================================================
faq:

Ve
nk
ate
sh

wt is the advantage of having static programming components memory
in Class?

=>The static programming components can be shared by multiple

objects generated from the class.

==============================================================

Assignment:

Construct the program for the following Layout:

===============================================================
*imp
define parameters?

=>parameters are the variables which are used to transfer the
data from one method to another method.
=>Based on parameters the methods are categorized into two types:
(i)Methods without parameters

thi
i

(ii)Methods with parameters

(i)Methods without parameters:

ipa

=>The methods which are declared without parameters are known as

(ii)Methods with parameters:

Ma

0-parameter methods or Methods without parameters.

Ve
nk
ate
sh

=>The methods which are declared with parameters are known as

parameterized methods or Methods with parameters.
==============================================================

*imp

define return_type?

=>return_type specify the methods will return the value after

method execution.

=>Based on return_type methods are categorized into two types:
(i)Non-return_type methods
(ii)return_type methods

(i)Non-return_type methods:
=>The methods which will not return any value after method
execution are known as Non-return_type methods.
=>The methods which are declared with "void" are known as

thi
i

Non-return_type methods.

(ii)return_type methods :

ipa

=>The methods which return the value after method execution are

Ma

known as return_type methods.

=>The methods which are declared without "void" are known as
return_type methods.

Ve
nk
ate
sh

=>we use "return" statement to return the value after method

execution

==============================================================

dt : 24/3/2023(Day-4)(Syllabus)
*imp
define Program?

thi
i

=>Program is a set-of-Instructions

define Programming?

ipa

=>The process of constructing programs is known as Programming.

Ma

Note:

=>After writing programs,we save the programs with language
extentions

Ve
nk
ate
sh

Test.c

Test.cpp

Test.java

=>After writing and saving the programs,the programs will have

the following two stages:
1.Compilation
2.Execution

1.Compilation:
=>The process of checking the program constructed according to
the rules of language or not,is known as Compilation process.

=>If the Compilation process is successfull,then sourceCode is
converted into Compiled code.
=>c and c++ languages generate "Objective Code" and JavaLang

thi
i

generate "Byte Code",after Compilation process.

2.Execution:

=>The process of running compiled codes and checking the required

ipa

output is generated or not,is known as Execution process.

Ma

=>In C and c++ languages,the Objective Code is converted into

Executable code after loading and linking process,and generate
result.

Ve
nk
ate
sh

=>In JavaLang,the ByteCode is executed on JVM(Java Virtual Machine)

Diagram:

=================================================

faq:

define Loading process?

=>The process of loading the required components into current

running program is known as "Loading process".
=>This loding process is performed using internal Loaders.

faq:

define Linking process?
=>The process of linking the loaded components into current running
program where they are needed,is known as "Linking Process".
=>This Linking process is performed using internal Linkers.

thi
i

===========================================================
faq:
wt is the diff b/w

ipa

(a)Objective Code

(a)Objective Code:

Ma

(b)Byte Code

Ve
nk
ate
sh

=>The Compiled code generated from c and c++ programs is known

as Objective Code.

=>while Objective Code generation,OperatingSystem is participated

and,because if this reason Objective code is PlatForm dependent
code.

DisAdvantage:

=>The Objective Code which is generated from one PlatForm cannot

be executed on other PlatForms.

Note:

=>C and c++ languages which are generating Objective Code are
Platform dependent languages.

(b)Byte Code:

thi
i

=>The Compiled code generated from JavaPrograms is known as
ByteCode.

=>While ByteCode generation,OperatingSystem is not participated

Advantage:

Ma

ipa

and,because of this reason ByteCode is PlatForm independent code

=>The ByteCode which is generated from one PlatForm can be

Ve
nk
ate
sh

executed on all PlatForms based on JVM.

Note:

=>The JavaLang which is generating ByteCode is PlatForm

independent language.

Diagram:

=============================================================

Dt:27/3/2023
faq:
wt is the diff b/w
1.JDK

thi
i

2.JRE
3.JVM

ipa

1.JDK:

of the following:
(i)Java Compiler

Ve
nk
ate
sh

(ii)Java Library

Ma

=>JDK stands for "Java Development Kit" and which is collection

(iii)JVM

Diagram:

thi
i
ipa
Ma

Ve
nk
ate
sh

(i)Java Compiler:

=>Java Compiler will compile the source code and if the

compilation Process is successfull then Byte code is generated.

(Java Compiler will compile the Source code and generate Byte code)

(ii)Java Library:

=>Java Library will provide pre-defined ready constructed

components which are used in application development.

(iii)JVM:
=>JVM stands for "Java Virtual Machine" and which is used to

execute Java Byte Code.
--------------------------------------------------------2.JRE:
=>JRE stands for "Java Runtime Environment" and which is collection

-----------------------------------------------------------3.JVM:

Ma

=>JVM will execute Java Byte Code.

ipa

=>JRE is internal partition of JDK.

thi
i

of JavaLib and JVM.

========================================================
faq:

Ve
nk
ate
sh

define Virtual Machine?

=>The s/w component which internally having the behaviour like

machine is knonw as Virtual Machine.

=========================================================

Dt : 29/3/2023
Executing Java Program:

step-1 : Create one folder in any drive

ipa

step-2 : Open notepad and type the program

thi
i

D:\Demo146

syntax:
Class_name.java

Ve
nk
ate
sh

Ex:

Ma

step-3 : Save the program in folder with language extention

Display.java

To save the program,click on File->Save->Browse the folder->
name the file as "Display.java"->save as type must be "All files"->
click "Save".

Note:

=>Open CommandPrompt to perform Compilation and execution process
=>To open CommandPrompt->goto folder->type "cmd" in AddressBar and
press enter.

step-4 : Compile the program as follows
syntax:
javac Class_name.java

thi
i

Ex:

step-5 : Execute the program as follows

java Class_name
Ex:

Ve
nk
ate
sh

java Display

Ma

syntax:

ipa

javac Display.java

================================================================
Ex-2 :

wap to add two numbers and display the result?

class Addition
{

public static void main(String args[])
{
int a=11,b=12;
int c = a+b;

System.out.println("a value="+a);
System.out.println("b value="+b);
System.out.print("c value="+c);
}

thi
i

}

o/p:

ipa

a value=11

c value=23

Ma

b value=12

=======================================================

Ve
nk
ate
sh

Assignment-1:

wap to display the following:
int empId

int empPhNo
int empSal

float totSal = empSal+(0.93F*empSal)+(0.63F*empSal);

Assignment-2:

wap to display the following:
int s1
int s2

...
int s6
int totMarks =
float per =

Ve
nk
ate
sh

Ma

ipa

thi
i

========================================================

Dt : 31/3/2023
*imp
DataTypes in Java:
=>The types of data which we are expecting as input to

=>Datatypes in Java are categorized into two types:
1.Primitive datatypes

Ma

1.Primitive datatypes:

ipa

2.NonPrimitive datatypes

thi
i

JavaPrograms are known as Datatypes in Java.

=>The "Single valued data formats" are known as Primitive

Ve
nk
ate
sh

datatypes.

=>Primitive datatypes are categorized into four types:
(a)Integer datatypes
(b)Float datatypes

(c)Character datatype
(d)Boolean datatype

(a)Integer datatypes:

=>The numeric data without decimal point representation are
known as Integer datatypes.
=>Integer datatypes are categorized into four types:

(i)byte - 1 byte(8 bits)
(ii)short - 2 bytes
(iii)int - 4 bytes
(iv)long - 8 bytes

Multi-media data.
=>"int" datatype is used in normal programming.

thi
i

=>"byte" and "short" datatypes are used for stream-data or

ipa

=>"long" datatype is used to hold lagest numeric value without

Ma

decimal point,which means holding PhoneNO,CardNo,...

=>In the process of assigning long-data-value we must use "L"
(or) "l" in the RHS of declaration.

Ve
nk
ate
sh

Ex:

long p = 9898981234L;

(b)Float datatypes:

=>The numeric data with decimal point representation are known

as Float datatypes.

=>Float datatypes are categorized into two types:
(i)float - 4 bytes

(ii)double - 8 bytes
=>"float" datatype is used in normal programming.
=>"double" datatype is used to hold lagest scientic calculated

values
=>In the process of assigning float-data-value we must use "F"
(or) "f" in the RHS of declaration.
Ex:

thi
i

float k = 123.56F;

(c)Character datatype:

Ex:
'h','y','k',...

Ve
nk
ate
sh

=>Types:

Ma

quotes is known as Character datatype.

ipa

=>The "single valued character" which is represented in single

char - 2 bytes

(d)Boolean datatype:

=>The datatype which is represented in the form of true or false

is known as Boolean datatype.
=>Types:

boolean - 1 bit

--------------------------------------------Ex-program:

DataTypes1.java
class DataTypes1
{
public static void main(String args[])

thi
i

{
byte b = 127;
short s = 32767;

ipa

int i = 45673467;

float k = 123.56F;
double z = 2345.67;

Ve
nk
ate
sh

char ch = 'h';

Ma

long p = 9898981234L;

boolean bl = true;

System.out.println("byte value="+b);

System.out.println("short value="+s);
System.out.println("int value="+i);

System.out.println("long value="+p);

System.out.println("float value="+k);

System.out.println("double value="+z);
System.out.println("char value="+ch);

System.out.println("boolean value="+bl);
}

}
o/p:
byte value=127
short value=32767

thi
i

int value=45673467
long value=9898981234
float value=123.56

ipa

double value=2345.67

boolean value=true

Ma

char value=h

========================================================

Ve
nk
ate
sh

*imp

2.NonPrimitive datatypes:

=>The "Group valued data formats" are known as NonPrimitive

datatypes or Referential datatypes.

=>These NonPrimitive datatypes are categorized into four types:
(a)Class

(b)Interface
(c)Array

(d)Enum
==========================================================
faq:

define "String" datatype?
=>In Java,"String" is a Pre-defined class from JavaLib and which
is NonPrimitive datatype or Referential data type.

=>The string-data is represented in double quotes
Ex:

ipa

String city = "hyd";

Ma

String branch = "CSE";
String name = "Alex";

thi
i

Note:

============================================================

Ve
nk
ate
sh

Assignment:

wap to display UserDetails?
userName
passWord
firstName
lastName
hNo

sName
city
state

pinCode

mailId
phNo

Ve
nk
ate
sh

Ma

ipa

thi
i

=============================================================

Dt : 1/4/2023
Assignment:(Solution)
wap to display UserDetails?

{
public static void main(String args[])

String userName="nit.v";
String passWord="mzu672";

Ve
nk
ate
sh

String firstName="Raj";

Ma

{

ipa

class UserDetails

thi
i

Prog : UserDetails.java

String lastName="Kumar";
String hNo="12-34/h";

String sName="SR-Nagar";
String city="Hyd";
String state="TS";

int pinCode=612345;

String mailId="raj@gmail.com";
long phNo=9898981234L;

System.out.println("****UserDetails****");
System.out.println("UName="+userName);

System.out.println("PWord="+passWord);
System.out.println("FName="+firstName);
System.out.println("LName="+lastName);
System.out.println("HNO="+hNo);

System.out.println("State="+state);
System.out.println("PinCode="+pinCode);

Ma

System.out.println("MailId="+mailId);
System.out.println("PhoneNO="+phNo);
}

Ve
nk
ate
sh

}

o/p:

****UserDetails****
UName=nit.v

PWord=mzu672
FName=Raj

LName=Kumar
HNO=12-34/h

StreetName=SR-Nagar
City=Hyd
State=TS

ipa

System.out.println("City="+city);

thi
i

System.out.println("StreetName="+sName);

PinCode=612345
MailId=raj@gmail.com
PhoneNO=9898981234
=============================================================

thi
i

faq:
wt is the diff b/w
(i)print()

Ma

(i)print():

ipa

(ii)println()

=>print() method will display the data and the cursor waits in

Ve
nk
ate
sh

the same line.

(ii)println():

=>println() method also display the data,but the cursor moved
to the new line or next line.

=========================================================
Note:

=>"+" symbol in print() method will specify concatenating msg with

result.

=========================================================
Assignment:
wap to display CustomerDetails?

custId
accNo
custName
balance

thi
i

accType
hNo
sName

ipa

city

pinCode
mailId

Ve
nk
ate
sh

phNo

Ma

state

==========================================================

Dt : 4/4/2023
*imp
Methods in Java:
=>Methods are the actions which are executed to generate results.

thi
i

=>Based on "static" keyword the methods are categorized into
two types:
1.static methods

Ma

1.static methods:

ipa

2.NonStatic methods

=>The methods which are declared with "static" keyword are known

Ve
nk
ate
sh

as static methods.

=>These static methods will get the memory within the class

while class loading and can be accessed with Class_name.

structure of "static" method:

static return_type method_name(para_list)
{

//method_body

}

Coding Rule:

=>Static methods can access static variables from the same class
directly,but cannot access Instance variables directly.
------------------------------------=>These static methods are categorized into two types:

thi
i

(i)pre-defined static methods
(ii)User defined static methods

ipa

(i)pre-defined static methods:

Ma

=>The static methods which are ready constructed and available
from JavaLib are known as pre-defined static methods or Built-in

Ve
nk
ate
sh

static methods.

(ii)User defined static methods:

=>The static methods which are defined by the programmer are

known as User defined static methods.

====================================================

2.NonStatic methods:

=>The methods which are declared without "static" keyword are

known as NonStatic methods.

=>These NonStatic methods are known as Instance methods,because
there are no Local methods.
=>These Instance methods will get the memory within the object

while Object creation process and can be accessed with Object_name.

structure of instance methods:

thi
i

return_type method_name(para_list)
{
//method_body

Coding Rule:

Ma

ipa

}

=>Instance methods can access both "Instance variables and Static

Ve
nk
ate
sh

variables" directly.

(Object generated from the class,which means object belongs to
class and members of Object can access members of class directly)
------------------------------------------------------

=>These Instance methods are categorized into two types:
(i)Pre-defined Instance methods

(ii)User defined Instance methods

(i)Pre-defined Instance methods:
=>The Instance methods which are ready constructed and available
from JavaLib are known as Pre-defined Instance methods or Built-in

Instance methods

(ii)User defined Instance methods:
=>The Instance methods which are defined by the programmer are

thi
i

known as User defined Instance methods.
=========================================================
EX : DemoMethods1.java

ipa

class DemoMethods1

static int x=10;
int y=20;

Ve
nk
ate
sh

static void dis1()

Ma

{

{

int z = 200;

System.out.println("****dis1()****");
System.out.println("x value="+x);
System.out.println("z value="+z);

}

void dis2()
{

int z=300;
System.out.println("****dis2()****");

System.out.println("x value="+x);
System.out.println("y value="+y);
System.out.println("z value="+z);
}

thi
i

public static void main(String args[])
{
int z = 100;

ipa

DemoMethods1.dis1();

ob.dis2();

Ma

DemoMethods1 ob = new DemoMethods1();

System.out.println("****main()***");

Ve
nk
ate
sh

System.out.println("z value="+z);

}

}

o/p:

****dis1()****
x value=10

z value=200
****dis2()****
x value=10

y value=20
z value=300
****main()***

thi
i

z value=100

=====================================================

Ve
nk
ate
sh

Ma

ipa

Diagram:

======================================================

Dt:6/4/2023
Assignment : (Solution)
EmployeeData.java
class EmployeeData

static String id="A121",name="Alex",desg="SE";
String mailId="alex@gmail.com";

ipa

long phNo=9898981234L;

thi
i

{

Ma

static void dis1()
{

System.out.println("---details----");

Ve
nk
ate
sh

System.out.println("EmpId="+id);

System.out.println("EmpName="+name);
System.out.println("EmpDesg="+desg);

}

void dis2()
{

System.out.println("----ContactDetails----");
System.out.println("EmpMailId="+mailId);
System.out.println("EmpPhoneNo="+phNo);

}
public static void main(String[] args)

{
EmployeeData.dis1();
EmployeeData ob = new EmployeeData();
ob.dis2();

thi
i

}
}
o/p:

ipa

---details----

EmpName=Alex
EmpDesg=SE

Ve
nk
ate
sh

----ContactDetails----

Ma

EmpId=A121

EmpMailId=alex@gmail.com
EmpPhoneNo=9898981234

==========================================================

Note:

=>In the process of costructing applications in Java,we write

SubClasses and MainClass

SubClasses - The classes which are declared in applications
other than MainClass are known as SubClases
- Applications can be declared with any number of
SubClasses

MainClass - The class in the application which is declared
with main() method is known as MainClass.
- Application must be declared with only one

Ve
nk
ate
sh

Ma

ipa

thi
i

MainClass

=============================================================
*imp
"Scanner" class:

=>"Scanner" is a Pre-defined Built-in class from "util"(utility)
package of JavaLib.
=>"Scanner" class will provide pre-defined Built-in instance
methods to read data into JavaProgram.

thi
i

=>The following are some important instance methods of "Scanner"
class:
nextByte() - to read byte data

ipa

nextShort() - to read short data

nextLong() - to read long data
nextFloat() - to read float data

Ma

nextInt() - to read int data

Ve
nk
ate
sh

nextDouble() - to read double data

nextBoolean()- to read boolean data
nextLine() - to read String data

=>To access these instance methods,we must create object for

"Scanner" class.

syntax of Object creation for Scanner:
Scanner s = new Scanner(System.in);

=>"System.in" in java represent connecting Console-input to Scanner
class Object.
----------------------------------------------------Ex-program:

wap to read two integer values and display the average?

Prog : DemoMethods2.java(MainClass)
import java.util.Scanner;

thi
i

class Average
{
float avg(int x,int y)

ipa

{

return z;
}

Ve
nk
ate
sh

}

Ma

float z = (float)(x+y)/2;

class DemoMethods2
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
Average ob = new Average();

System.out.println("Enter the int value-1:");

int v1 = s.nextInt();
System.out.println("Enter the int value-2:");
int v2 = s.nextInt();

float res=ob.avg(v1,v2);
System.out.println("Average="+res);
}
}

thi
i

o/p:
Enter the int value-1:
7

ipa

Enter the int value-2:

Average=4.5

Ma

2

Ve
nk
ate
sh

======================================================

Dt : 25/3/2023(Day-5)
faq:
define High Level Languages?
=>The language programs which are constructed from the format

thi
i

which is understandable by the users,are known as High Level
languages
Ex:

define Low Level Languages?

Ma

faq:

ipa

C,C++,Java

Ve
nk
ate
sh

=>The Language programs which are constructed from the format

which is not understandable by the users,are known as Low Level
Languages.
Ex:

Machine Languages

faq:

define Translators?

=>Translators are used to translate High Level Language formats
into Low Level Language formats and Low Level Language formats into
High Level Language formats

=>These Translators are categorized into two types:
(i)Compilers

- translates the total program at-a-time

Ve
nk
ate
sh

Ma

ipa

thi
i

(ii)Interpreters - translates the program line-by-line

==============================================================
*imp
History of Java:
"James Gosling" - Sun Micro Systems - 1991 - Code Writer(Programmer)

WORA - Write Once and Run Anywhere
Virtual Machine

thi
i

Test.gt (Green Talk)

ipa

OAK

1995

Ma

"SILK" "DNA" ... "JAVA"

Ve
nk
ate
sh

--------------------------------------------------

Java Versions:

1995 - Java Alpha&Beta
1996 - JDK 1.0
1997 - JDK 1.1
1998 - JDK 1.2
2000 - JDK 1.3
2002 - JDK 1.4

----------------------------2004 - Java5
2006 - Java6

2011 - Java7
2014 - Java8
2017 - Java9
2018 - Java10,Java11

thi
i

2019 - Java12,Java13
2020 - Java14,Java15
2021 - Java16,Java17

ipa

2022 - Java18,Java19

Ma

2023 - Java20(March 21st)

=====================================================
LTS(Long Term Support) products:

Ve
nk
ate
sh

Java8

Java11
Java17

======================================================

Dt : 28/3/2023
*imp
Installing Java s/w and Setting path:

thi
i

step-1 : Download Java s/w(JDK) from Oracle WebSite

step-2 : Install JDK(Java s/w)

Ve
nk
ate
sh

Note:

Ma

ipa

https://www.oracle.com/in/java/technologies/downloads/

=>After installation process is successfull,we can find one

folder with name "java" in "programfiles"
C:\Program Files\Java

step-3 : Set Java path in "Environment Variables"

RightClick on MyComputer->Properties->Advanced System Settings->
Environment Variables->Click "new" from System Variables,

Variable name : path

Variable value : C:\Program Files\Java\jdk-17.0.4.1\bin;

step-4 : Click "ok" for three times
===========================================================

thi
i

Note:
=>Open CommandPrompt and check the following commands are working

javac - Command for Compilation process

Ma

java - Command Execution process

ipa

or not:

=============================================================
Note:

Ve
nk
ate
sh

=>Use the following syntax in CommandPrompt to know the Version

available in ComputerSystem:
java -version

============================================================
*imp

Writing,Saving,Compiling and Executing Java program:
=>In Java language writing program means constructing "class".

define "class"?
=>class in Java is a "Structured layout" generating "Objects".
=>Class in Java is a Collection of Variables,Methods,Blocks,

Constructors and main()
=>we use "class" keyword in Java to construct Classes

thi
i

structure of "class" in Java:

class Class_name
{

ipa

Variables

Blocks
Constructors

Ve
nk
ate
sh

main()

Ma

Methods

}

=>main() in Java will have the following pre-defined built-in

format:

public static void main(String args[])

--------------------------------------------------------

Ex-program :
Wap to display the msg as "Welcome to Java"?

class Display
{
public static void main(String args[])
{

thi
i

System.out.print("Welcome to Java");
}
}

Ve
nk
ate
sh

Ma

ipa

=======================================================

Dt : 30/3/2023
faq:
define Environment Variables?
=>The variables part of OperatingSystem holding information about softwares

thi
i

installed in ComputerSystem are known as "Environment Variables"
=>These Environment Variables are categorized into two types:
(i)User Variables

Ma

(i)User Variables:

ipa

(ii)System Variables

=>The variables which are related to individual users of ComputerSystem

Ve
nk
ate
sh

are known as User Variables.

=>The information available in User variables can be used by only the

indvidual User.

(ii)System Variables:

=>The variables which are related to ComputerSystem are known as System

Variables.

=>The information available in System Variables can be used by all users

of ComputerSystem.
===================================================================
===

faq:
wt is the advantage of having JavaPath in Environment Variables?
=>When we have JavaPath in Environment Variables,then we can Compile and
Execute Java Programs from any location of ComputerSystem.

thi
i

===================================================================
====

Ve
nk
ate
sh

Ma

ipa

Diagram:

===================================================================
====
Flow of Syllabus Content:

1.Naming Conventions in Java
2.Datatypes in Java
3.Variables in Java

4.Methods in Java
5.JVM Architecture with internals
6.Constructors in Java
7.Blocks in Java

thi
i

8.Packages in Java
9.Creating Java Project using IDE
10.Relations in Java(Introduction)

ipa

11.References in Java

13.Interfaces in Java
14.AbstractClasses in Java

Ve
nk
ate
sh

15.InnerClasses in Java

Ma

12.Inheritance in Java

16.PolyMorphism in Java

17.Conclusion of Object Oriented features
(Abstraction and Encapsulation)

18.Exception Handling in Java
19.String in Java

20.WrapperClasses in Java
21.Arrays in Java

22.Java Collection Framework
(Data structures in Java)
23.Enum in Java

24.MultiThreading in Java
25.IO Streams and Files in Java
26.Networking in Java
27.Introduction GUI Programming

thi
i

28.Object Class(Object Cloning)
29.Conclusion

======================================================

ipa

*imp

Ma

Naming Conventions in Java:

=>The rules followed by the programmer in writing Java Programs are

Ve
nk
ate
sh

known as Naming Conventions in Java.

packages :

def : packages are collection of "Classes and Interfaces".
rule : packages must be in LowerCase.

Classes and Interfaces:

def : Classes and Interfaces are collection of "Variables and Methods"

rule : In Classes and Interfaces the starting letter of every word must
be Capital letter or UpperCase.
Ex:
InputStream

InputStreamReader

Variables and Methods:
def : Variables are data holders and Methods are actions

thi
i

rule : In Variables and Methods the first word must be lowercase and
from second word onwards the starting letter must be capital
Ex-Variables:

ipa

panCardNo

Ex-Methods:
getSalary()

Ve
nk
ate
sh

calculateTot()

Ma

rollNo

Keywords :

def : Pre-defined Built-in words are known as Keywords

rule : Keywords must be LowerCase
Ex:

static
void

public
class
...

===================================================================
==
faq:
define Identifiers?
=>The names which are used to identify the programming components are

thi
i

known as Identifiers.

Ve
nk
ate
sh

Ma

ipa

===================================================================
=

5/20/23, 9:44 AM

6 PM CoreJava145-Dia1.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:45 AM

6 PM CoreJava146-Dia3.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:46 AM

6 PM CoreJava146-Dia5.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:46 AM

6 PM CoreJava146-Dia7.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:47 AM

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

Methods1.png

1/1

5/20/23, 9:47 AM

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

Methods3.png

1/1

5/20/23, 9:48 AM

6 PM CoreJava146-Dia2.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:48 AM

6 PM CoreJava146-Dia4.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:49 AM

6 PM CoreJava146-Dia8.png

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

1/1

5/20/23, 9:49 AM

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NTE4NDYwOTQ2NjY3/details

Methods2.png

1/1

Dt : 7/4/2023
*imp
JVM Architecture with Internals:
=>JVM stands for "Java Virtual Machine" and which is used to

thi
i

execute Java Byte Code.
=>This JVM internally divided into the following partitions:
1.Class Loader SubSystem

ipa

2.Runtime DataArea

Ve
nk
ate
sh

Diagram:

Ma

3.Execution Engine

thi
i
ipa
Ma
Ve
nk
ate
sh
1.Class Loader SubSystem:

=>The Class Loader SubSystem will load the Class-file onto
Runtime Data Area for execution.

2.Runtime DataArea:
=>This Runtime DataArea internally divided into the following
partitions:
(a)Method Area

thi
i

(b)Heap Area
(c)Java Stack Area
(d)PC Register Area

Ma

(a)Method Area:

ipa

(e)Native Method Area

Ve
nk
ate
sh

=>The partition of Runtime DataArea where classes are loaded
is known as Method Area.

=>Static members of class will get the memory within the class
while Class loading.

=>when MainClass is loaded,main() method will get the memory
within the class and automatically copied onto Java Stack
Area to start execution process.

(b)Heap Area:
=>The patition of Runtime DataArea where the Objects are created
is known as Heap Area.

=>while Object creation,Instance members of class will get the
memory within the object.

(c)Java Stack Area:

executed is known as Java Stack Area.

thi
i

=>The partition of Runtime DataArea where the methods are

=>The main() method is copied onto Java Stack Area first and

Ma

remaining methods for execution.

ipa

starts the execution process,and this main() method will call

Ve
nk
ate
sh

Execution flow of DemoMethods2.java:

thi
i
ipa
Ma
Ve
nk
ate
sh

========================================================

Assignment:

wap to read two integer values and display greater value?

SubClass : Greater
=>int generate(int x,int y)

MainClass: DemoMethods3

Note:
=>Draw the execution flow

Ve
nk
ate
sh

Ma

ipa

thi
i

===================================================

Dt : 8/4/2023
faq:
wt is the diff b/w
(i)Object

thi
i

(ii)Object reference
(iii)Object reference Variable

ipa

(i)Object:

Object.

Ve
nk
ate
sh

(ii)Object reference:

Ma

=>The memory which is created part of HeapArea is known as

=>The address of object is known as Object reference.

(iii)Object reference Variable:

=>The variable which is holding Object reference is known as
Object reference variable or Object name.

Diagrams:

thi
i
ipa

======================================================

Ma

define Object?(revised)

=>Object is a storage related to a class created in Heap Area of
JVM holding instance members of class.

Ve
nk
ate
sh

========================================================
faq:

define Method Frame?

=>The partition of Java Stack Area where method is copied for

execution is known as Method Frame.

=>After method execution completed,the method frame will be

destroyed automatically.

=======================================================

Note:
List of variables from the above application:
Primitive datatype variables : v1,v2,res,x,y,z

NonPrimitive datatype variables : s,ob

All variables declared in the application are Local variables:
avg() - x,y,z

thi
i

main() - s,ob,v1,v2,res

ipa

List of parameters : v1,v2,x,y

Ma

Types of parameters:

=>Parameters are categorized into two types:
(i)Actual Parameters

Ve
nk
ate
sh

(ii)Formal Parameters

(i)Actual Parameters:

=>The variables which hold original input data and used in

method call are known as Actual Parameters.

(ii)Formal Parameters:

=>The variables which hold intermediate data and used in method

signatures are known as Formal parameters.
=>These Formal parameters are used in calculations.

Note:
=>we can take same names in Actual parameters and formal
parameters
=>All parameters are variables,but all variables are not

thi
i

parameters
===========================================================
Assignment:

SubClass : Percentage

Ma

ipa

wap to read 6 sub marks and display the percentage?

Ve
nk
ate
sh

=>float calculate(int totMarks)

MainClass : DemoMethods4

===========================================================

Dt : 10/4/2023
*imp
Operators in Java:
=>Operators are the special symbols which perform operations.

1.Arithmetic Operators
2.Relational Operator
3.Logical Operators

1.Arithmetic Operators:

Ma

4.Increment-Decrement Operators

ipa

thi
i

=>The following are some important operators in Java:

Ve
nk
ate
sh

=>The operators which perform basic operations are known as

Arithmetic Operators.

Operator Meaning
+

Addition

-

Subtraction

*

Multiplication

/

Division

%

ModDivision

Ex:

a=7 b=2
a+b = 7+2 = 9
a-b = 7-2 = 5
a*b = 7*2 = 14

thi
i

a/b = 7/2 = 3
a%b = 7%2 = 1

ipa

2.Relational Operator:

as Reational Operators.

Ve
nk
ate
sh

Operator Meaning

Ma

=>The operators which are used to perform comparisions are known

>

Greater Than

>=

Greater Than or equal to

<

Less Than

<=

Less Than or equal to

==

Is equal to

!=

Not Equal to

3.Logical Operators:
=>The operators which are used to compare two comparisions are
known as Logical Operators.

Operator Meaning
Logical AND

||

Logical OR

!

Logical NoT

thi
i

&&

A B A&&B

ipa

T T T

T F F

Ve
nk
ate
sh

F F F

Ma

F T F

A B A||B
T T T
F T T
T F T
F F F

A !A
T F
F T

4.Increment-Decrement Operators:
=>Increment Operators will increment the value by 1 and decrement
operators will decrement the value by 1.

++

Increment

--

Decrement

thi
i

Operator Meaning

ipa

============================================================

Control Structures in Java:

Ma

*imp

=>The structures whih decide the execution-flow of program are

Ve
nk
ate
sh

known as Control Structures.

=>These Control Structures are categorized into three types:
1.Selection statements
2.Iterative statements

3.Branching Statements

1.Selection statements:

=>The statements which are used to select one part of the program

for execution are known as Selection Statements or Conditional
Statements.
=>Types:

(a)Simple if
(b)if-else
(c)Nested if(Inner if)
(d)Ladder if-else

thi
i

(e)switch-case

2.Iterative statements:

ipa

=>The statements which are used to execute some lines of program

statements or looping Structures.
=>Types:

Ve
nk
ate
sh

(a)while loop

Ma

repeatedly are known as Iterative Statements or Repeatitive

(b)do-while loop
(c)for loop

3.Branching Statements:

=>The statements which are used to transfer the execution control

from one location to another location are known as Branching
Statements or Transfer Statements
=>Types:
(a)break
(b)continue

(c)return
(d)exit
Note:
=>"goto" not available in Java

thi
i

================================================================
Assignment:(Solution)

wap to read two integer values and display greater value?

ipa

SubClass : Greater

MainClass: DemoMethods3
import java.util.Scanner;

Ve
nk
ate
sh

class Greater

Ma

=>int generate(int x,int y)

{

int generate(int x,int y)
{

if(x>y)
{

return x;
}

else
{
return y;

}
}
}
class DemoMethods3

public static void main(String[] args)
{

ipa

Scanner s = new Scanner(System.in);

thi
i

{

int v1 = s.nextInt();

Ma

System.out.println("Enter int value-1:");

System.out.println("Enter int value-2:");

Ve
nk
ate
sh

int v2 = s.nextInt();

Greater gt = new Greater();

int res = gt.generate(v1,v2);

System.out.println("GreaterValue:"+res);

}

}

o/p:

Enter int value-1:
123
Enter int value-2:
120

GreaterValue:123
===================================================
Ex-program:
wap to read two integer values and perform arithmetic operation

thi
i

based on User Choice?
1.add
2.sub

ipa

3.mul

5.modDiv

Ve
nk
ate
sh

Program : DemoMethods5.java

Ma

4.div

import java.util.Scanner;
class Addition
{

int add(int x,int y)
{

return x+y;

}

}
class Subtraction
{

int sub(int x,int y)
{
return x-y;
}

thi
i

}
class Multiplication
{

ipa

int mul(int x,int y)

return x*y;
}

Ve
nk
ate
sh

}

Ma

{

class Division
{

float div(int x,int y)
{

return (float)x/y;

}

}

class ModDivision
{
int modDiv(int x,int y)

{
return x%y;
}
}

thi
i

class DemoMethods5
{
public static void main(String[] args)

ipa

{

Ma

Scanner s = new Scanner(System.in);

System.out.println("Enter int value-1:");
int v1 = s.nextInt();

Ve
nk
ate
sh

System.out.println("Enter int value-2:");
int v2 = s.nextInt();

System.out.println("*****Choice****");

System.out.println("\t1.add\n\t2.sub\n\t3.mul\n\t4.div\n\t5.modDiv");
System.out.println("Enter the Choice:");
int choice = s.nextInt();
switch(choice)
{
case 1:
Addition ad = new Addition();

int r1 = ad.add(v1,v2);
System.out.println("Sum:"+r1);
break;
case 2:

int r2 = sb.sub(v1,v2);
System.out.println("Sub:"+r2);

ipa

break;

thi
i

Subtraction sb = new Subtraction();

Ma

case 3:

Multiplication ml = new Multiplication();
int r3 = ml.mul(v1,v2);

Ve
nk
ate
sh

System.out.println("Mul:"+r3);
break;

case 4:

Division dv = new Division();

float r4 = dv.div(v1,v2);

System.out.println("Div:"+r4);
break;

case 5:

ModDivision md = new ModDivision();
int r5 = md.modDiv(v1,v2);
System.out.println("ModDiv:"+r5);

break;
default:
System.out.println("Invalid Choice...");
}//end of switch

thi
i

}

Ve
nk
ate
sh

Ma

ipa

}

o/p:

Enter int value-1:
7

Enter int value-2:
2

*****Choice****
1.add
2.sub
3.mul
4.div

5.modDiv
Enter the Choice:
5
ModDiv:1

Ve
nk
ate
sh

Ma

ipa

thi
i

====================================================

ASSIGNMENT-1
Program-1
Define a method which returns the 1 if the given number is even, in other case return 0
Name of method: isEven() // which accepts an integer value as argument and return 1 if the
given number is even, else retrun 0.
Argument: int
Return type: an integer value
Example, if x = 22, return 1. if x = 35, return 0
Program-2
Define a method which returns the greatest number among two numbers.
Write the method with the following specifications:
Name of method: getGreatest() // which accepts two integer values as argument and return
the greatest value.
Arguments: two argument of type integer
Return type: an integer value
Specifications: The value returned by the method getGreatest() is determined by the following
rules:
If any of the given numbers are negative, return -1.
If any of the given numbers are zero, return -2.
If the given numbers are positive, return the greatest.
Program-3
Define a method which returns the least number among two numbers.
Write the method with the following specifications:
Name of method: getLeastNum() // which accepts two integer values as argument and return
the least value.
Arguments: two argument of type integer
Return type: an integer value
Specifications: The value returned by the method getLeastNum() is determined by the
following rules:
If any of the given numbers are negative, return -1.
If any of the given numbers are zero, return -2.
If the given numbers are positive, return the least number.
Program-4
Define a method which returns the number it if it is an even number, if the number is odd then
return the next multiple of 10.
Write the method with the following specifications:
Name of method: oddRounder() // which accepts an integer value as argument and return
the same value if it is an even number, if the value is odd then return the next multiple of 10.
Arguments: one argument of type integer
Return Type: an integer value
Example if x = 24 then return 24, if x = 25 then return 30.
Specifications: The value returned by the method oddRounder() is determined by the
following rules:

If any of the given number is negative, return -1.
If any of the given number is zero, return -2.
If the given number is even, return the same number.
If the given number is odd, return the next multiple of 10.
Program-5
Define a method which returns the 1 if the given number is positive, return -1 if the given
number is negative, return 0 if the given number is 0.
Name of method findSign()
Arguments: one argument of type integer
Return Type: an integer value
Test Cases
1. If any of the given number is positive, return 1.
2. If any of the given number is negative, return -1.
3. If any of the given number is zero, return 0.

Dt : 11/4/2023
faq:
define switch-case statement?
=>switch-case statement is used to select one from multiple

thi
i

options or cases

syntax:

ipa

switch(value)

case 1 : statements;
break;

Ve
nk
ate
sh

case 2 : statements;

Ma

{

break;
...

case n : statements;
break;

default : statements;

}

EXecution behaviour:
=>switch-value is compared with the available options or cases
and,if any case matched with switch-value then the statements are

executed.
=>After executing statements the switch-case execution is stopped
using "break".
============================================================

thi
i

Assignment:
wap to read two integer values and perform the following based on
User-choice:

ipa

1.GreaterValue

Ma

2.SmallerValue

SubClasses : GreaterValue,SmallerValue

Ve
nk
ate
sh

MainClass : DemoMethods

==============================================================
*imp

Iterative Statements:
(a)while loop

(b)do-while loop
(c)for loop

(a)while loop:
=>In while looping structure the condition is checked first and
if the condition is true then loop_body is executed,this process is

repeated until the condition is false.

syntax:
while(condition)

thi
i

{
//loop_body

ipa

}

Ve
nk
ate
sh

Ma

Flowchart:

Assignment:(Solution)
wap to read 6 sub marks and display the percentage?

SubClass : Percentage

thi
i

=>float calculate(int totMarks)

MainClass : DemoMethods4

ipa

import java.util.Scanner;

{
float calculate(int totMarks)

Ve
nk
ate
sh

{

Ma

class Percentage

return (float)totMarks/6;

}

}

class DemoMethods4
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
int i=1,totM=0;
while(i<=6)

{
System.out.println("Enter Marks of Subject-"+i);
int sub = s.nextInt();
if(sub<0 || sub>100)

thi
i

{
System.out.println("Invalid Marks...");

}

Ma

totM = totM+sub;

ipa

continue;//skip the below lines from the iteration

System.out.println("subject:"+sub);
i++;

Ve
nk
ate
sh

}//end of loop

System.out.println("TotalMarks:"+totM);
Percentage pr = new Percentage();
float per = pr.calculate(totM);

System.out.println("Percentage:"+per);

}

}

o/p:
Enter Marks of Subject-1

90
subject:90
Enter Marks of Subject-2
150

thi
i

Invalid Marks...
Enter Marks of Subject-2
50

ipa

subject:50

-12
Invalid Marks...

Ve
nk
ate
sh

Enter Marks of Subject-3

Ma

Enter Marks of Subject-3

67

subject:67

Enter Marks of Subject-4
53

subject:53

Enter Marks of Subject-5
89

subject:89
Enter Marks of Subject-6
90

subject:90
TotalMarks:439
Percentage:73.166664
===========================================================

thi
i

Assignment:
Update above program by display the grade of an Student?

ipa

per=>

60 to <70 ---- Grade-B
50 to <60 ---- Grade-C

Ve
nk
ate
sh

35 to <50 ---- Grade-D

Ma

70 to 100 ---- Grade-A

else ---- Fail

SubClass : Grade

=>String gr(float per)

Note:

=>If any Sub Marks enterted in b/w 0 to 34,then Grade must be

"Fail"

=============================================================
(b)do-while loop:
=>In do-while looping Structure,the loop_body is executed first

and then the Condition is checked,this process is repeated until
the condition is false.

syntax:

thi
i

do
{
//loop_body

ipa

}

Ve
nk
ate
sh

Flowchart:

Ma

while(condition);

thi
i
ipa
Ma
Ve
nk
ate
sh

==========================================================
*imp

(c)for loop:

=>for-loop is more simple in representation when compared to
while and do-while loops,because Initialization,Condition and
Increment or Decrement declared in the same line.

syntax:
for(Initialization;Condition;Incre/Decre)
{

thi
i

//Loop_body
}

Ve
nk
ate
sh

Ma

ipa

Flowchart:

============================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 12/4/2023
Assignment:(Solution)
wap to read two integer values and perform the following based on
User-choice:

SubClasses : GreaterValue,SmallerValue

import java.util.Scanner;
class GreaterValue

Ve
nk
ate
sh

{

Ma

MainClass : DemoMethods6

int greater(int x,int y)
{

if(x>y)
{

return x;

}

else
{

return y;
}

ipa

2.SmallerValue

thi
i

1.GreaterValue

}
}
class SmallerValue
{

thi
i

int smaller(int x,int y)
{
if(x<y)

ipa

{

Ma

return x;
}
else

Ve
nk
ate
sh

{

return y;

}

}

}

class DemoMethods6
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
System.out.println("Enter int value-1:");

int v1 = s.nextInt();
System.out.println("Enter int value-2:");
int v2 = s.nextInt();
System.out.println("****Choice****");

System.out.println("Enter the Choice:");
int choice = s.nextInt();

ipa

switch(choice)

Ma

{
case 1:

thi
i

System.out.println("1.GreaterVlaue\n2.SmallerValue");

GreaterValue gv = new GreaterValue();

Ve
nk
ate
sh

int r1 = gv.greater(v1,v2);

System.out.println("GreaterValue:"+r1);
break;

case 2:

SmallerValue sv = new SmallerValue();

int r2 = sv.smaller(v1,v2);
System.out.println("SmallerValue:"+r2);
break;

default:
System.out.println("Invalid Choice...");
}//end of switch

}
}

o/p:

thi
i

Enter int value-1:
12
Enter int value-2:

ipa

123

1.GreaterVlaue
2.SmallerValue

Ve
nk
ate
sh

Enter the Choice:

Ma

****Choice****

1

GreaterValue:123

==============================================================
Assignment:(Solution)

Update above program by display the grade of an Student?

per=>
70 to 100 ---- Grade-A
60 to <70 ---- Grade-B

50 to <60 ---- Grade-C
35 to <50 ---- Grade-D
else ---- Fail
SubClass : Grade

thi
i

=>String gr(float per)

Note:

ipa

=>If any Sub Marks enterted in b/w 0 to 34,then Grade must be

Ma

"Fail"

Ve
nk
ate
sh

Program : DemoMethods4.java(Modified)
import java.util.Scanner;
class Percentage
{

float calculate(int totMarks)
{

return (float)totMarks/6;

}

}
class Grade
{

String gr(float per)
{
if(per>=70 && per<=100)
{

else if(per>=60 && per<70)
{

Ma

return "Grade-B";
}

else if(per>=50 && per<60)

Ve
nk
ate
sh

{

return "Grade-C";

}

else if(per>=35 && per<50)
{

return "Grade-D";

}

else
{

return "Fail";
}

ipa

}

thi
i

return "Grade-A";

}
}
class DemoMethods4
{

{
Scanner s = new Scanner(System.in);

ipa

int i=1,totM=0;

thi
i

public static void main(String[] args)

Ma

boolean k=false;
while(i<=6)
{

Ve
nk
ate
sh

System.out.println("Enter Marks of Subject-"+i);
int sub = s.nextInt();

if(sub<0 || sub>100)
{

System.out.println("Invalid Marks...");
continue;//skip the below lines from the iteration

}

if(sub>=0 && sub<=34)
{

k=true;
}

totM = totM+sub;
System.out.println("subject:"+sub);
i++;
}//end of loop

Percentage pr = new Percentage();
float per = pr.calculate(totM);

ipa

System.out.println("Percentage:"+per);

thi
i

System.out.println("TotalMarks:"+totM);

Ma

if(k)
{

System.out.println("Result-Garde:Fail");

Ve
nk
ate
sh

}

else
{

Grade ob = new Grade();
String res = ob.gr(per);

System.out.println("Result-Garde:"+res);

}

}

}

o/p:

Enter Marks of Subject-1
78
subject:78
Enter Marks of Subject-2

thi
i

76
subject:76
Enter Marks of Subject-3

ipa

67

Enter Marks of Subject-4
64

Ve
nk
ate
sh

subject:64

Ma

subject:67

Enter Marks of Subject-5
56

subject:56

Enter Marks of Subject-6
9

subject:9

TotalMarks:350

Percentage:58.333332
Result-Garde:Fail
========================================================

Assignment:
wap to perform WithDraw process?

1.read pinNo

thi
i

=>The pinNo must be 4 digits,else "Invalid pinNo"
=>If the pinNo entered wrongly for three times then display the
msg as "Transaction blocked".

ipa

2.If the pinNo validated successfully,then read amt to WithDraw

"Invalid amt"

Ma

=>The amt must be greater than zero and multiples of 100,else

3.If the amt is validated Successfully,then the amt must be less

Ve
nk
ate
sh

than 2000/-,else "Insufficient Fund"

4.If the amt is less than 2000/- then perform the transaction
o/p:

Amt withdrawn :
Balance amt :

Transaction Successfull

SubClass : WithDraw

=>void wDraw(int amt)
=========>o/p
MainClass : DemoMethods

=========================================================
Ex-program:
wap to display the sum of n numbers?

thi
i

Condition : n>0

Program : DemoLoop1.java
import java.util.Scanner;

ipa

class Test1

int sum=0;
int add(int n)

Ve
nk
ate
sh

{

Ma

{

for(int i=1;i<=n;i++)
{

sum=sum+i;

}

return sum;

}

}

class DemoLoop1
{
public static void main(String[] args)

{
Scanner s = new Scanner(System.in);
System.out.println("Enter the value of n:");
int n = s.nextInt();

thi
i

if(n>0)
{

int res = ob.add(n);

ipa

Test1 ob = new Test1();

Ma

System.out.println("Sum:"+res);
}
else

Ve
nk
ate
sh

{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:
5

Sum:15
===========================================================
Assignment:

wap to read a number and display the factorial?
Condition : number>0
==========================================================
Assignment:

thi
i

wap to display the sum of even numbers from the given n value?
Condition : n>0

===========================================================

ipa

Assignment:

I/p: n=123

Ve
nk
ate
sh

O/p: sum = 1+2+3 + 6

Ma

wap to read a number and display the sum of digits?

Condition : number>0

==========================================================

==========================================================
Dt : 13/4/2023
Assignment:(Solution)
wap to read a number and display the factorial?

thi
i

Condition : number>0

Program : DemoLoop2.java

ipa

import java.util.Scanner;

{
int fact=1;

Ve
nk
ate
sh

int factorial(int n)

Ma

class Test2

{

for(int i=n;i>=1;i--)
{

fact=fact*i;
}

return fact;

}

}
class DemoLoop2
{

public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
System.out.println("Enter the value of n:");

thi
i

int n = s.nextInt();
if(n>0)

Test2 ob = new Test2();

Ma

int res = ob.factorial(n);

ipa

{

System.out.println("Factoral:"+res);
}

Ve
nk
ate
sh

else
{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:
4
Factoral:24

==========================================================

Assignment:(Solution)
wap to display the sum of even numbers from the given n value?
Condition : n>0

thi
i

Program : DemoLoop3.java
import java.util.Scanner;
class Test3

ipa

{

int add(int n)
{

Ve
nk
ate
sh

for(int i=1;i<=n;i++)

Ma

int sum=0;

{

if(i%2 == 0)
{

sum=sum+i;

}

}

return sum;

}
}
class DemoLoop3

{
public static void main(String[] args)
{
Scanner s = new Scanner(System.in);

thi
i

System.out.println("Enter the value of n:");
int n = s.nextInt();

{

Ma

Test3 ob = new Test3();

ipa

if(n>0)

int res = ob.add(n);

System.out.println("Sum of even number:"+res);

Ve
nk
ate
sh

}

else
{

System.out.println("Invalid input...");

}

}

}

o/p:

Enter the value of n:
10
Sum of even number:30

===========================================================
Assignment:(Solution)

thi
i

wap to read a number and display the sum of digits?

I/p: n=123

ipa

O/p: sum = 1+2+3 + 6

Program : DemoLoop4.java

Ve
nk
ate
sh

import java.util.Scanner;

Ma

Condition : number>0

class Test4
{

int sum=0;

int add(int n)
{

while(n>0)
{

int k=n%10;
sum=sum+k;
n=n/10;

}
return sum;
}
}

thi
i

class DemoLoop4
{
public static void main(String[] args)

ipa

{

Ma

Scanner s = new Scanner(System.in);

System.out.println("Enter the value of n:");
int n = s.nextInt();

Ve
nk
ate
sh

if(n>0)
{

Test4 ob = new Test4();
int res = ob.add(n);

System.out.println("Sum of digits:"+res);

}

else
{

System.out.println("Invalid input...");
}
}

}
o/p:
Enter the value of n:
1234

thi
i

Sum of digits:10
==========================================================
Assignment:

i/p : n=123
o/p : res=321

Ma

ipa

wap to read a number and display the reverse of given number?

Ve
nk
ate
sh

==========================================================
Assignment:

wap to read a number and display the sum of cubes of given number?

i/p:n=123

o/p:res = 1+8+27 = 36

==========================================================
Ex-program:

wap to read a number and check the number is Prime number or not?

Program : DemoLoop5.java

import java.util.Scanner;
class Test5
{
int count=0;

thi
i

int prime(int n)
{
for(int i=1;i<=n;i++)

ipa

{

{
count++;

Ve
nk
ate
sh

}

Ma

if(n%i == 0)

}

return count;

}

}

class DemoLoop5
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
System.out.println("Enter the value of n:");

int n = s.nextInt();
if(n>0)
{
Test5 ob = new Test5();

thi
i

int count = ob.prime(n);
if(count==2)
{

ipa

System.out.println("Prime number...");

else
{

Ma

}

Ve
nk
ate
sh

System.out.println("NotPrime...");

}

}

else
{

System.out.println("Invalid input...");

}

}

}
o/p:
Enter the value of n:

7
Prime number...
=======================================================
faq:

thi
i

wt is the diff b/w
(i)while loop

ipa

(ii)do-while loop

Ma

(i)while loop:

=>In while-loop,when the condition is true then the loop_body is
executed.

Ve
nk
ate
sh

(ii)do-while loop:

=>In do-while-loop,the loop_body is executed once for the false

condition,and which waste the execution time and degrades the
performance of an application.

======================================================

*imp

Constructors in Java:

=>Constructor is a special-method having the same name of the

class and executed while Object creation process,because the
constructor call is available in Object creation syntax attached
with "new" keyword.

=>while declaring constructors we must not use return_type
because the Constructor will have Class_return_type.

thi
i

structure of Constructor:

Class_name(para_list)
{

ipa

//method_body

----------------------------------------------

Ma

}

=>Based on parameters the constructors are categorized into two

Ve
nk
ate
sh

types:

1.Constructors without parameters
2.Constructors with parameters

1.Constructors without parameters:

=>The Constructors which are declared without parameters are

known as 0-parameter Constructors or Constructors without parameters

Ex-program : DemoCon1.java
class CTest1
{

int k=10;
CTest1()
{
System.out.println("****CTest1()****");

thi
i

System.out.println("The value k:"+k);
}
void dis()

ipa

{

Ma

System.out.println("****dis()****");

System.out.println("The value k:"+k);
}

Ve
nk
ate
sh

}

class DemoCon1
{

public static void main(String[] args)
{

CTest1 ob = new CTest1();//Con_call

ob.dis();//Method_call
}

}
o/p:
****CTest1()****

The value k:10
****dis()****
The value k:10

Ve
nk
ate
sh

Ma

ipa

thi
i

=================================================

Dt : 14/4/2023
Execution flow of above program:(DemoCon1.java)
ClassFiles:
CTest1.class

Ve
nk
ate
sh

Ma

ipa

thi
i

DemoCon1.class(MainClass)

================================================
faq:
wt is the diff b/w

(i)Constructor
(ii)Instance method

=>Constructor is executed while object creation,but Instance method

thi
i

is executed after object creation.
=>Costructor is an one-time executable component while object

creation process,but Instance method can be executed any number of

ipa

times after object creation.

faq:
define default Constructor?

Ma

============================================================

Ve
nk
ate
sh

=>The constructor without parameters,which is added by the

compiler at compilation stage is default constructor.

faq:

In wt situation default constructor is added?
=>when the compiler at compilation stage finds any class declared

without any constructors then default constructor is added.
===========================================================
faq:
define static Constructor?
=>There is no concept of static constructor in Java,because

constructor means executed while object creation process and which
cannot be Class_level_Component.(Compilation Error)

Ve
nk
ate
sh

Ma

ipa

thi
i

========================================================

Dt : 17/4/2023
2.Constructors with parameters:
=>The Constructors which are declared with parameters are known

thi
i

as Parameterized Constructors or Constructors with parameters.

Ex : DemoCon3.java
import java.util.Scanner;

ipa

class User

Ma

{
//Instance variables memory in Object
String uName,mId;

Ve
nk
ate
sh

long phNo;

//Constructor to initialize instance Variables
//a,b,c are Local variables of Constructor
User(String a,String b,long c)
{

uName=a;
mId=b;

phNo=c;
}

//Instance method memory in Object to display details
void getUser()
{
System.out.println("****UserDetails****");

System.out.println("MailId:"+mId);
System.out.println("PhoneNo:"+phNo);

ipa

}

class DemoCon3

Ma

}

{

thi
i

System.out.println("UserName:"+uName);

Ve
nk
ate
sh

public static void main(String[] args)
{

//s,uN,mId,pNo,ob are Local variables of main()
Scanner s = new Scanner(System.in);
System.out.println("Enter the UserName:");
String uN = s.nextLine();

System.out.println("Enter the MailId:");
String mId = s.nextLine();

System.out.println("Enter the PhoneNo:");
long pNo = s.nextLong();

User ob = new User(uN,mId,pNo);//Con_call
ob.getUser();//Method_call
}
}

thi
i

o/p:
Enter the UserName:
nit.v

ipa

Enter the MailId:

Enter the PhoneNo:
9898981234

Ve
nk
ate
sh

****UserDetails****

Ma

v@gmail.com

UserName:nit.v

MailId:v@gmail.com

PhoneNo:9898981234

--------------------------------------------------

Execution flow of above program:(Demonstrating parameterized Con)
ClassFiles:

User.class

DemoCon3.class(MainClass)

thi
i
ipa
Ma
Ve
nk
ate
sh

============================================================
*imp

Advantage of Constructors:

=>Constructors are used to initialize instance variables while

Object creation process ,and which saves the execution time and
generate HighPerformance of an application.
=============================================================
*imp

Loading data to Objects:
=>Loading data to objects can be done in three ways:
1.Using Constructor
2.Using Object reference variable

thi
i

3.Using "Setter" methods

1.Using Constructor:

ipa

=>Using Constructors we can load the data to objects while Object

Ex:
above program : DemoCon3.java

Ma

creation process.

Ve
nk
ate
sh

-------------------------------------------------------

2.Using Object reference variable:

=>We can also load the data to objects using Object name or

Object reference variable after Object creation process.

Ex : DemoCon4.java

import java.util.Scanner;
class Product
{

//Instance Variables memory in Object
String pId,pName;

//Instance method memory in Object
void getProduct()
{

System.out.println("ProdId:"+pId);
System.out.println("ProdName:"+pName);

ipa

}

class DemoCon4
{

Ma

}

Ve
nk
ate
sh

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);

Product p = new Product();//Con_call

System.out.println("Enter the ProdId:");

p.pId = s.nextLine();

System.out.println("Enter the ProdName:");
p.pName = s.nextLine();

p.getProduct();//method_call
}

thi
i

System.out.println("****ProductDetails****");

}
o/p:
Enter the ProdId:
A121

thi
i

Enter the ProdName:
Mouse
****ProductDetails****

ipa

ProdId:A121

Ve
nk
ate
sh

Diagram:

Ma

ProdName:Mouse

thi
i
ipa
Ma
Ve
nk
ate
sh
------------------------------------------

3.Using "Setter" methods:

=>We can also load the data to objects using "Setter methods"

after Object creation process.

faq:

define Setter methods?

=>The methods which are used to set the data to objects are known
as Setter methods.

faq:
define Getter methods?
=>The methods which are used to get the data from the objects are

Coding Rule of "Setter" and "Getter" methods:

thi
i

known as Getter methods.

=>Every variable in class will have its own Setter and Getter

Ex : DemoCon5.java
import java.util.Scanner;

Ve
nk
ate
sh

class Customer

Ma

ipa

methods.

{

//Instance variable memory in Object
String cId,cName;

//Setter methods

void setCId(String a)
{

cId=a;
}
void setCName(String b)

{
cName=b;
}

thi
i

//Getter methods
String getCId()
{

ipa

return cId;

String getCName()
{

Ve
nk
ate
sh

return cName;

Ma

}

}

}

class DemoCon5
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
Customer c = new Customer();//Con_call
System.out.println("Enter the CustId:");
String custId = s.nextLine();

c.setCId(custId);//Setter-method_Call
System.out.println("Enter the CustName:");
String custName = s.nextLine();

System.out.println("****CustomerDetails****");
System.out.println("CustId:"+c.getCId());

thi
i

c.setCName(custName);

ipa

System.out.println("CustName:"+c.getCName());

}
o/p:

Ve
nk
ate
sh

Enter the CustId:

Ma

}

A121

Enter the CustName:
Raj

****CustomerDetails****
CustId:A121

CustName:Raj

===========================================================

Assignment:
Read and display BookDetails using three process:
1.Using Constructor

2.Using Object reference variable
3.Using "Setter" methods

Ve
nk
ate
sh

Ma

ipa

thi
i

============================================================

Dt : 18/4/2023
Assignment:
Read and display BookDetails using three process:

thi
i

(Using "Setter" methods)

Program : DemoCon6.java
import java.util.Scanner;

ipa

class BookData

//Instance Variables
String code,name,author;

Ve
nk
ate
sh

float price;

Ma

{

int qty;

//Setter methods

void setCode(String code)
{

this.code=code;

}

void setName(String name)
{
this.name=name;

}
void setAuthor(String author)
{
this.author=author;

thi
i

}
void setPrice(float price)
{

ipa

this.price=price;

void setQty(int qty)
{

Ve
nk
ate
sh

this.qty=qty;

Ma

}

}

//Getter methods
String getCode()
{

return code;

}

String getName()
{
return name;

}
String getAuthor()
{
return author;

thi
i

}
float getPrice()
{

ipa

return price;

int getQty()
{

Ve
nk
ate
sh

return qty;

Ma

}

}

}

class DemoCon6
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
BookData ob = new BookData();

System.out.println("Enter the BookCode:");
ob.setCode(s.nextLine());
System.out.println("Enter the BookName:");
ob.setName(s.nextLine());

ob.setAuthor(s.nextLine());

ob.setPrice(s.nextFloat());

ipa

System.out.println("Enter the BookPrice:");

thi
i

System.out.println("Enter the BookAuthor:");

ob.setQty(s.nextInt());

Ma

System.out.println("Enter the BookQty:");

Ve
nk
ate
sh

System.out.println("****BookDetails****");

System.out.println("BookCode:"+ob.getCode());

System.out.println("BookName:"+ob.getName());
System.out.println("BookAuthor:"+ob.getAuthor());
System.out.println("BookPrice:"+ob.getPrice());
System.out.println("BookQty:"+ob.getQty());
}

}

o/p:
Enter the BookCode:
A121

Enter the BookName:
C-Lang
Enter the BookAuthor:
B-Swamy

thi
i

Enter the BookPrice:
1600
Enter the BookQty:

ipa

10

BookCode:A121
BookName:C-Lang

Ve
nk
ate
sh

BookAuthor:B-Swamy

Ma

****BookDetails****

BookPrice:1600.0
BookQty:10

===================================================

faq:

define "this" keyword in Java?

=>"this" keyword will hold the reference of object from where

current method or constructor is executing.

=>Uisng "this" keyword we can access variables and methods from
the Object.

faq:
In wt situation we use "this" keyword?
=>"this" keyword is used while loading the data from local
variables to Instance variables having same names.

thi
i

=======================================================
faq:

wt is the behaviour of Constructor declared with return_type?

ipa

=>If the Constructor is declared with return_type then it is having

faq:

Ve
nk
ate
sh

define destructors in Java?

Ma

the behaviour like normal method.

=>There is no concept of destructors in Java,because the

Constructors are destroyed automatically after execution.
(destructors are available in c++)

==========================================================

*imp

Blocks in Java:

=>The set-of-statements which are declared within the flower

brackets and executed automatically is known as block.
=>Blocks in Java are categorized into two types:
1.Static blocks

2.NonStatic blocks(Instance blocks)

1.Static blocks:
=>The blocks which are declared with "static" keyword are known

thi
i

as static blocks.

syntax:

ipa

static

//statements

Ve
nk
ate
sh

}

Ma

{

Execution behaviour of static blocks:

=>static blocks are executed only once with highest priority when

the class is used for the first time.

=>static blocks will get the memory within the class while class

loading and can access static variables of class directly,but
cannot access Instance variables.

-------------------------------------------------------

************************Student Marks Application************************
A class Student is given to you.
Instance Variables:
studentId :String
studentName :String
marks: int
grade: char
Create a parameterized constructor with the parameters: studentId, studentName, marks.
Note that grade is not set either through constructor because it is a calculated value.
Methods:
displayDetails(): This method should return a String with the details of the student in the
following format:
Student [name=John Smith, studentId=C123, marks=95, grade=A]
calculateGrade(): This is a method that calculates the grade based on the marks that is set.
If marks are above 90, grade is set to A.
If marks are between 81 and 90, grade is set to B,
if marks are between 71 and 80, grade is set to C,
if marks are between 61 and 70, grade is set to D,
if marks are less than 61, grade is set to E.
Use this method when you need to set or reset grade.
A class Tester with main method is given to you to test your code.
*************************************************************************

Assignment-3
Program-1
Define a method which returns the square of the given number if it is an even, return cube of
the given number if it is an odd number.
Write the method with the following specifications:
Name of method: calculate() // which accepts an integer value as argument and return
square of the given value if it is an even, return cube of the given value if it is an odd number.
Arguments: one argument of type integer
Return Type: an integer value
Specifications: The value returned by the method calculates () is determined by the following
rules:
If the given number is negative or zero, return -1.
If the given number is even, return square of the number.
If the given number is odd, return cube of the given number.
Program-2
Define a method which returns the sum of three rounded numbers. If the right most digit of the
number is less than 5, then round off it's value to the previous multiple of 10 otherwise if the
right most digit of the number is greater or equal to 5, then round off to the next multiple of 10.
Write the method with the following specifications:
Name of method sumOfRoundedValues() // which accepts three integer value as argument
and return the sum of three rounded numbers.
Arguments: three argument of type integer
Return Type: an integer value
Example
If a = 23, b = 34, c = 66
20 + 30 + 70 = 120
If a = 23, b = 37, c = 55
20 + 40 + 60 = 120
Specifications: The value returned by the method sumOfRoundedValues() is determined by
the following rules:
If any of the given number is negative or zero, return -1.
If any of the given numbers right most digit is of the number is lessthan 5, then round off its
value to the previous multiple of 10 otherwise if the right most digit of the number is greater
or equal to 5, then round off to the next multiple of 10.
Program-3
Define a method which accepts a 4-digit value as number and checks whether the number is
armstrong or not.
Armstrong number: An Armstrong number is an n-digit number that is equal to the sum of the
nth powers of its digits.

For this program we need 4-digit armstrong number and is calculated as
Input: 1634 is a 4-digit armstrong number defined as
1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634
Write the method with the following specifications:
Name of method: checkArmStrong() // which accepts an integer value as argument and
return the String as specified below.
Arguments: one argument of type integer
Return Type: a String value
Specifications: The value returned by the method checkArmStrong() is determined by the
following rules:
If the input value is negative, return "-1" as string.
If the input value is not a 4-digit number, return "-2" as string.
If the input value is a 4-digit number and is an armstrong, return "ArmStrong Number" as
string otherwise return "Not ArmStrong Number" as string.
Note: The string values you are returning are case sensitive.

Dt : 19/4/2023
Ex-program:(Demonstrating static block in MainClass)
program : DemoBlock1.java
class DemoBlock1

thi
i

{
static int k;
static

ipa

{

Ma

System.out.println("****Static block****");
System.out.println("The value k:"+k);
}

Ve
nk
ate
sh

public static void main(String[] args)
{

k++;

System.out.println("****main()****");
System.out.println("The value k:"+k );

}

}

o/p:

****Static block****
The value k:0
****main()****

The value k:1

Execution flow of above program:
ClassFiles:

Ve
nk
ate
sh

Ma

ipa

thi
i

DemoBlock1.class

=============================================================
Ex-program:(Demonstrating static block in SubClass)

Program : DemBlock2.java
class BTest1
{
static int z;

static
{
System.out.println("****SubClass Static block****");
System.out.println("The value z:"+z);

thi
i

}
}

{

{
BTest1.z++;

Ma

public static void main(String[] args)

ipa

class DemoBlock2

Ve
nk
ate
sh

System.out.println("****main()****");

System.out.println("The value z:"+BTest1.z);

}

}

o/p:

****SubClass Static block****
The value z:0

****main()****
The value z:1

Execution flow of above program:

ClassFiles:
BTest1.class

Ve
nk
ate
sh

Ma

ipa

thi
i

DemoBlock2.class(MainClass)

==============================================================
2.NonStatic blocks(Instance blocks:

=>The blocks which are declared without "static" keyword are

known as NonStatic blocks or Instance blocks

syntax:

{
//statements
}

thi
i

Execution behaviour of Instance blocks:
=>Instance blocks are executed while object creation process.

=>Instance blocks are executed for all multiple object creations.

ipa

=>Instance blocks will get the memory within the object while

and Static variables.

Ve
nk
ate
sh

Ex-Program : DemoBlock3.java

Ma

Object creation process,and can access both Instance variables

class BTest2
{

int x=10;

static int y=20;

{

x++;

y++;
System.out.println("****Instance block****");
System.out.println("The value x:"+x);

System.out.println("The value y:"+y);
}
}
class DemoBlock3

public static void main(String[] args)
{

Ma

BTest2 ob1 = new BTest2();

ipa

System.out.println("--------ob1---------");

System.out.println("--------ob2---------");
BTest2 ob2 = new BTest2();

Ve
nk
ate
sh

}

}

o/p:

--------ob1---------

****Instance block****
The value x:11

The value y:21

--------ob2---------

****Instance block****
The value x:11
The value y:22

thi
i

{

Execution flow of above program:
ClassFiles:
BTest2.class

Ve
nk
ate
sh

Ma

ipa

thi
i

DemoBlock3.class(MainClass)

==============================================================

Dt : 20/4/2023
*imp
Class generating Multiple objects:
=>Classes in Java can generate any number of objects without

thi
i

restriction.
=>The multiple objects which are generated from the class are
independent by their memory location on HeapArea of JVM.

ipa

=>In the process of generating multiple objects,the class is

faq:

Ma

loaded only once.

Ve
nk
ate
sh

In wt situation class will generate multiple objects?

=>In the process of holding database table data we generate

multiple objects from a class,in this process each object will
hold one database table record.

==============================================================
faq:

wt is the diff b/w
(i)blocks

(ii)methods
=>blocks are executed automatically,but methods are executed on
method call

=>blocks will have highest priority in execution than methods.
=>static block will have highest priority in execution than
static method
=>Instance block will have highest priority in execution than

thi
i

Instance method.
=============================================================
faq:

ipa

wt is the diff b/w

(ii)Constructor

Ma

(i)Instance block

=>Both components are executed while object creation process,but

Ve
nk
ate
sh

Instance block will have highest priority in execution than
Constructor.

===============================================================
faq:

wt is the diff b/w
(i)Static block

(ii)Constructor

=>Static block is one time executable component when the class is
used for the first time.
=>constructor also one time executable component while object
creation process.

===============================================================
Program : DemoBlock4.java
class BTest4
{

{
System.out.println("====BTest4()=====");

Ma

ipa

}

thi
i

BTest4()

static
{

Ve
nk
ate
sh

System.out.println("====Static block====");

}

{

System.out.println("====Instance block====");

}

void dis()
{

System.out.println("====dis()====");
}

}
class DemoBlock4
{

thi
i

public static void main(String[] args)
{
BTest4 ob = new BTest4();

ipa

ob.dis();

}
o/p:

Ve
nk
ate
sh

====Static block====

Ma

}

====Instance block====
====BTest4()=====
====dis()====

=============================================================
Note:

=>In realtime static blocks are used in DAO(Data Access Object)

layer of MVC(Model View Controller) to hold database connection
code.
=>In realtime Instance blocks are less used when compared to
static blocks.

==============================================================
*imp
Packages in Java:
=>package is a collection of Classes and Interfaces.

thi
i

=>packages in Java are categorized into two types:
1.Pre-defined packages

ipa

2.User defined packages

Ma

1.Pre-defined packages:

=>The packages which are defined and available from JavaLib are
known as Pre-defined packages or Built-in packages.

Ve
nk
ate
sh

=>The following are some important pre-defined packages:
java.lang - language package(default package)
java.util - utility package

java.io - Input/Output Streams package
java.net - Networking package

2.User defined packages:

=>The packages which are defined by the user are known as user

defined packages.
=>we use "package" keyword to define User defined packages
syntax:

package package_name;
===============================================================
dt : 24/4/2023
Note:

thi
i

=>Download and install IDE Eclipse using the following link:
https://www.eclipse.org/downloads/

ipa

=>Download:

Ma

"Eclipse IDE for Enterprise java and Web Developers"
(IDE-Integrated Development Environment)

===============================================================

Ve
nk
ate
sh

*imp

Creating Java Project using IDE Eclipse:

step-1 : Open IDE Eclipse,while opening name the WorkSpace and
click "Launch"

step-2 : Create Java Project

Click on File->new->Project->Java->select "Java Project" and click
"Next"->name the project and click "Finish"

step-3 : Create packages in "src"
RightClick on "src"->new->package,name the package and click

"Finish"

step-4 : Construct Classes under packages

thi
i

RightClick on package->new->Class,name the class and click "Finish"

Note:

=>To increase font-size,click on Window->Preferences->General->

step-5 : Execute the application

Ve
nk
ate
sh

Open MainClass->click Run->Run

Ma

ipa

Appearance->Colors and Fonts->Java->Java Editor Text font...

=========================================================

Ex-application:

Project_name : EmployeeDetails_App

packages,

p1 : EmpData,EmpSalary
p2 : EmpMainClass

Diagram:

thi
i
ipa
Ma

EmpData.java

Ve
nk
ate
sh

package p1;
public class EmpData {
public String id,name,desg;
public void getEmpData() {
System.out.println("====EmpData====");
System.out.println("EmpId:"+id);
System.out.println("EmpName:"+name);
System.out.println("EmpDesg:"+desg);
}
}
EmpSalary.java

package p1;
public class EmpSalary {
public float getTotSal(int bSal) {
return bSal+(0.93F*bSal)+(0.63F*bSal);
}
}
EmpMainClass.java(MainClass)

package p2;
import java.util.Scanner;
import p1.EmpData;
import p1.EmpSalary;

thi
i

public class EmpMainClass {
public static void main(String[] args) {

EmpData ed = new EmpData();

Ma

EmpSalary es = new EmpSalary();

ipa

Scanner s = new Scanner(System.in);

System.out.println("Enter the empId:");

Ve
nk
ate
sh

ed.id = s.nextLine();

System.out.println("Enter the empName:");
ed.name = s.nextLine();

System.out.println("Enter the empDesg:");
ed.desg = s.nextLine();

System.out.println("Enter the bSal:");
int bSal = s.nextInt();

float totSal = es.getTotSal(bSal);

ed.getEmpData();
System.out.println("BSal:"+bSal);

System.out.println("TotSal:"+totSal);

s.close();
}

thi
i

}

Assignment:

packages,

Ma

Project_name : StudentDetails_App

Ve
nk
ate
sh

p1 : StuData,StuContact,StuPercentage
p2 : StuMainClass

StuData

=>rollNo,name,branch
=>void getStuData()

StuContact

=>mailId,phNo
=>void getStuContact()

ipa

==========================================================

StuPercentage
=>float getPercentage(int totMarks)

StuMainClass

thi
i

=>main()
=>read ...
6 sub marks

Ve
nk
ate
sh

Ma

ipa

==============================================================

Dt : 25/4/2023
Assignment:(Solution)
Project_name : StudentDetails_App
packages,

thi
i

p1 : StuData,StuContact,StuPercentage
p2 : StuMainClass

ipa

StuData.java

Ve
nk
ate
sh

Ma

package p1;
public class StuData {
public String rollNo,name,branch;
public void getStuData() {
System.out.println("****StudentDetails****");
System.out.println("RollNo:"+rollNo);
System.out.println("Name:"+name);
System.out.println("Branch:"+branch);
}
}
StuContact.java

package p1;
public class StuContact {
public String mailId;
public long phNo;
public void getStuContact() {
System.out.println("MailId:"+mailId);
System.out.println("PhoneNo:"+phNo);
}
}
StuPercentage.java

package p1;
public class StuPercentage {
public float getPercentage(int totMarks) {
return (float)totMarks/6;
}
}

thi
i

StuMainClass.java(MainClass)
package p2;

ipa

import java.util.Scanner;
import p1.StuData;

import p1.StuPercentage;
public class StuMainClass {

Ma

import p1.StuContact;

Ve
nk
ate
sh

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
StuData sd = new StuData();

StuContact sc = new StuContact();

StuPercentage sp = new StuPercentage();

System.out.println("Enter the rollNo:");
sd.rollNo = s.nextLine();
System.out.println("Enter the StuName:");
sd.name = s.nextLine();
System.out.println("Enter the Branch:");

sd.branch = s.nextLine();
System.out.println("Enter the MailId:");
sc.mailId = s.nextLine();
System.out.println("Enter the PhoneNo:");

System.out.println("****Enter 6 Sub Marks****");
int i=1,totM=0;

ipa

while(i<=6) {

thi
i

sc.phNo = s.nextLong();

int sub = s.nextInt();
if(sub<0 || sub>100)

Ve
nk
ate
sh

{

Ma

System.out.println("Enter Marks of Subject-"+i);

System.out.println("Invalid marks...");
continue;

}

totM = totM+sub;
i++;

}//end of loop

sd.getStuData();

sc.getStuContact();
System.out.println("TotalMarks:"+totM);
float per = sp.getPercentage(totM);

System.out.println("Percentage:"+per);
s.close();
}
}

thi
i

==============================================================
Assignment-1:

Update above StudentDetails_App by adding "StuResult"

ipa

p1 : StuResult

Ma

=>String generate(float per)

===============================================================
Assignment-2:

Ve
nk
ate
sh

Project_name : Arithmetic_App

packages,

p1 : Addition,Subtraction,Multiplication,Division,
ModDivision

p2 : ArithmeticMainClass

============================================================
*imp

Access Modifiers in Java:
=>Access Modifiers in Java specify the scope and visibility of
programming components in project.

=>Access Modifiers are categorized in to the following:
1.public
2.private
3.protected

thi
i

4.default

1.public:

2.private:

Ma

ipa

=>"public" programming components are accessed within the project

=>"private" programming components are accessed only within the

Ve
nk
ate
sh

class.

3.protected:

=>"protected" programming components are accessed inside the
package,but these "protected" programming components canbe
accessed by the ChildClass declared outside the package.

4.default:

=>The programming components in class,which are declared without
any access modifier are considered as "default".
=>default programming components are accessed only inside the

package.
Note:
=>"default" keyword mustnot be used in classes(Compilation Error)

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh

===============================================================

*imp

define "import" statement?

=>"import" statement will specify the "class or Interface"

available from one package to another package.
=>Importing process in Java canbe done in three ways:
(i)Using "import package_name.CName/IName; "
(ii)Using "import package_name.*; "
(iii)Using "Fully Qualified Names"

Ve
nk
ate
sh
ipa

Ma

thi
i

Dt : 26/4/2023
(i)Using "import package_name.CName/IName; "
=>In this importing process the required class or interface
from the package available to current running program.

thi
i

=>This importing process is also known as "Explicit importing
process"

ipa

Ex:

import p1.StuData;
import p1.StuContact;

Ve
nk
ate
sh

import p1.StuPercentage;

Ma

import java.util.Scanner;

(ii)Using "import package_name.*; "

=>In this importing process all the classes and Interfaces from

the package are available to current running program.
=>This importing process is also known as "Implicit importing

process"

Ex:
import java.util.*;
import p1.*;

(iii)Using "Fully Qualified Names"
=>The process of declaring classes and Interfaces with
package_names part of programming code are known as

Ex:

ipa

java.util.Scanner s = new java.util.Scanner(System.in);

thi
i

"Fully Qualified names"

Ma

p1.StuData sd = new p1.StuData();
p1.StuContact sc = new p1.StuContact();

p1.StuPercentage sp = new p1.StuPercentage();

Ve
nk
ate
sh

============================================================

faq:

define "static" import?

=>The process of declaring "import" statement with static keyword

is known as "static import" and which is introduced by Java5 version
syntax:

import static package_name.CName/IName.*;
Ex:

import static p1.Test.*;

Advantage:

=>In static import,all the static members of Class or Interface
available to current running program and can be accessed directly
without class_name or Interface_name.

thi
i

Ex-progrm:
Test.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public class Test {
public static int k;
public static void dis() {
System.out.println("****static method
dis()****");
System.out.println("The value k:"+k);
}
public void m(int z) {
System.out.println("****Instance method
m(z)****");
System.out.println("The value z:"+z);
}
}
DemoStatic.java(MainClass)
package p2;

import java.util.Scanner;

import static p1.Test.*;//Only Static members are available
import p1.Test;//Class available
public class DemoStatic {
public static void main(String[] args) {

Scanner s = new Scanner(System.in);
System.out.println("Enter the value of k:");
k = s.nextInt();//static variable of class Test
dis();//static method of class Test

thi
i

Test ob = new Test();
ob.m(123);
s.close();

ipa

}

o/p:
Enter the value of k:

Ve
nk
ate
sh

125

Ma

}

****static method dis()****
The value k:125

****Instance method m(z)****
The value z:123

Diagram:

==========================================================
faq:
define "s.close()"?

=>s.close() represent closing Scanner Object connection to Console
input.

Note:

thi
i

=>According to Java Application development,the resources which
are opened outside the JVM must be closed after using the resources
part of Security.

ipa

(Resources means IO,File,Database,N/W,WB,...)`

*imp
Relations in Java:

Ma

==========================================================

Ve
nk
ate
sh

=>The process of establishing relations b/w Programming components

are known as "relations in Java".

=>Relations in Java are categorized into three types:
1.References - Interlinking of Objects
2.Inheritance - Interlinking of Classes
3.InnerClasses - Class holding class

5/20/23, 9:59 AM

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NjA2MzkzMDk1MjYy/details

Packages2.png

1/1

Dt : 27/4/2023

1.References - Interlinking of Objects
=>The process in which one object holding the reference of another

thi
i

object is known as References Concept.
=>In references concept the members of one object can access the
members of another object.

ipa

=>References in Java are categorized into two types:

(b)Loosly Coupled References

Ve
nk
ate
sh

(a)Tightly Coupled References:

Ma

(a)Tightly Coupled References

=>The references concept in which the reffered-class object is

available to only one object is known as Tightly Coupled References
=>In Tightly Coupled references the reffered-class object is

created when we create OuterClass object.

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh
Ex-Program:

EAddress.java

package p1;
public class EAddress {
public String hNo,sName,city,state;
public int pinCode;
public void getEAddress() {

thi
i

}

}

System.out.println("****EAddress****");
System.out.println("HNo:"+hNo);
System.out.println("SName:"+sName);
System.out.println("City:"+city);
System.out.println("State:"+state);
System.out.println("PinCode:"+pinCode);

Employee.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public class Employee {
public String eId,eName,eDesg;
public EAddress ea = new EAddress();
//Tightly Coupled
reference
public void getEmployee() {
System.out.println("****Employee****");
System.out.println("EmpId:"+eId);
System.out.println("EmpName:"+eName);
System.out.println("EmpDesg:"+eDesg);
}
}
DemoRef1.java(MainClass)
package p2;

import java.util.Scanner;
import p1.Employee;

public class DemoRef1 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
Employee e = new Employee();

System.out.println("Enter the EmpId:");
e.eId = s.nextLine();
System.out.println("Enter the EmpName:");

System.out.println("Enter the EmpDesg:");

System.out.println("Enter the HNo:");

Ma

e.ea.hNo = s.nextLine();

ipa

e.eDesg = s.nextLine();

System.out.println("Enter the StreetName:");
e.ea.sName = s.nextLine();

Ve
nk
ate
sh

System.out.println("Enter the City:");
e.ea.city = s.nextLine();

System.out.println("Enter the State:");
e.ea.state = s.nextLine();

System.out.println("Enter the PinCode:");
e.ea.pinCode = s.nextInt();

e.getEmployee();

e.ea.getEAddress();

s.close();

thi
i

e.eName = s.nextLine();

}
}
o/p:
Enter the EmpId:

thi
i

A111
Enter the EmpName:
Raj

ipa

Enter the EmpDesg:

Enter the HNo:
12-34/h

Ve
nk
ate
sh

Enter the StreetName:

Ma

SE

SRNagar

Enter the City:
Hyd

Enter the State:
TS

Enter the PinCode:
612345

****Employee****
EmpId:A111
EmpName:Raj

EmpDesg:SE
****EAddress****
HNo:12-34/h
SName:SRNagar

PinCode:612345
-------------------------------------------------------------

Ma

(b)Loosly Coupled References:

ipa

State:TS

thi
i

City:Hyd

=>The references concept in which the reffered class object is
available to more than one object is known as Loosly Coupled

Ve
nk
ate
sh

references.

=>In Loosly Coupled References reffered-class objects are not

created while creating OuterClass objects,which means reffered
class objects already created and available while creating
OuterClass Objects.

=>This Loosly Coupled References Concept is also known as

Construct Injection process.

Ex-program:
BookDetails.java
package p1;

CreateBook.java

Ve
nk
ate
sh

Ma

package p1;
import java.util.Scanner;
public class CreateBook {
//Instance Variable
public BookDetails bd=null;

ipa

thi
i

public class BookDetails {
public String bCode,bName,bAuthor;
public float bPrice;
public int bQty;
public void getBookDetails() {
System.out.println("****BookDetails****");
System.out.println("BookCode:"+bCode);
System.out.println("BookName:"+bName);
System.out.println("BookAuthor:"+bAuthor);
System.out.println("BookPrice:"+bPrice);
System.out.println("BookQty:"+bQty);
}
}

//Construct to initialize instance variable
public CreateBook(BookDetails bd) {
this.bd=bd;
}

}

public void readBookDetails(Scanner s) {
System.out.println("Enter the BookCode:");
bd.bCode = s.nextLine();
System.out.println("Enter the BookName:");
bd.bName = s.nextLine();
System.out.println("Enter the BookAuthor:");
bd.bAuthor = s.nextLine();
System.out.println("Enter the BookPrice:");
bd.bPrice = s.nextFloat();
System.out.println("Enter the BookQty:");
bd.bQty = s.nextInt();
}

DisplayBook.java
package p1;
public class DisplayBook {
//Instance Variable
public BookDetails bd=null;

public void disBookDetails() {
bd.getBookDetails();
}

Ve
nk
ate
sh

DemoRef2.java(MainClass)

Ma

}

ipa

thi
i

//Constructor to Initialize Instance variable
public DisplayBook(BookDetails bd) {
this.bd=bd;
}

package p2;

import java.util.Scanner;
import p1.*;

public class DemoRef2 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);//Con_call
BookDetails bd = new BookDetails();//Con_Call

CreateBook cb = new CreateBook(bd);//Con_Call
DisplayBook db = new DisplayBook(bd);//Con_call

cb.readBookDetails(s);//Scanner as parameter
db.disBookDetails();

thi
i

s.close();
}
}

ipa

o/p:

A101
Enter the BookName:

Ve
nk
ate
sh

C-Lang

Ma

Enter the BookCode:

Enter the BookAuthor:
B-Swamy

Enter the BookPrice:
1200

Enter the BookQty:
12

****BookDetails****
BookCode:A101
BookName:C-Lang

BookAuthor:B-Swamy

BookPrice:1200.0
BookQty:12
=========================================================
Assignment:

Ve
nk
ate
sh

Ma

ipa

thi
i

Construct the application using the following Layout:

=====================================================

Dt : 28/4/2023

Ma

ipa

thi
i

Diagram:(demonstrating Loosly Coupled references)

=====================================================

Ve
nk
ate
sh

Assignment:(Solution)
SAddress.java

package p1;
public class SAddress {
public String hNo,sName,city,state;
public int pinCode;
public void getSAddress() {
System.out.println("****Address****");
System.out.println("HNO:"+hNo);
System.out.println("SName:"+sName);
System.out.println("City:"+city);
System.out.println("State:"+state);
System.out.println("PinCode:"+pinCode);
}

}

SContact.java

ipa

thi
i

package p1;
public class SContact {
public String mailId;
public long phNo;
public void getSContact() {
System.out.println("****Contact****");
System.out.println("MailId:"+mailId);
System.out.println("PhoneNO:"+phNo);
}
}
Student.java

Ve
nk
ate
sh

Ma

package p1;
public class Student {
public String rollNo,name,branch;
public SAddress sa = new SAddress();
public SContact sc = new SContact();
public void getStudent() {
System.out.println("****StudentDetails****");
System.out.println("RollNo:"+rollNo);
System.out.println("Name:"+name);
System.out.println("Branch:"+branch);
}
}
DemoRef3.java(MainClass)
package p2;

import java.util.*;

import p1.Student;
public class DemoRef3 {
public static void main(String[] args) {

Scanner s = new Scanner(System.in);
Student ob = new Student();

System.out.println("Enter the RollNo:");

thi
i

ob.rollNo = s.nextLine();
System.out.println("Enter the Name:");

System.out.println("Enter the Branch:");

Ma

ob.branch = s.nextLine();

ipa

ob.name = s.nextLine();

System.out.println("Enter the hNo:");
ob.sa.hNo = s.nextLine();

Ve
nk
ate
sh

System.out.println("Enter the StreetName:");
ob.sa.sName = s.nextLine();

System.out.println("Enter the City:");
ob.sa.city = s.nextLine();

System.out.println("Enter the State:");
ob.sa.state = s.nextLine();

System.out.println("Enter the PinCode:");
ob.sa.pinCode = Integer.parseInt(s.nextLine());
System.out.println("Enter the MailId:");
ob.sc.mailId = s.nextLine();
System.out.println("Enter the PhoneNo:");

ob.sc.phNo = s.nextLong();

ob.getStudent();
ob.sa.getSAddress();

thi
i

ob.sc.getSContact();
s.close();
}

Ma

Ve
nk
ate
sh

o/p:

ipa

}

Enter the RollNo:
91234

Enter the Name:
Raj

Enter the Branch:
CSE

Enter the hNo:
12-34/h

Enter the StreetName:
SR

Enter the City:
Hyd
Enter the State:
TS

thi
i

Enter the PinCode:
612345
Enter the MailId:

ipa

v@

989898
****StudentDetails****

Ve
nk
ate
sh

RollNo:91234

Ma

Enter the PhoneNo:

Name:Raj

Branch:CSE

****Address****
HNO:12-34/h
SName:SR
City:Hyd
State:TS

PinCode:612345
****Contact****
MailId:v@

PhoneNO:989898
==========================================================
Note:
=>String-data reading is skipped,when we read String-data after

thi
i

reading numeric-data because the numeric methods will leave
enter-key information in Scanner Object.

=>This can be Overcomed using pre-defined parse-methods.

ipa

=>These parse-methods are used to read data in the form of String

Ma

and converts into numeric.

=>The following are some important parse-menthods:
byte var = Byte.parseByte(s.nextLine());

Ve
nk
ate
sh

short var = Short.parseShort(s.nextLine());
int var = Integer.parseInt(s.nextLine());

long var = Long.parseLong(s.nextLine());

float var = Float.parseFloat(s.nextLine());

double var = Double.parseDouble(s.nextLine());

=>Byte,Short,Integer,Long,Float,Double are pre-defined Wrapper

Classes.

=============================================================

Dt : 29/4/2023
Assignment:(Solution)
wap to perform WithDraw process?

WithDraw.java

BankMainClass.java(MainClass)

Ma

ipa

thi
i

package p1;
public class WithDraw {
public void wDraw(int amt) {
System.out.println("Amt withdrawn:"+amt);
System.out.println("balance amt:"+(2000-amt));
System.out.println("Transaction Successfully...");
}
}

Ve
nk
ate
sh

package p2;

import java.util.*;

import p1.WithDraw;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
int count=0;

while(true) {
System.out.println("Enter the PinNo:");
int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {
System.out.println("Enter the amt to WithDraw:");
int amt = s.nextInt();
if(amt>0 && amt%100==0) {

thi
i

if(amt<=2000) {
WithDraw wd = new WithDraw();
wd.wDraw(amt);//method call

ipa

break;//stop the loop

Ma

}else {

System.out.println("Insufficient fund..");
break;//stop the loop

Ve
nk
ate
sh

}

}else {

System.out.println("Invalid amt...");
break;//stop the loop

}

}else {

System.out.println("Invalid pinNo...");
count++;

}
if(count==3) {
System.out.println("Sorry ! Transaction blocked...");

break;//stop the loop
}
}//end of loop
s.close();

thi
i

}
}
o/p:

ipa

Enter the PinNo:

Enter the amt to WithDraw:
1200

Ve
nk
ate
sh

Amt withdrawn:1200

Ma

1234

balance amt:800

Transaction Successfully...

=========================================================

Student Marks Application:(Solution)

Student.java

package p1;
public class Student {
public String studentId,studentName;
public int marks;
public char grade;
public Student(String studentId,String
studentName,int marks) {

this.studentId=studentId;
this.studentName=studentName;
this.marks=marks;

Ve
nk
ate
sh

Ma

ipa

thi
i

}
public void caluculateGrade() {
if(marks>90 && marks<=100) {
grade = 'A';
}else if(marks>=81 && marks<=90) {
grade='B';
}else if(marks>=71 && marks<=80) {
grade='C';
}else if(marks>=61 && marks<=70) {
grade='D';
}else {
grade='E';
}
}
public String displayDetails() {
String details = "StudentName="+studentName+
"\nStudentId="+studentId+
"\nMarks="+marks+
"\nGrade="+grade;
return details;
}

}
DemoTestMarks.java(MainClass)
package p2;

import java.util.*;

import p1.Student;

public class DemoTestMarks {

public static void main(String[] args) {
Scanner s = new Scanner(System.in);
System.out.println("Enter the StudentId:");

String stuId = s.nextLine();
System.out.println("Enter the StudentName:");
String stuName = s.nextLine();
System.out.println("Enter the Marks:");

ob.caluculateGrade();
String details = ob.displayDetails();

s.close();
}

Ve
nk
ate
sh

}

Ma

System.out.println(details);

o/p:

Enter the StudentId:
V123

Enter the StudentName:
Alex

Enter the Marks:
67

StudentName=Alex
StudentId=V123
Marks=67

ipa

Student ob = new Student(stuId,stuName,marks);

thi
i

int marks = s.nextInt();

Grade=D

Ve
nk
ate
sh

Ma

ipa

thi
i

========================================================

Dt : 2/5/2023
Note:
=>References concept is also known as 'HAS-A Relation',because
in references concept one object has-a reference of another object.

*imp
2.Inheritance - Interlinking of Classes

thi
i

===========================================================

Ma

in Java is known as Inheritance process.

ipa

=>The process of interlinking two classes with "extends" keyword

=>In Inheritance process the ParentClass members are available

Ve
nk
ate
sh

to ChildClass.

Diagram:

thi
i
ipa
Ma

Ve
nk
ate
sh

syntax:
class A
{

//PClass_body

}

class B extends A
{

//CClass_body

}
===========================================================
Case-1 : Variables and methods from the SuperClass/ParentClass

Case-2 : Constructors from the SuperClass/ParentClass
Case-3 : Blocks from the SuperClass/ParentClass

Ex-program-1:(Demonstrating Instance members)
A.java

thi
i

Case-1 : Variables and methods from the SuperClass/ParentClass

Ve
nk
ate
sh

Ma

ipa

package p1;
public class A {
public int p,q;
public void showpq() {
System.out.println("****SuperClass-A****");
System.out.println("p:"+p+"\nq:"+q);
}
}
B.java

package p1;
public class B extends A{
public int r;
public void showr() {
System.out.println("****SubClass-B****");
System.out.println("r:"+r);
}
public void sum() {
System.out.println("****SubClass-sum()***");
System.out.println("p+q+r:"+(p+q+r));
}
}
DemoInheritance1.java(MainClass)

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import p1.*;
public class DemoInheritance1 {
public static void main(String[] args) {
System.out.println("-----SuperClass Object----");
A ob1 = new A();
ob1.p=11;
ob1.q=12;
ob1.showpq();
System.out.println("-----SubClass Object----");
B ob2 = new B();
ob2.p=20;
ob2.q=21;
ob2.r=22;
ob2.showpq();
ob2.showr();
ob2.sum();
}
}
o/p:

-----SuperClass Object----****SuperClass-A****
p:11
q:12

-----SubClass Object----****SuperClass-A****
p:20
q:21
****SubClass-B****

r:22
****SubClass-sum()***
p+q+r:63

ClassFiles:
A.class
B.class

Ve
nk
ate
sh

Ma

DemoInheritance1.class(MainClass)

ipa

thi
i

Execution flow of above program:(Demonstrating Inheritance)

-------------------------------------------------------Note:

=>In Inheritance process we create object for SubClass/ChildClass,
in this process the ChildClass object will hold all instance members
of ParentClass and ChildClass.
=======================================================

thi
i

Ex-program-2:(Demonstrating static members)

A.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public class A {
public static int a;
public static void showa() {
System.out.println("====PClass====");
System.out.println("The value a:"+a);
}
}
B.java

package p1;
public class B extends A{
public static int b;
public static void showb() {
System.out.println("====ChildClass====");
System.out.println("The value b:"+b);
}
}
DemoInheritance2.java(MainClass)
package p2;
import p1.*;
public class DemoInheritance2 {
public static void main(String[] args) {

thi
i

ipa

}

}

System.out.println("----Access with Class----");
B.a=12;
B.showa();
B.b=13;
B.showb();
System.out.println("----Access with Object----");
B ob = new B();
ob.a=21;
ob.showa();
ob.b=22;
ob.showb();

----Access with Class---====PClass====

Ve
nk
ate
sh

The value a:12

Ma

o/p:

====ChildClass====
The value b:13

----Access with Object---====PClass====
The value a:21

====ChildClass====
The value b:22

------------------------------------------------------------Note:
=>In Inheritance process all the static members of ParentClass

are available to ChildClass and can be accessed with ChildClass
name directly.

Ve
nk
ate
sh

Ma

ipa

thi
i

------------------------------------------------------------

Implement a bank application that requires two classes namely, Account and Customer.
The class Customer is given and has the following specifications.
Customer:
Instance Variables: firstName, lastName.(both Strings)
Getters/setters ,default constructor, and parameter constructor.
A class Account is given and has the following specifications.
Account:
Instance Variables:customer(of type Customer), balance: double, accountNo: int,
interestRate:float
Methods:
deposit(amount) deposits the given amount. Add the given amount to balance
withdraw(amount) withdraw /subtract the amount from balance if the amount is less
than balance. Other wise do not withdraw.
A tester class BankTester with the main method is given to you. Use this class to test your
solution.

Dt : 3/5/2023
Execution Flow of above program:(Demonstrating static members)
ClassFiles:
A.class

thi
i

B.class
DemoInheritance2.class(MainClass)

ipa

===========================================================

define Empty-Object-reference?

Ma

faq:

=>Empty-Object-reference is generated when we create object for

Ve
nk
ate
sh

the class holding only static members.

===========================================================
faq:

can we access static members of class using Object reference or
Object name?

=>Yes,we can access static members of class using object reference

because the object reference generated for the class and belongs to
class.

=============================================================
*imp
Case-2 : Constructors from the SuperClass/ParentClass

(i)O-parameter constructor from the SuperClass/ParentClass
=>when we have 0-parameter constructor in PClass then compiler
at compilation stage will add "super()" to the CClass constructor

thi
i

and which PClass_Con_Call.

Ex:

ipa

A.java

Ve
nk
ate
sh

Ma

package p1;
public class A {
public A() {
System.out.println("****PClass-A()****");
}
}
B.java

package p1;
public class B extends A{
public B() {
System.out.println("****CClass-B()****");
}
}
DemoInheritance3.java(MainClass)

package p2;
import p1.*;
public class DemoInheritance3 {
public static void main(String[] args) {
B ob = new B();//CClass_Con_Call
}

}
o/p:
****PClass-A()****

thi
i

****CClass-B()****

(ii)Parameterized Constructor from the SuperClass/ParentClass

ipa

=>when we have parameterized constructor in PClass then we must

PClass_Constructor.

Ve
nk
ate
sh

Ex:

Ma

add "super()" to the CClass constructor to pass parameters to

A.java

package p1;
public class A {
public A(int x,int y) {
System.out.println("****PClass-A()****");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
}
B.java

package p1;
public class B extends A{
public B(int v1,int v2) {
super(v1,v2);//PClass_Con_Call
}

}
DemoInheritance4.java(MainClass)

ipa

thi
i

package p2;
import p1.*;
public class DemoInheritance4 {
public static void main(String[] args) {
B ob = new B(12,13);//CClass_Con_Call
}
}
o/p:

The value x:12
The value y:13

Ma

****PClass-A()****

Ve
nk
ate
sh

===============================================================

*imp

Case-3 : Blocks from the SuperClass/ParentClass

=>Static blocks in PClass are executed first and then CClass static
blocks are executed.

=>Instance blocks in pClass are executed first and then CClass
Instance blocks are executed.

Ex:

A.class
package p1;
public class A
{

thi
i

public A()
{
System.out.println("****PClass-A()****");
}

ipa

static
{
System.out.println("****PClass-staticblock****");
}

Ma

{

Ve
nk
ate
sh

System.out.println("****PClass-Instanceblock****");
}
}

B.class

package p1;
public class B extends A
{
static
{
System.out.println("****CClass-staticblock****");
}

public B()
{

}

System.out.println("****CClass-B()****");

{

thi
i

System.out.println("****CClass-Instanceblock****");
}
}
DemoInheritance5.java(MainClass)

Ve
nk
ate
sh

o/p:

Ma

ipa

package p2;
import p1.*;
public class DemoInheritance5 {
public static void main(String[] args) {
B ob = new B();
}
}

****PClass-static-block****
****CClass-static-block****

****PClass-Instance-block****
****PClass-A()****

****CClass-Instance-block****
****CClass-B()****

============================================================

5/20/23, 10:02 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

Inheritance1.png

1/1

Dt : 4/5/2023
*imp
Member Access and Inheritance:
(i)"public" programming components of ParentClass can be accessed

thi
i

by the ChildClasses available in the same package or different
package.

(ii)In Inheritance process "private" programming components of

ipa

ParentClass cannot be accessed by the ChildClasses,because

Ma

private programming are accessed only inside the class.

(iii)"protected" programming components of parentClass can be
accessed by the ChildClasses within the same package or

Ve
nk
ate
sh

different package.

(iv)defualt programming components of ParentClass can be accessed
by the ChildClasses within the same package,but cannot be
accessed by the ChildClasses from differet packages.

Ex-program:
A.java

package p1;
public class A {
protected int a=10;
public void mA() {
System.out.println("****mA()****");
System.out.println("The value a:"+a);
}

}
B.java

}

Ma

C.java

ipa

}

thi
i

package p1;
public class B extends A{
public int b=20;
public void mB() {
System.out.println("****mB()****");
System.out.println("The value a:"+a);
System.out.println("The value b:"+b);

Ve
nk
ate
sh

package p2;
import p1.A;
public class C extends A{
public int c=30;
public void mC() {
System.out.println("The value a:"+a);
System.out.println("The value c:"+c);
}
}
DemoInheritance6.java(MainClass)
package maccess;
import p1.*;

import p2.C;
public class DemoInheritance6 {
public static void main(String[] args) {

B ob1 = new B();
ob1.mA();
ob1.mB();
C ob2 = new C();

thi
i

ob2.mA();
ob2.mC();
}

ipa

}

****mA()****
The value a:10

Ve
nk
ate
sh

****mB()****

Ma

o/p:

The value a:10
The value b:20
****mA()****

The value a:10
The value a:10
The value c:30

=========================================================

*imp
Method Overriding process:
=>The method with same method signature in ParentClass and

ChildClass,then ParentClass method is replaced by ChildClass
method while Object creation process is known as Method Overriding
process or Method Replacement process.
=>Same method signature means,

thi
i

same return_type
same method_name
same para_list

Ma

ipa

same para_type

Case-1 : Instance method Overriding process
Case-2 : Static method Overriding process

Ve
nk
ate
sh

Case-3 : Constructor Overriding process

Case-1 : Instance method Overriding process
=>The Instance method with same method Signature in PClass and

CClass then PClass Instance method is replaced by CClass instance
method while Object creation process,is known as Instance method
Overriding process.

Ex-program:
A.class

thi
i

package p1;
public class A {
public void showA(int a) //Overrided_method
{
System.out.println("****PClass-showA(a)****");
System.out.println("The value a:"+a);
}
}
B.class

Ve
nk
ate
sh

Ma

ipa

package p1;
public class B extends A{
public void showA(int a) //Overriding method
{
System.out.println("****CClass-showA(a)****");
System.out.println("The value a:"+a);
}
public void showB(int b) //Non Overriding method
{
System.out.println("****CClass-showB(b)****");
System.out.println("The value b:"+b);
}
}
DemoInheritance7.java(MainClass)

package p2;
import p1.*;
public class DemoInheritance7 {
public static void main(String[] args) {
B ob = new B();
ob.showA(12);
ob.showB(13);
}
}
o/p:

****CClass-showA(a)****
The value a:12
****CClass-showB(b)****

thi
i

The value b:13

Execution flow of above program:(Demonstrating Overriding process)
ClassFiles:

ipa

A.class

Ma

B.class

Ve
nk
ate
sh

DemoInheritance7.class(MainClass)

thi
i
ipa
Ma
Ve
nk
ate
sh

===========================================================
Case-2 : Static method Overriding process

=>There is no concept of static method Overriding process,because

static methods will get the memory within the class and available
within the class.

Case-3 : Constructor Overriding process
=>There is no concept of Constructor Overriding process,because

PClass Constructor will hace PClass_name and CClass Constructor
will have CClass_name.
=============================================================
faq:

thi
i

define Method Hiding process?
=>when we have same static method signature in PClass and CClass,
then PClass Static method is hided by CClass static method while

Ex:
A.class

Ma

ipa

execution process,is known as Method Hiding process.

Ve
nk
ate
sh

package p1;
public class A {
public static void showA(int a)
{
System.out.println("****PClass-showA(a)****");
System.out.println("The value a:"+a);
}
}
B.class

package p1;
public class B extends A{
public static void showA(int a)
{
System.out.println("****CClass-showA(a)****");
System.out.println("The value a:"+a);
}

public static void showB(int b) //Non Overriding
method
{
System.out.println("****CClass-showB(b)****");
System.out.println("The value b:"+b);
}
}

thi
i

DemoInheritance8.java(MainClass)

Ve
nk
ate
sh

o/p:

Ma

ipa

package p2;
import p1.*;
public class DemoInheritance8 {
public static void main(String[] args) {
B.showA(123);
B.showB(124);
}
}

****CClass-showA(a)****
The value a:123

****CClass-showB(b)****
The value b:124

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh

==========================================================

Summary:

(i)Same Instance method signature in PClass and CClass is known as
Method Overriding process

(ii)Same Static method Signature in PClass and CClass is known as
Method Hiding process.

=========================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

A class Student is given to you. It contains the following implementation.
Instance Variables: studentId : int , name :String , examFee:double
Methods: displayDetails(): String , payFee() :double
Default constructor, an all-fields constructor and a toString method.
Create two sub classes of Student called DayScholar and Hosteller. Add the following
implementations to each class.
DayScholar:
Instance Variables : transportFee:double ,
Methods: Default constructor and an all-fields constructor
Hosteller:
Instance Variables: hostelFee :double
Methods: Default constructor and an all-fields constructor .
Add the following methods in BOTH classes.
Method: displayDetails(): This method should return a string containing the details of the
student in the following format:
Student [name=John Smith,studentId=123,examFee=100.0] OR
DayScholar[transportFee=500, name=John Smith,studentId=123,examFee=100.0] and so on.
Method: payFee(amount): This method takes amount as parameter that represents the fee
provided. You must calculate and
then return the remaining amount paid in excess. If excess is paid, the returned amount will be
negative. The total fees that each student must pay must include all the fees applicable to that
Student(examFees, transportFees, hostelFees as applicable). Subtract the given amount from
total fee for each student and return the remaining amount.
A class StudentTester is given to you with a main method. Use this class to test your solution's
classes and methods.

Dt : 5/5/2023
Method Overloading process:
=>More than one method with same method name but differentiated by their
para_list or para_type is known as Method Overloading process or Method

thi
i

extention process.

Case-1 : Instance method Overloading process

Ma

Case-2 : Static method Overloading process

ipa

=>In Method Overloading process,return_type of methods are not cosidered.

Case-3 : Constructor Overloading process

Ve
nk
ate
sh

Case-1 : Instance method Overloading process

=>More than one Instance method with same name but differentiated by their

para_list or para_type is known as Instance method Overloading process.

Ex-program:
A.java

package p1;
public class A {
public void m(int a) {
System.out.println("*****PClassm(a)******");

B.java

Ma

ipa

thi
i

System.out.println("The value
a:"+a);
}
public void m(int a,int b) {
this.m(a);
System.out.println("*****PClassm(a,b)******");
System.out.println("The value
b:"+b);
}
}

Ve
nk
ate
sh

package p1;
public class B extends A{
public void m(int a,int b,int c) {
super.m(a, b);
System.out.println("*****CClassm(a,b,c)******");
System.out.println("The value
c:"+c);
}
public void m(int a,int b,int c,int
d) {
this.m(a, b, c);

System.out.println("*****CClassm(a,b,c,d)******");
System.out.println("The value
d:"+d);

thi
i

}

}

ipa

DemoInheritance9.java(MainClass)

Ve
nk
ate
sh

Ma

package p2;
import p1.*;
public class DemoInheritance9 {
public static void main(String[]
args) {
B ob = new B();
ob.m(1, 2, 3, 4);
}
}
o/p:

*****PClass-m(a)******
The value a:1

*****PClass-m(a,b)******
The value b:2
*****CClass-m(a,b,c)******
The value c:3

*****CClass-m(a,b,c,d)******
The value d:4
------------------------------------------------------------faq:

thi
i

define Instance method Interlinking process?
=>The process of calling one Instance method from another Instance method

faq:
wt is the diff b/w

Ve
nk
ate
sh

(i)super

Ma

process or Instance method Chaining process.

ipa

using "this" or "super" keyword is known as Instance method Interlinking

(ii)this

(i)super:

=>"super" keyword is used to access the variables and methods from the
SuperClass or ParentClass.

(ii)this:

=>"this" keyword is used to access the variables and methods from the
Same class or Current running class.
===================================================================

Case-2 : Static method Overloading process
=>More than one static method with same method_name but differentiated
by their para_list or para_type is known as Static method Overloading process.

thi
i

faq:
Can we perform Static method Interlinking process or not?

=>No,we cannot perform Static method Interlinking process using "super"

ipa

and "this" keywords,because "super" and "this" are NonStatic reference

faq:

Ma

variables

Ve
nk
ate
sh

Can we access static methods using "super" and "this" keywords?
=>Yes,we can access static methods using "super" and "this" keywords,but

"super" and "this" keywords must be used in NonStatic methods or Instance
methods.

Ex-program:
A.java

package p1;
public class A {
public static void m(int a) {
System.out.println("*****PClassm(a)******");

Ve
nk
ate
sh

Ma

ipa

thi
i

System.out.println("The value
a:"+a);
}
public static void m(int a,int b)
{
//this.m(a);
System.out.println("*****PClassm(a,b)******");
System.out.println("The value
a:"+a);
System.out.println("The value
b:"+b);
}
}
B.java

package p1;
public class B extends A{
public static void m(int a,int
b,int c) {
//super.m(a, b);
System.out.println("*****CClassm(a,b,c)******");
System.out.println("The value
a:"+a);
System.out.println("The value
b:"+b);

c:"+c);

System.out.println("The value

Ve
nk
ate
sh

Ma

ipa

thi
i

}
public static void m(int a,int
b,int c,int d) {
//this.m(a, b, c);
System.out.println("*****CClassm(a,b,c,d)******");
System.out.println("The value
a:"+a);
System.out.println("The value
b:"+b);
System.out.println("The value
c:"+c);
System.out.println("The value
d:"+d);
}
public void access(int a,int b,int
c,int d) {
super.m(a);
super.m(a, b);
this.m(a, b, c);
this.m(a, b, c, d);
}
}

DemoInheritance10.java(MainClass)

*****PClass-m(a)******

Ve
nk
ate
sh

The value a:1

Ma

o/p:

ipa

thi
i

package p2;
import p1.*;
public class DemoInheritance10 {
public static void main(String[]
args) {
B ob = new B();
ob.access(1, 2, 3, 4);
}
}

*****PClass-m(a,b)******
The value a:1
The value b:2

*****CClass-m(a,b,c)******
The value a:1
The value b:2
The value c:3

*****CClass-m(a,b,c,d)******
The value a:1
The value b:2

The value c:3
The value d:4
================================================================
*imp

thi
i

Case-3 : Constructor Overloading process
=>More than one Constructor differentiated by their para_list or para_type

ipa

is known as Constructor Overloading process.

Ma

faq:

define Constructor Chaining Process?(Constructor Interlinking process)
=>The process of calling one constructor from another constructor using

Ve
nk
ate
sh

"super()" or "this()" is known as Constructor Chaining Process.

Ex-program :
A.java

package p1;
public class A {
public A(int a) {

System.out.println("****A(a)****");
System.out.println("The value
a:"+a);
}

public A(int a,int b) {
this(a);

ipa

thi
i

System.out.println("****A(a,b)****");
System.out.println("The value
b:"+b);
}
}
B.java

Ve
nk
ate
sh

Ma

package p1;
public class B extends A{
public B(int a,int b,int c) {
super(a,b);

System.out.println("****B(a,b,c)****")
;
System.out.println("The value
c:"+c);
}
public B(int a,int b,int c,int d) {
this(a,b,c);
System.out.println("****B(a,b,c,d)****
");

System.out.println("The value
d:"+d);
}
}

thi
i

DemoInheritance11.java(MainClass)

Ve
nk
ate
sh

Ma

ipa

package p2;
import p1.*;
public class DemoInheritance11 {
public static void main(String[]
args) {
B ob = new
B(1,2,3,4);//Con_Call_with_para
}
}
o/p:

****A(a)****
The value a:1

****A(a,b)****
The value b:2

****B(a,b,c)****
The value c:3

****B(a,b,c,d)****
The value d:4

Ve
nk
ate
sh

Ma

ipa

thi
i

==================================================================

Dt : 6/5/2023
faq:
wt is the diff b/w
(i)super()

thi
i

(ii)this()

(i)super():

ipa

=>super() is used to access the constructors from the ParentClass or

(ii)this():

Ma

SuperClass.

Ve
nk
ate
sh

=>this() is used to access the Constructors from the Same Class or

Current Running Class.

===================================================================
===
Note:

=>Inheritance process is not manditory to perform Method Overloading

process,but Inheritance is manditory to perform Method Overriding process.
===================================================================
====
Ex-program:
Addition.java

DemoInheritance12.java(MainClass)

thi
i

ipa

package p1;
public class Addition {
public void add(int x,int y){
System.out.println("Sum1:"+(x+y));
}
public int add(int x,int y,int z){
return x+y+z;
}
public float add(float x,float y){
return x+y;
}
}

Ve
nk
ate
sh

Ma

package p2;
import p1.Addition;
public class DemoInheritance12 {
public static void main(String[] args) {
Addition ob = new Addition();
ob.add(1, 2);
int sum2 = ob.add(1, 2, 3);
float sum3 = ob.add(1.2F, 4.3F);
System.out.println("Sum2:"+sum2);
System.out.println("Sum3:"+sum3);
}

}

o/p:

Sum1:3
Sum2:6

Sum3:5.5
==========================================================

Assignmnet:(References)(Solution)
Customer.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class Customer {
public String firstName,lastName;
public Customer() {}
public Customer(String firstName,String lastName) {
this.firstName=firstName;
this.lastName=lastName;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
}

Account.java

package p1;
public class Account {
public Customer c = new Customer();
public double balance=2000;
public int accountNo;
public float interestRate;
public void withDraw(int amt) {
System.out.println("FirstName:"+c.getFirstName());
System.out.println("LastName:"+c.getLastName());
System.out.println("AccNo:"+accountNo);
if(amt<=balance) {

balance=balance-amt;
System.out.println("balance:"+balance);
System.out.println("Interest:"+interestRate);
}else {
System.out.println("Insufficient fund...");
}

}
public void deposit(int amt) {

BankTester.java(MainClass)

Ma

ipa

thi
i

System.out.println("FirstName:"+c.getFirstName());
System.out.println("LastName:"+c.getLastName());
System.out.println("AccNo:"+accountNo);
balance=balance+amt;
System.out.println("balance:"+balance);
System.out.println("Interest:"+interestRate);
}
}

Ve
nk
ate
sh

package p2;

import java.util.*;
import p1.*;

public class BankTester {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
Account ac = new Account();

System.out.println("Entere the firstName:");
ac.c.setFirstName(s.nextLine());
System.out.println("Entere the lastName:");
ac.c.setLastName(s.nextLine());

System.out.println("Enter the accNum:");
ac.accountNo = s.nextInt();
System.out.println("====Choice====");
System.out.println("1.WithDraw\n2.Deposit");

int choice = s.nextInt();
switch(choice) {
case 1:

int a1 = s.nextInt();
ac.withDraw(a1);

Ve
nk
ate
sh

break;

Ma

System.out.println("Enter the amt:");

case 2:

System.out.println("Enter the amt:");
int a2 = s.nextInt();
ac.deposit(a2);
break;

default:

System.out.println("Invalid Choice:");

}//end of switch
s.close();
}

ipa

thi
i

System.out.println("Enter the Choice:");

}
o/p:
Entere the firstName:
Alex

thi
i

Entere the lastName:
K
Enter the accNum:

ipa

31313131

1.WithDraw
2.Deposit

Ve
nk
ate
sh

Enter the Choice:

Ma

====Choice====

2

Enter the amt:
1300

FirstName:Alex
LastName:K

AccNo:31313131
balance:3300.0
Interest:0.0

=============================================================
*imp

Types of Inheritances:
=>Inheritances are categorized into 5 types:
1.Single Inheritance
2.Multiple Inheritance

thi
i

3.Multi Level Inheritance
4.Hierarchal Inheritance
5.Hybrid Inheritance

Ve
nk
ate
sh

Ma

ipa

Diagrams:

===============================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

*imp
Interfaces in Java:
=>Interface is a collection of variables,abstract methods and
concrete methods from Java8 version onwards.

abstract methods,but cannot hold concrete methods)

ipa

faq:

thi
i

(Upto Java7 version Interface is collection of variables and

Ma

define abstract methods?

=>The methods which are declared without method body are known
as abstract methods.

Ve
nk
ate
sh

structure of abstract methods:

abstract return_type method_name(para_list);

faq:

define concrete methods?

=>The methods which are declared with method_body are known as

Concrete methods.

structure of concrete methods:

return_type method_name(para_list)
{
//method_body

}
----------------------------------------------------------*imp
Coding rules of Interface:

thi
i

Rule-1 : we use "interface" keyword to declare interfaces
syntax:
interface Interface_name

ipa

{

}

Ma

//Interface_body

Ve
nk
ate
sh

Rule-2 : The programming components which are declared within the
interface are automatically "public"

Note:

=>The programming components which are declared in Classes

without any access modifier are considered as "default"

Rule-3 : Interfaces can be declared with both Primitive datatype
variables and NonPrimitive datatype variables

Rule-4 : The variables which are declared in interfaces are
automatically "static and final variables"

Note:
(i)static variables in interface will get the memory within
the interface while interface loading and can be accessed
with interface_name.

thi
i

(ii)final variables must be initialized with value and once
initialized cannot be modified.

(final variables are also known as secured variables or

ipa

constant variables)

Ma

(iii)There is no concept of declaring NonStatic variables

in interfaces,because the variables are automatically

Ve
nk
ate
sh

static variables.

Rule-5 : The methods which are declared in interfaces are
automatically NonStatic abstract methods.
(There is no concept of static abstract methods)

Rule-6 : The Normal interfaces can be declared with any number of
abstract methods no restriction.

Rule-7 : Interfaces cannot be instantiated,which means we cannot
create object for Interfaces directly.

Rule-8 : These interfaces are implemented to classes using
"implements" keyword and the classes are known as
implementation classes.

thi
i

Rule-9 : These implementation classes must construct body for all
abstract methods of Interface.

ipa

Ex-program:
ITest.java

Ve
nk
ate
sh

Ma

package p1;
public interface ITest {
public static final int k=123;
public abstract void showA(int a);
public abstract void showB(int b);
}
IClass.java

package p1;
public class IClass implements ITest{
public void showA(int a)//Overriding and
Implemented method
{
System.out.println("****showA(a)****");
System.out.println("The value a:"+a);
System.out.println("The value k:"+k);
}
public void showB(int b)//Overriding and
Implemented method
{
System.out.println("****showB(b)****");

System.out.println("The value b:"+b);
System.out.println("The value k:"+k);

thi
i

}
public void showC(int c)//NonOverriding and
NonImplemented methods
{
System.out.println("****showC(c)****");
System.out.println("The value c:"+c);
System.out.println("The value k:"+k);
}

ipa

}
DemoInterface1.java(MainClass)

Ve
nk
ate
sh

Ma

package p2;
import p1.*;
public class DemoInterface1 {
public static void main(String[] args) {
//ITest ob = new ITest();//Error
IClass ob = new IClass();
ob.showA(100);
ob.showB(200);
ob.showC(300);
}
}
o/p:

****showA(a)****
The value a:100
The value k:123
****showB(b)****
The value b:200

The value k:123
****showC(c)****
The value c:300
The value k:123

Ve
nk
ate
sh

Ma

ipa

thi
i

-------------------------------------------------------

Dt : 9/5/2023
Execution flow of above program:
ClassFiles:
ITest.class

thi
i

IClass.class

Ve
nk
ate
sh

Ma

ipa

DemoInterface1.class(MainClass)

----------------------------------------------------------

Rule-10 : Implementation classes can be declared with both implemented
methods and NonImplemented methods.

faq:
wt is the diff b/w
(i)Implemented methods

(ii)NonImplemented methods

(i)Implemented methods:
=>The methods which are taken from interfaces and constructed the body

thi
i

are known as Implemented methods.

(ii)NonImplemented methods:

Ma

known as NonImplemented methods.

ipa

=>The methods which are declared in implementation classes directly are

-----------------------------------------------------------------

Rule-11 : Interfaces can be implemented to any number of implementation

Ve
nk
ate
sh

Classes.

Diagram:

Ex-program :
IComparable.java

thi
i

package p1;
public interface IComparable {
public abstract int compareTo(int x,int y);
}
GreaterValue.java

Ve
nk
ate
sh

SmallerValue.java

Ma

ipa

package p1;
public class GreaterValue implements IComparable{
public int compareTo(int x,int y) {
if(x>y) return x;
else return y;
}
}

package p1;
public class SmallerValue implements IComparable{
public int compareTo(int x,int y) {
if(x<y) return x;
else return y;
}
}
DemoInterface2.java(MainClass)
package p2;

import java.util.*;
import p1.*;
public class DemoInterface2 {

public static void main(String[] args) {
Scanner s = new Scanner(System.in);
System.out.println("Enter the value-1:");
int v1 = s.nextInt();

thi
i

System.out.println("Enter the value-2:");
int v2 = s.nextInt();
if(v1>0 && v2>0) {

ipa

if(v1==v2) {

Ma

System.out.println("Values are equal...");
}else {

System.out.println("*******Choice*******");

Ve
nk
ate
sh

System.out.println("\t1.GreaterValue"
+ "\n\t2.SmallerValue");

System.out.println("Enter the Choice:");
int choice = s.nextInt();
switch(choice) {
case 1:

GreaterValue gv = new GreaterValue();
int res1 = gv.compareTo(v1,v2);
System.out.println("GreaterVale:"+res1);
break;

case 2:

SmallerValue sm = new SmallerValue();
int res2 = sm.compareTo(v1,v2);
System.out.println("SmallerValue:"+res2);
break;

thi
i

default:
System.out.println("Invalid choice...");
}//end of switch

ipa

}//end of else

Ma

}else {
System.out.println("Invalid input....");
}

Ve
nk
ate
sh

s.close();
}

}

o/p:

Enter the value-1:
12

Enter the value-2:
13

*******Choice*******
1.GreaterValue
2.SmallerValue

Enter the Choice:
1
GreaterVale:13
===========================================================

Construct application from the following Layout:

thi
i

Assignment:

ipa

============================================================

Ma

Rule-12 : Interfaces can be declared with Concrete methods

============================================================
*imp

Ve
nk
ate
sh

Concrete methods in Interfaces:(Java8 - new feature)

=>From Java8 version onwards the interfaces can be declared with concrete

methods.

=>The following are the concrete methods can be declared in Interfaces:
(a)static Concrete methods(Java8)

(b)default Concrete methods(Java8)
(c)private Concrete methods(Java9)

Dt : 10/5/2023
(a)static Concrete methods(Java8):
=>The Concrete methods in interfaces which are declared with "static"
keyword are known as static Concrete methods,introduced by Java8 version.

thi
i

Coding Rule:
=>Static concrete methods of Interfaces are not available to implementation
classes,which means Static concrete methods of Interface cannot be accessed

Ma

ipa

with Implementation_Class_name.

(b)default Concrete methods(Java8):

=>The Concrete methods in interfaces which are declared with "default"

Ve
nk
ate
sh

keyword are known as default concrete methods,introduced by Java8 version.
=>These default concrete methods are only NonStatic methods.

Coding Rule:

=>These default concrete methods are available to implementation classes,

which means these default concrete methods will get the memory within the
object of implementation class and can be accessed with Implementation class
Object_name

(c)private Concrete methods(Java9):
=>The concrete methods in interfaces which are declared with "private"
keyword are known as private concrete methods,introduced by Java9 version.

=>These private concrete methods are categorized into two types:
(i)NonStatic private concrete methods
(ii)static private Concrete methods
Coding Rule:

thi
i

=>These private concrete methods are accessed only inside the interface,
which means accessed by the NonPrivate methods of same interface.

ipa

Ex:
ITest.java

Ve
nk
ate
sh

Ma

package p1;
public interface ITest {
public abstract void showA(int a);
public static void showB(int b) {
System.out.println("****static concrete
showB(b)****");
System.out.println("The value b:"+b);
}
public default void showC(int c) {
System.out.println("****default concrete
showC(c)****");
System.out.println("The value c:"+c);
}
private static void showD(int d) {
System.out.println("****static private concrete
showD(d)****");
System.out.println("The value d:"+d);
}
private void showE(int e) {
System.out.println("****NonStatic private
concrete showE(e)****");
System.out.println("The value e:"+e);
}
public default void access(int d,int e) {

}

}

ITest.showD(d);
this.showE(e);

IClass.java

DemoInterface3.java(MainClass)

Ma

ipa

thi
i

package p1;
public class IClass implements ITest{
public void showA(int a)//Overriding and Implemented
method
{
System.out.println("****Implemented method
showA(a)****");
System.out.println("The value a:"+a);
}
}

Ve
nk
ate
sh

package p2;
import p1.*;
public class DemoInterface3 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.showA(12);
//IClass.showB(13);//Error
ITest.showB(13);
ob.showC(14);
//ITest.showD(15);//Error
//ob.showE(16);//Error
ob.access(15,16);
}
}
o/p:
****Implemented method showA(a)****

The value a:12
****static concrete showB(b)****
The value b:13
****default concrete showC(c)****

thi
i

The value c:14
****static private concrete showD(d)****

****NonStatic private concrete showE(e)****

Ma

The value e:16

ipa

The value d:15

==========================================================
Rule-13 : There is no concept of Blocks and Constructors in Interfaces.

Ve
nk
ate
sh

=======================================================

Rule-14 : Interfaces can be extended from another Interfaces using "extends"
Keyword,which means one interface can have features of another
interface.

Diagram:

Ex:

ITest1.java

package p1;
public interface ITest1 {
public abstract void showA(int a);
}

ITest2.java
package p1;
public interface ITest2 extends ITest1{
public abstract void showB(int b);
}

thi
i

IClass.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public class IClass implements ITest2{
public void showA(int a) {
System.out.println("****showA(a)****");
System.out.println("The value a:"+a);
}
public void showB(int b) {
System.out.println("****showB(b)****");
System.out.println("The value b:"+b);
}
}
DemoInterface4.java(MainClass)

package p2;
import p1.*;
public class DemoInterface4 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.showA(12);
ob.showB(13);
}
}
o/p:
****showA(a)****
The value a:12

****showB(b)****
The value b:13
===================================================================
=====
Comparision Diagram:

thi
i

===================================================================
====

*imp

Ma

Summary of Single Inheritance process:

ipa

dt : 11/5/2023

=================================================================

Ve
nk
ate
sh

*imp

Multiple Inheritance process using Interfaces:

Model-1 : Extracting the features from more than one interface
into a Class.

(Class implementing from more than one Interface)

Diagram:

Note:
(i)Same abstract method signatures in multiple Inheritance will
not effect the inheritance process.
(ii)Same static concrete methods in multiple inheritance will

methods are not available to implementation class.

thi
i

not effect the inheritance process,because the static concrete

(iii)when we have same default concrete methods in multiple

ipa

inheritance,will raise ambiguity at compilation stage and

Ma

which can be rectified

(iii)Same private concrete methods in Multiple Inheritance will
not effect the inheritance process,because the private methods

Ve
nk
ate
sh

are not available to implementation class.

Ex-program:
ITest1.java

package p1;
public interface ITest1 {
public abstract void showA(int a);
public static void showB(int b) {
System.out.println("***ITest1 static
showB(b)***");
System.out.println("The value b:"+b);
}
public default void showC(int c) {
System.out.println("***ITest1 default
showC(c)***");
System.out.println("The value c:"+c);

this.showD(16);

thi
i

}
private void showD(int d) {
System.out.println("***ITest1 private
showD(d)***");
System.out.println("The value d:"+d);
}
}
ITest2.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public interface ITest2 {
public abstract void showA(int a);
public static void showB(int b) {
System.out.println("***ITest2
showB(b)***");
System.out.println("The value
}
public default void showCC(int c) {
System.out.println("***ITest2
showC(c)***");
System.out.println("The value
this.showD(18);
}
private void showD(int d) {
System.out.println("***ITest2
showD(d)***");
System.out.println("The value
}
}

static
b:"+b);
default
c:"+c);

private
d:"+d);

IClass.java

package p1;
public class IClass implements ITest1,ITest2{
public void showA(int a) {
System.out.println("****Implemented method
showA(a)****");

}

}

System.out.println("The value a:"+a);

DemoMultipleInheritance1.java(MainClass)

Ve
nk
ate
sh

o/p:

Ma

ipa

thi
i

package p2;
import p1.*;
public class DemoMultipleInheritance1 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.showA(123);
ITest1.showB(12);
ITest2.showB(13);
ob.showC(14);
ob.showCC(15);
}
}

****Implemented method showA(a)****
The value a:123

***ITest1 static showB(b)***
The value b:12

***ITest2 static showB(b)***
The value b:13

***ITest1 default showC(c)***
The value c:14

***ITest1 private showD(d)***
The value d:16

***ITest2 default showC(c)***
The value c:15
***ITest2 private showD(d)***
The value d:18

thi
i

---------------------------------------------------------------Model-2 : Extracting the features from one class and any number of
Interfaces into a class.

ipa

(Class extends from one class and can be implemented from

Diagram:

Ve
nk
ate
sh

Ex-program:

Ma

any number of Interfaces)

PClass.java

package p1;
public class PClass {
public void m1(int x) {
System.out.println("****PClass m1(x)****");
System.out.println("The value x:"+x);
}
}
ITest.java

package p1;
public interface ITest {
public abstract void m2(int y);
}

IClass.java

thi
i

package p1;
public class IClass extends PClass implements ITest{
public void m2(int y) {
System.out.println("****Implemented method
m2(y)****");
System.out.println("The value y:"+y);
}
}

ipa

DemoMultipleInheritance2.java(MainClass)

Ve
nk
ate
sh

Ma

package p2;
import p1.*;
public class DemoMultipleInheritance2 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.m1(12);
ob.m2(14);
}
}
o/p:

****PClass m1(x)****
The value x:12

****Implemented method m2(y)****
The value y:14

---------------------------------------------------------------

Model-3 : Extracting the features from more than one interface
into an Interface.
(Interface extends from more than one Interfaces)

Diagram:

Ex-program:

ipa

package p1;
public interface ITest1 {
public abstract void m1(int x);
}

thi
i

ITest1.java

ITest2.java

Ma

package p1;
public interface ITest2 {
public abstract void m2(int y);
}

Ve
nk
ate
sh

ITest3.java

package p1;
public interface ITest3 extends ITest1,ITest2{
public abstract void m3(int z);
}
IClass.java

package p1;
public class IClass implements ITest3{
public void m1(int x) {
System.out.println("****Implemented method
m1(x)****");
System.out.println("The value x:"+x);
}
public void m2(int y) {
System.out.println("****Implemented method
m2(y)****");

System.out.println("The value y:"+y);

DemoMultipleInheritance3.java(MainClass)

thi
i

}
public void m3(int z) {
System.out.println("****Implemented method
m3(c)****");
System.out.println("The value z:"+z);
}
}

Ve
nk
ate
sh

Ma

ipa

package p2;
import p1.*;
public class DemoMultipleInheritance3 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.m1(11);
ob.m2(12);
ob.m3(13);
}
}
o/p:

****Implemented method m1(x)****
The value x:11

****Implemented method m2(y)****
The value y:12

****Implemented method m3(c)****
The value z:13

========================================================
Note:

Model-1 : java.lang.String Class
Model-2 : WrapperClasses
Model-3 : JDBC - java.sql.Connection Interface
=========================================================

thi
i

Dt : 12/5/2023
*imp
AbstractClasses:

ipa

=>The classes which are declared with "abstract" keyword are

Ma

known as "abstract Classes".

=>Abstract Classes can hold variables,abstract methods,Concrete
methods,blocks,constructors and features.

Ve
nk
ate
sh

=>Abstract methods in abstract classes must be declared with
"abstract" keyword.

=>AbstractClasses cannot be instantiated,which means we cannot
create object for AbstractClasses.

=>These AbstractClasses are extended to classes and the classes
are known as "Extention Classes" or "Implementation classes"

=>These "Extention Classes" must construct body for abstract
methods of AbstractClasses.

Ex:
AClass.java

thi
i

package p1;
public abstract class AClass {
public abstract void m1(int a);
public void showX(int x) {
System.out.println("***AClass showX(x)***");
System.out.println("The value x:"+x);
}
}
BClass.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public abstract class BClass extends AClass{
public abstract void m2(int b);
public void showY(int y) {
System.out.println("***BClass showY(y)***");
System.out.println("The value y:"+y);
}
}
EClass.java

package p1;
public class EClass extends BClass{
public void m1(int a) {
System.out.println("***Implemented method
m1(a)***");
System.out.println("The value a:"+a);
}
public void m2(int b) {
System.out.println("***Implemented method
m2(b)***");
System.out.println("The value b:"+b);
}
}
DemoAbstractClass.java(MainClass)

ipa

thi
i

package p2;
import p1.*;
public class DemoAbstractClass {
public static void main(String[] args) {
//BClass ob = new BClass();//Error
EClass ob = new EClass();
ob.m1(11);
ob.m2(12);
ob.showX(13);
ob.showY(14);
}
}
o/P:

The value a:11
***Implemented method m2(b)***

Ve
nk
ate
sh

The value b:12

Ma

***Implemented method m1(a)***

***AClass showX(x)***
The value x:13

***BClass showY(y)***
The value y:14

Diagram:

thi
i
ipa
Ma

=======================================================

Ve
nk
ate
sh

faq:
wt is the diff b/w
(i)Class

(ii)AbstractClass

=>Class holds only Concrete methods,but AbstractClass will hold
both abstract methods and Concrete methods.

=>Class can be instantiated ,but AbstractClass cannot be
instantiated.

faq:
wt is the diff b/w

(i)Interface
(ii)AbstractClass
=>Interface components are "public",but AbstractClass components
are "default"

thi
i

=>Variables in interface are automatically "static and final",but
Variables in AbstractClasses are user choice.

Classes will hold blocks and Constructors.

ipa

=>Interfaces cannot hold "blocks and Constructors",but Abstract

faq:
define Abstraction process?

Ma

=============================================================

Ve
nk
ate
sh

=>The process of hiding the background implementation from the

end-users is known as Abstraction process.

=>In Java,we use "Interfaces" and "AbstractClasses" to construct

Abstraction process.

=============================================================
faq:

define Encapsulation process?

=>The process of binding all the programming components into a
single unit class is known as Encapsulation process.

=>Class is Collection of Variables,Methods,Blocks,Constructors
and features.
============================================================
faq:

thi
i

define TypeCasting process?
=>The process of converting one datatype into another datatype
is known as TypeCasting process.

ipa

=>This TypeCasting process can be done in two ways:

(b)Narrowing process

Ve
nk
ate
sh

(a)Widening process:

Ma

(a)Widening process

=>The process of converting lower datatype into higher datatype

is known as Widening process.

=>This Widening process is also known as UpCasting process or

Implicit TypeCasting process.

char->byte->short->int->long->float->double

(b)Narrowing process:

=>The process of converting higher datatype into lower datatype
is known as Narrowing process.
=>This Narrowing process is also known as DownCasting process or

Explicit TypeCasting process.
double->float->long->int->short->byte->char

Ve
nk
ate
sh

Ma

ipa

thi
i

==============================================================

5/20/23, 10:04 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

Interface3.png

1/1

5/20/23, 10:05 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

Interface4.png

1/1

Dt : 13/5/2023
Ex : DemoTypeCasting.java

System.out.println("ASCII code of char n : "+k);
System.out.println("ASCII code of char N :

Ma

"+z);

ipa

thi
i

package maccess;
public class DemoTypeCasting {
public static void main(String[] args) {
char ch1 = 'n';
char ch2 = 'N';
//Widening process or UpCasting process
//Implicit Type casting
int k = (int)ch1;//Char to ASCII code
int z = (int)ch2;//Char to ASCII code

Ve
nk
ate
sh

int v1 = 65;
int v2 = 97;
//Narrowing process or DownCasting process
//Explicit Type Casting
char ch3 = (char)v1;
char ch4 = (char)v2;
System.out.println("char at ASCII code 65 :

"+ch3);
"+ch4);
}
}

System.out.println("char at ASCII code 97 :

o/p:

ASCII code of char n : 110
ASCII code of char N : 78
char at ASCII code 65 : A
char at ASCII code 97 : a

thi
i

=====================================================

ipa

*imp
Generalization process:

Generalization process.

Ma

=>The process of converting CClass into PClass is known as

Ve
nk
ate
sh

=>In Generalization process one object is created holding all the
members of PClass and Only Overriding members from the CClass.
syntax:

PClass ob = (PClass)new CClass();

=>This Generalization process can also be applied on Interfaces

and AbstractClasses.
syntax:

ITest ob = (ITest)new IClass();

AClass ob = (AClass)new EClass();

Ex-program:

PClass.java

ITest.java

Ma

ipa

thi
i

package p1;
public class PClass
{
public void m1(int x)
{
System.out.println("****PClass m1(x)****");
System.out.println("The value x:"+x);
}
public void m2(int y)
{
System.out.println("****PClass m2(y)****");
System.out.println("The value y:"+y);
}
}

Ve
nk
ate
sh

package p1;
public interface ITest {
public abstract void showA(int a);
public default void showB(int b) {
System.out.println("***ITest default
showB(b)***");
System.out.println("The value b:"+b);
}
}
CClass.java

package p1;
public class CClass extends PClass implements ITest{
public void m1(int x)//Overriding method
{
System.out.println("****CClass m1(x)****");
System.out.println("The value x:"+x);
}
public void m3(int z)//NonOverriding method

{

System.out.println("****CClass m3(z)****");
System.out.println("The value z:"+z);

ipa

DemoGeneralization1.java(MainClass)

thi
i

}
public void showA(int a) {
System.out.println("****ITest implemented
showA(a)****");
System.out.println("The value a:"+a);
}
}

Ve
nk
ate
sh

Ma

package p2;
import p1.*;
public class DemoGeneralization1 {
public static void main(String[] args) {
System.out.println("****Generalization on
Class****");
PClass ob1 = (PClass)new CClass();
ob1.m1(11);
ob1.m2(12);
//ob1.m3(13);
//ob1.showA(14);
System.out.println("****Generalization on
Interface****");
ITest ob2 = (ITest)new CClass();
ob2.showA(16);
ob2.showB(17);
//Specialization process
//CClass ob3 = (CClass)new PClass();
//raises Exception
}
}
o/p:
****Generalization on Class****

****CClass m1(x)****
The value x:11
****PClass m2(y)****
The value y:12

****ITest implemented showA(a)****
The value a:16

ipa

***ITest default showB(b)***

Ve
nk
ate
sh

Ma

The value b:17

Diagram:

thi
i

****Generalization on Interface****

thi
i
ipa
Ma
Ve
nk
ate
sh

==========================================================

*imp

Specialization process:

=>The process of taking one feature from the PClass and

constructing the CClass is known as Specialization process.
syntax:

CClass ob = (CClass)new PClass();
=>The process of converting PClass into CClass is known as
Specialization process.

=>Specialization process cannot be applied on Interfaces and
Abstract Classes.

Coding Rule:

Built-in class from the library,else raises

ipa

"java.lang.ClassCastException"

Ma

Ex for Specialization:
Cloning process

thi
i

=>To perform Specialization process the PClass must be Pre-defined

Serialization and DeSerialization process

Ve
nk
ate
sh

=======================================================

dt : 15/5/2023
Assignment:(Solution)

Student.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class Student {
public int studentId;
public String name;
public double examFee;
public Student() {}
public Student(int studentId,String name,double
examFee) {
this.studentId=studentId;
this.name=name;
this.examFee=examFee;
}
public String displayDetails() {
return "StudentId:"+studentId+"\nName:"+name+
"\nExamFee"+examFee;
}
public double payFee(int amt) {
return examFee;
}
}
DayScholar.java

package p1;
public class DayScholar extends Student{
public double transportFee;
public DayScholar() {}
public DayScholar(int studentId,String name,
double examFee,double transportFee) {
super(studentId,name,examFee);
this.transportFee=transportFee;
}

thi
i

}

public String displayDetails() {
return "transportFee:"+transportFee+
"\nstudentId:"+studentId+
"\nName:"+name+
"\nExamFee:"+examFee;
}
public double payFee(int amt) {
return amt-(examFee+transportFee);
}

ipa

Hosteller.java

Ve
nk
ate
sh

Ma

package p1;
public class Hosteller extends Student{
public double hostelFee;
public Hosteller() {}
public Hosteller(int studentId,String name,double
examFee,
double hostelFee) {
super(studentId,name,examFee);
this.hostelFee=hostelFee;
}
public String displayDetails() {
return "hostelFee:"+hostelFee+
"\nstudentId:"+studentId+
"\nName:"+name+
"\nExamFee:"+examFee;
}
public double payFee(int amt) {
return amt-(examFee+hostelFee);
}
}
DemoInheritance14.java(MainClass)
package p2;
import java.util.*;

import p1.*;
public class DemoInheritance14 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);

//transportFee=2000
//hostelFee=2000

Ma

int amt = Integer.parseInt(s.nextLine());

ipa

System.out.println("Enter the totalAmt(6000):");

thi
i

//examFee=2000

System.out.println("====Choice=====");
System.out.println("\t1.DayScholar"

Ve
nk
ate
sh

+ "\n\t2.Hosteller");

System.out.println("Enter the Choice:");

int choice = Integer.parseInt(s.nextLine());
switch(choice) {
case 1:

System.out.println("Enter the StudentId:");
int id = Integer.parseInt(s.nextLine());
System.out.println("Enter the StudentName:");
String name = s.nextLine();
System.out.println("Enter the ExamFee:");
double examFee = Double.parseDouble(s.nextLine());

System.out.println("Enter the TransportFee:");
double transportFee = Double.parseDouble(s.nextLine());
DayScholar ds = new DayScholar
(id,name,examFee,transportFee);

thi
i

System.out.println(ds.displayDetails());
System.out.println("returned Amt:"+ds.payFee(amt));
break;

ipa

case 2:

Ma

System.out.println("Enter the StudentId:");
int id2 = Integer.parseInt(s.nextLine());

System.out.println("Enter the StudentName:");

Ve
nk
ate
sh

String name2 = s.nextLine();

System.out.println("Enter the ExamFee:");
double examFee2 = Double.parseDouble(s.nextLine());
System.out.println("Enter the hostelFee:");
double hostelFee = Double.parseDouble(s.nextLine());
Hosteller hs = new Hosteller

(id2,name2,examFee2,hostelFee);

System.out.println(hs.displayDetails());
System.out.println("returned Amt:"+hs.payFee(amt));
break;

default:

System.out.println("Invalid Choice:");
}//end of switch
s.close();
}

thi
i

}
=========================================================
*imp

ipa

InnerClasses in Java:

innerclass or Nested class.

Ma

=>The process of declaring class inside the class is known as

=>These InnerClasses are categorized into the following:

Ve
nk
ate
sh

1.Member InnerClasses

2.Anonymous InnerClasses

1.Member InnerClasses:

=>The innerclasses which are declared as members of class are

known as Member InnerClasses.

=>These Member InnerClasses are categorized into two types:
(a)Static member InnerClasses

(b)NonStatic member InnerClasses

(a)Static member InnerClasses:
=>The member InnerClasses which are declared with "static"
keyword are known as Static member InnerClasses or Class member

thi
i

InnerClasses.

Coding Rules:

and NonStatic programming components.

ipa

(i)Static member InnerClasses can be declared with both static

Ma

(ii)Instance methods static member InnerClass can access static
variables of OuterClass directly,but cannot access instance
variables of OuterClass because there is no relation b/w

Ve
nk
ate
sh

InnerClass Object and OuterClass Object.

(iii)Static methods of Static member InnerClasses can access only
static variables of OuterClass and InnerClass directly,but
cannot access Instance variables.

you can access the private members of the static member inner class from the outer class through an instance of the inner class because the instance
has access to its own private members.

Text
syntax of Object creation for static member
InnerClasses:

OuterClass_name.InnerClass_name ob =

new OuterClass_name.InnerClass_name();

Ex:
SubClass1.SubClass2 ob2 = new SubClass1.SubClass2();

Program:
SubClass1.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class SubClass1 {
public int x=10;
public static int y=20;
public void m1() {
System.out.println("****OuterClass m1()****");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}//OuterClass method
public static class SubClass2{
public int a=100;
public static int b=200;
public void m2() {
System.out.println("****InnerClass Instance
m2()****");
System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
//System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
public static void m22() {
System.out.println("****InnerClass static
m22()****");
//System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
//System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
}//Static member InnerClass
}//OuterClass
DemoInnerClass1.java(MainClass)
package p2;
import p1.*;
public class DemoInnerClass1 {

thi
i

public static void main(String[] args) {
//OuterClass Object
SubClass1 ob1 = new SubClass1();
ob1.m1();//OuterClass method_call
//Static member InnerClass Object
SubClass1.SubClass2 ob2 = new
SubClass1.SubClass2();
ob2.m2();//InnerClass Instance method call
SubClass1.SubClass2.m22();
//InnerClass static method call
}

ipa

}

****OuterClass m1()****
The value x:10

Ve
nk
ate
sh

The value y:20

Ma

o/p:

****InnerClass Instance m2()****
The value a:100
The value b:200
The value y:20

****InnerClass static m22()****
The value b:200
The value y:20

The payroll system of an organization involves calculating the gross salary of each type of
employee and the tax applicable to each.
Create the following entity classes as described below.
Class Employee
Fields: id: int, name : String, basicSalary : double, HRAPer : double, DAPer : double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer
Class Manager
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double,
projectAllowance: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer + projectAllowance
Class Trainer
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double, batchCount:
int, perkPerBatch: double
Public Method: calculateGrossSalary() - returns a double
Calculate the gross salary as : basicSalary +HRAPer +DAPer +(batchCount * perkPerBatch)
Class Sourcing
Fields: id: int, name : String, basicSalary : double, HRAPer : double,DAPer : double,
enrollmentTarget: int, enrollmentReached: int, perkPerEnrollment: double
Public Method: calculateGrossSalary() - returns a double
Calculate
the
gross
salary
as
:
basicSalary
+HRAPer
+DAPer
+((enrollmentReached/enrollmentTarget)*100)*perkPerEnrollment)
Class TaxUtil
Fields: None
Public Methods:
calculateTax(Employee) - returns a double
calculateTax(Manager) - returns a double
calculateTax(Trainer) - returns a double
calculateTax(Sourcing) - returns a double
Tax Calculation Logic: If gross salary is greater than 30000 tax is 20% else, tax is 5%
Note : Attributes/Fields must be non-Private for the above classes.
A ClassObject class is given to you with the main Method. Use this class to test your solution.

Dt : 16/5/2023
Execution flow of above program:
ClassFiles:
SubClass1.class

thi
i

SubClass1$SubClass2.class

Ve
nk
ate
sh

Ma

ipa

DemoInnerClass1.class(MainClass)

==========================================================
(b)NonStatic member InnerClasses :

=>The member InnerClasses which are declared without "static"

keyword are known as NonStatic member InnerClasses.
=>NonStatic member InnerClasses are categorized into two types:
(i)Instance member InnerClasses
(ii)Local member InnerClasses

(i)Instance member InnerClasses:
=>The NonStatic member InnerClasses which are declared outside
the methods are known as Instance member InnerClasses or Object

thi
i

member InnerClasses.

Coding Rules:

ipa

(i)Instance member InnerClasses can be declared with both static

Ma

and NonStatic members.

(ii)Instance methods of Instance member InnerClasses can access
all the members of OuterClass directly,because InnerClass object

Ve
nk
ate
sh

will hold the reference of OuterClass object.
(The objects are inter-related)

(iii)The static methods of Instance member InnerClasses can access
only static members of OuterClass and InnerClass.

syntax of Object creation for Instance member InnerClass:
OuterClass_name.InnerClass_name ob =

OuterClass_Object_name.new InnerClass_name();

Ex-program:
SubClass1.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class SubClass1 {
public int x=10;
public static int y=20;
public void m1() {
System.out.println("****OuterClass m1()****");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}//OuterClass method
public class SubClass2{
public int a=100;
public static int b=200;
public void m2() {
System.out.println("****InnerClass Instance
m2()****");
System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
public static void m22() {
System.out.println("****InnerClass Static
m22()****");
//System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
//System.out.println("The value x:"+x);
System.out.println("The value y:"+y);
}
}//Instance member InnerClass
}//OuterClass
DemoInnerClass2.java(MainClass)

package p2;
import p1.*;
public class DemoInnerClass2 {
public static void main(String[] args) {
//OuterClass Object
SubClass1 ob1 = new SubClass1();
ob1.m1();//OuterClass method_call

thi
i

}

}

//Instance member InnerClass Object
SubClass1.SubClass2 ob2 = ob1.new SubClass2();
ob2.m2();//InnerClass instance method call
SubClass1.SubClass2.m22();
//InnerClass static method call

o/p:

ipa

****OuterClass m1()****

The value y:20
****InnerClass Instance m2()****

Ve
nk
ate
sh

The value a:100

Ma

The value x:10

The value b:200
The value x:10

The value y:20

****InnerClass Static m22()****
The value b:200
The value y:20

====================================================

Assignment:
Update above programs by initializing variable x,y,a and b using
Constructors.

Ve
nk
ate
sh

Ma

ipa

thi
i

=======================================================

Dt : 17/5/2023
Execution flow:(Instance member InnerClass)
ClassFiles:
SubClass1.class

thi
i

SubClass1$SubClass2.class

Ve
nk
ate
sh

Ma

ipa

DemoInnerClass2.class(MainClass)

===========================================================
*imp

(ii)Local member InnerClasses:
=>The NonStatic member InnerClasses which are declared inside
the methods are known as Local member InnerClasses.

=>Local member InnerClasses can be declared in both static
and NonStatic methods.
=>Local member InnerClass in Instance method will have behaviour
like Instance member InnerClass.

thi
i

=>Local member InnerClass in Static method will have behaviour
like Static member InnerClass.

ipa

Coding Rule:

where the classes are declared.

Ve
nk
ate
sh

Ex-program:

Ma

=>Local member InnerClass objects are created inside the methods

SubClass1.java

package p1;
public class SubClass1 {
public void m1(int x) {
class SubClass2{
public void m2(int x) {
System.out.println("****m2(x)****");
System.out.println("The value x:"+x);
}
}//Instance member InnerClass
SubClass2 ob2 = new SubClass2();
ob2.m2(x);
}//OuterClass Instance method
public static void m11(int y) {
class SubClass22{
public void m22(int y) {
System.out.println("****m22(y)****");

System.out.println("The value y:"+y);

}
}//Static member InnerClass
SubClass22 ob22 = new SubClass22();
ob22.m22(y);
}//OuterClass Static method
}//OuterClass

thi
i

DemoInnerClass3.java(MainClass)

Ve
nk
ate
sh

Ma

ipa

package p2;
import p1.*;
public class DemoInnerClass3 {
public static void main(String[] args) {
//OuterClass Object
SubClass1 ob1 = new SubClass1();
ob1.m1(11);//OuterClass Instance method
SubClass1.m11(12);//InnerClass Instance method
}
}
o/p:

****m2(x)****
The value x:11

****m22(y)****
The value y:12

---------------------------------------------------------

ClassFiles:

SubClass1.class
SubClass1$1SubClass2.class
SubClass1$1SubClass22.class

DemoInnerClass3.class(MainClass)
=========================================================
*imp
2.Anonymous InnerClasses:

thi
i

=>The InnerClasses which are declared without name are known as
Anonymous InnerClasses or Anonymous Local member InnerClasses
=>These Anonymous InnerClasses are categorized into two types:

ipa

(a)Anonymous InnerClass as Class extention

Ma

(b)Anonymous InnerClass as Implementation class

(a)Anonymous InnerClass as Class extention:

Ve
nk
ate
sh

=>The process of declaring CClass without name is known as

"Anonymous InnerClass as Class Extention".

syntax:

class PClass
{

//PClass_body

}

PClass ob = new PClass()
{

//CClass_body
};

Ve
nk
ate
sh

Ma

ipa

thi
i

-----------------------------------------------------

Dt : 18/5/2023
Ex-Program:
PClass.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class PClass
{
public void m1(int x)
{
System.out.println("****PClass m1(x)****");
System.out.println("The value x:"+x);
}
public void m2(int y)
{
System.out.println("****PClass m2(y)****");
System.out.println("The value y:"+y);
}
}
DemoAnonymous1.java(MainClass)

package p2;
import p1.PClass;
public class DemoAnonymous1
{
public static void main(String[] args)
{
//Anonymous InnerClass as Class Extension
PClass ob = new PClass()
{
public void m1(int x)//Overriding method
{
System.out.println("****Overriding
m1(x)****");
System.out.println("The value x:"+x);
}
public void m3(int z)//NonOverriding method
{

m3(z)****");
}
};

System.out.println("The value z:"+z);

ob.m1(12);
ob.m2(13);
//ob.m3(14);//Error

thi
i

}

System.out.println("****NonOverriding

ipa

}
o/p:

The value x:12
****PClass m2(y)****

Ma

****Overriding m1(x)****

Ve
nk
ate
sh

The value y:13

Execution flow of above program:
ClassFiles:

PClass.class

DemoAnonymous1.class(MainClass)
DemoAnonymous1$1.class

thi
i
ipa
Ma

Note:

Ve
nk
ate
sh

=>Generalization process using Classes is modified as "Anonymous
InnerClass as Class extension" model.

=============================================================

*imp

(b)Anonymous InnerClass as Implementation class:
=>The process of declaring implementation class without name

is known as Anonymous InnerClass as Implementation class.

syntax:
interface ITest
{

//Interface_body
}

ITest ob = new ITest()

thi
i

{
//IClass_body

ipa

};

ITest.java

Ma

Ex-program:

Ve
nk
ate
sh

package p1;
public interface ITest {
public abstract void m1(int x);
public default void m2(int y) {
System.out.println("****default m2(y)****");
System.out.println("The value y:"+y);
}
}
DemoAnonymous2.java(MainClass)

package p2;
import p1.ITest;
public class DemoAnonymous2 {
public static void main(String[] args) {
//Anonymous InnerClass as implementation class
ITest ob = new ITest()
{
public void m1(int x)//Overriding and implemented
{
System.out.println("***Implemented m1(x)***");

System.out.println("The value x:"+x);

o/p:
***Implemented m1(x)***

ipa

Ve
nk
ate
sh

The value x:11

Ma

}

}

ob.m1(11);
ob.m2(12);
//ob.m3(23);//Error

****default m2(y)****
The value y:12

Execution flow of above program:
ClassFiles:

ITest.class

DemoAnonymous2.class(MainClass)
DemoAnonymous2$1.class

thi
i

}
public void m3(int z)
{
System.out.println("***NonImplemented
m3(z)***");
System.out.println("The value z:"+z);
}
};

thi
i
ipa
Ma

Note:

=>Generalization process using Interfaces model is modified as

Ve
nk
ate
sh

"Anonymous InnerClass as Implementation class".

===============================================================

Note:

=>Anonymous InnerClass as implementation class model is modified

as LambdaExpression in Java8 version.

=======================================================

*imp

LambdaExpressions in Java:(Java8 - new feature)
=>The process of declaring method without method name is known as
LambdaExpression,and which is also known as Anonymous method.

Structure of LambdaExpression:

(para_list)->
{

thi
i

//method_body
}

ipa

Note:

Ma

=>This LambdaExpression is attached with the abstract method of

interface and we execute lambdaExpression with abstract method_name

Ve
nk
ate
sh

syntax:

Interface_name ob = (para_list)->
{

//body

};

Ex-program:
ITest.java

package p1;
public interface ITest {
public abstract void m1(int x);
public default void m2(int y) {
System.out.println("***default m2(y)***");

}

System.out.println("The value y:"+y);

}

DemoLambdaExpression1.java(MainClass)

Ve
nk
ate
sh

}

}

ob.m1(11);
ob.m2(12);

Ma

ipa

thi
i

package p2;
import p1.ITest;
public class DemoLambdaExpression1 {
public static void main(String[] args) {
//LambdaExpression
ITest ob = (int x)->
{
System.out.println("****Implemented m1(x)****");
System.out.println("The value x:"+x);
};

o/p:

****Implemented m1(x)****
The value x:11

***default m2(y)***
The value y:12

======================================================

Dt : 19/5/2023
Execution flow of above program:(Demonstrating LambdaExpression)
ClassFiles:
ITest.class

Ve
nk
ate
sh

Ma

ipa

thi
i

DemoLambdaExpression1.class(MainClass)

========================================================
Advantage of LambdaExpressions:
=>when we use LambdaExpressions,separate class files are not
generated and loading time of execution process is saved and
generate high performance of an application.

=========================================================
Coding Rules:
Rule-1 : The interface which provide abstract method to hold
LambdaExpression must be declared with only one abstract

thi
i

method and which is known as Functional Interface.
Rule-2 : The parameter-names used in LambdaExpression,the same
names must not be used to declare local variables within

ipa

the same method scope.

Ma

Rule-3 : LambdaExpressions will access the variables of Functional
interface using interface_name.

=======================================================

Ve
nk
ate
sh

Ex-program:(Variables with LambdaExpressions)
ITest.java

package p1;
//Functional Interface
public interface ITest {
public static final int x=10;
public abstract void showA(int a);
}
DemoLambdaExpression2.java(MainClass

package p2;
import p1.ITest;
public class DemoLambdaExpression2
{
public static int y=20;
public static void main(String[] args)

{

ipa

thi
i

int z = 30;
ITest ob = (int a)->
{
System.out.println("****Implemented
showA(a)****");
System.out.println("The value a:"+a);
System.out.println("The value x:"+ITest.x);
System.out.println("The value y:"+y);
System.out.println("The value z:"+z);
};
ob.showA(12);
}

o/p:
****Implemented showA(a)****

Ve
nk
ate
sh

The value a:12

Ma

}

The value x:10

The value y:20
The value z:30

==========================================================
Execution flow of above program:
ClassFiles:

ITest.class

DemoLambdaExpression2.class(MainClass)

thi
i
ipa
Ma

==========================================================

Ve
nk
ate
sh

Note:

=>While execution process the LambdaExpression will be executed

local to the method where it is declared.

=========================================================

faq:

wt is the diff b/w

(i)Normal Interface

(ii)Functional Interface
(iii)Marker Interface

(i)Normal Interface:

=>The interface which is declared with any number of abstract
methods is known as Normal interface.
Ex:
Collection<E>

thi
i

Map<K,V>

(ii)Functional Interface:

ipa

=>The interface which is declared with only one abstract method

methods in Functional Interface.
Ex:

Ve
nk
ate
sh

Predicate<T>

Ma

is known as Functional Interface,but we can declare concrete

BiPredicate<T,U>
Function<T>

BiFunction<T,U>
Consumer<T>

BiConsumer<T,U>

(iii)Marker Interface:

=>The interface which is declared with 0-methods is known as
Marker Interface.(Empty Interface is Marker Interface)
Ex:

Cloneable
Serializable
==========================================================
Assignment-1:

thi
i

Convert IComparable-Application into LambdaExpressions.
(GreaterValue and SmallerVlaue classes as LambdaExpressions)

ipa

Assignment-2:

Ma

Convert IArithmetic-Application into LambdaExpressions.

(Addition,Subtraction,Multiplication,Division,ModDivision class as
LambdaExpressions)

Ve
nk
ate
sh

============================================================

Dt : 20/5/2023
Assignment-1:(solution)
Convert IComparable-Application into LambdaExpressions.

thi
i

(GreaterValue and SmallerVlaue classes as LambdaExpressions)

IComparable.java

Ma

ipa

package p1;
public interface IComparable {
public abstract int compareTo(int x,int y);
}
DemoLambdaExpression3.java(MainClass)
package p2;

Ve
nk
ate
sh

import java.util.*;

import p1.IComparable;

public class DemoLambdaExpression3 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);

System.out.println("Enter the value-1:");
int v1 = s.nextInt();

System.out.println("Enter the value-2:");
int v2 = s.nextInt();
if(v1==v2) {
System.out.println("Values are equal...");

}else {
System.out.println("****Choice****");
System.out.println("\t1.GreaterValue"
+ "\n\t2.SmallerValue");

thi
i

System.out.println("Enter the Choice:");
int choice = s.nextInt();

case 1:

{
if(x>y) return x;

Ve
nk
ate
sh

else return y;

Ma

IComparable ob1 = (int x,int y)->

ipa

switch(choice) {

};

int r1 = ob1.compareTo(v1,v2);

System.out.println("GreaterValue:"+r1);
break;

case 2:

IComparable ob2 = (int x,int y)->
{

if(x<y) return x;
else return y;
};

int r2 = ob2.compareTo(v1, v2);
System.out.println("SmallerValue:"+r2);
break;
default:

thi
i

System.out.println("Invalid Choice...");
}//end of switch
}

ipa

s.close();

}
o/p:

Ve
nk
ate
sh

Enter the value-1:

Ma

}

12

Enter the value-2:
13

****Choice****

1.GreaterValue
2.SmallerValue

Enter the Choice:
1
GreaterValue:13

==============================================================
Assignment:
Construct BankTransaction Model using the following layout:

thi
i

a.Read pinNo
=>pinNo must be in b/w 1111 to 9999,else inValid pinNo

=>If the pinNo validated Successfully,then verify the pinNo is

ipa

among 1111 or 2222 or 3333,else "pinNo donot exist"

Ma

=>If the pinNo validation and verification failed for 3 times

then display the msg as "Transaction blocked" and stop the
program.

Ve
nk
ate
sh

b.If the pinNo validated and verifed Successfully,then show the
following options:
1.WithDraw
2.Deposit

1.WithDraw:

=>Enter the amt

=>The amt must be greater than zero and multiples of 100,else
"Invalid amt".
=>If the amt is validated Successfully,then create object
for WithDraw-class and pass amt as parameter to process()

method.
=>part of process() method check amt is less than balnace or
not.
=>If amt is less than bal then perform transaction,else

thi
i

"Insufficient fund"
o/p:
Amt WithDrawn :

ipa

Balance amt :

2.Deposit:

Ve
nk
ate
sh

=>Enter the amt

Ma

Transaction Successfull

=>The amt must be greater than zero and multiples of 100,else
"Invalid amt".

=>If the amt is validated Successfully,then create object
for Deposit-class and pass amt as parameter to process()

method.
o/p:

Amt Deposited :
Balance amt :

Transaction Successfull
=============================================================

Note:
=>Construct the application in three Models:

thi
i

Model-1 : Interface and Implementation classes with names.

Model-2 : Interface and Implementation classes without names

ipa

(Anonymous InnerClasses as implementation classes)

(LambdaExpressions)

Ma

Model-3 : Interface and Implementation classes as LambdaExpressions

==========================================================

Ve
nk
ate
sh

Dt : 22/5/2023

Model-1 : Interface and Implementation classes with names.
(Solution)

Balance.java

package p1;
public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}
}
CheckPinNo.java

ipa

Transaction.java

thi
i

package p1;
public class CheckPinNo {
public boolean verify(int pinNo) {
return switch(pinNo) {
case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}

Ve
nk
ate
sh

Ma

package p1;
//Functional Interface
public interface Transaction {
public static final Balance b=new Balance();
//Tightly Coupled reference
public abstract void process(int amt);
}
WithDraw.java

package p1;
public class WithDraw implements Transaction{
public void process(int amt) {
if(amt<=b.bal) {
System.out.println("Amt WithDrawn:"+amt);
b.bal = b.bal-amt;
System.out.println("Balance
amt:"+b.getBal());
System.out.println("Transaction
Successfully..");
}else {
System.out.println("InSufficient Fund...");
}
}
}

Deposit.java

ipa

thi
i

package p1;
public class Deposit implements Transaction{
public void process(int amt) {
System.out.println("Amt deposited:"+amt);
b.bal=b.bal+amt;
System.out.println("Balance amt:"+b.getBal());
System.out.println("Transaction
Successfull...");
}
}

package p2;
import p1.*;

Ma

BankMainClass.java(MainClass)

Ve
nk
ate
sh

import java.util.*;

public class BankMainClass {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
int count=0;
xyz:

while(true) {

System.out.println("Enter the PinNo:");
int pinNo = s.nextInt();
if(pinNo>=1111 && pinNo<=9999) {

CheckPinNo cpn = new CheckPinNo();
boolean k = cpn.verify(pinNo);
if(k) {
System.out.println("****Choice****");

+ "\n\t2.Deposit");

thi
i

System.out.println("\t1.WithDraw"

switch(s.nextInt()) {

Ma

case 1:

ipa

System.out.println("Enter the Choice:");

System.out.println("Enter the amt:");
int a1 = s.nextInt();

Ve
nk
ate
sh

if(a1>0 && a1%100==0) {

WithDraw wd = new WithDraw();
wd.process(a1);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

case 2:

System.out.println("Enter the amt:");
int a2 = s.nextInt();
if(a2>0 && a2%100==0) {

Deposit dp = new Deposit();
dp.process(a2);//method_call
}else {
System.out.println("Invalid amt...");

thi
i

}
break xyz;
default:

ipa

System.out.println("Invalid Choice...");

}//end of switch
}else {

Ma

break xyz;//stop the loop

Ve
nk
ate
sh

System.out.println("PinNo donot exist..");
count++;

}

}else {

System.out.println("Invalid PinNo...");
count++;

}

if(count==3) {

System.out.println("Sorry!Transaction Blocked...");
break;//stop the loop
}

}//end of loop
}

}

thi
i

------------------------------------------------------ClassFiles:
Balance.class

ipa

CheckPinNo.class

WithDraw.class
Deposit.class

Ve
nk
ate
sh

BankMainClass.class(MainClass)

Ma

Transaction.class

===========================================================
Model-2 : Interface and Implementation classes without names
(Anonymous InnerClasses as implementation classes)

(Solution)

Balance.java

package p1;
public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}
}

ipa

package p1;
public class CheckPinNo {
public boolean verify(int pinNo) {
return switch(pinNo) {
case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}

thi
i

CheckPinNo.java

Transaction.java

Ve
nk
ate
sh

Ma

package p1;
//Functional Interface
public interface Transaction {
public static final Balance b=new Balance();
//Tightly Coupled reference
public abstract void process(int amt);
}
BankMainClass.java(MainClass)
package p2;

import p1.*;

import java.util.*;

public class BankMainClass {

public static void main(String[] args) {
Scanner s = new Scanner(System.in);
int count=0;

xyz:
while(true) {
System.out.println("Enter the PinNo:");
int pinNo = s.nextInt();

CheckPinNo cpn = new CheckPinNo();
boolean k = cpn.verify(pinNo);

ipa

if(k) {

thi
i

if(pinNo>=1111 && pinNo<=9999) {

Ma

System.out.println("****Choice****");
System.out.println("\t1.WithDraw"
+ "\n\t2.Deposit");

Ve
nk
ate
sh

System.out.println("Enter the Choice:");
switch(s.nextInt()) {
case 1:

System.out.println("Enter the amt:");
int a1 = s.nextInt();

if(a1>0 && a1%100==0) {
//WithDraw class as Anonymous
Transaction wd = new Transaction()
{
public void process(int amt) {
if(amt<=b.bal) {

System.out.println("Amt
WithDrawn:"+amt);
b.bal = b.bal-amt;
System.out.println("Balance

System.out.println("Transaction Successfully..");

System.out.println("InSufficient Fund...");

Ma

}

ipa

}else {

thi
i

amt:"+b.getBal());

}

Ve
nk
ate
sh

};

wd.process(a1);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

case 2:

System.out.println("Enter the amt:");
int a2 = s.nextInt();
if(a2>0 && a2%100==0) {
//Deposit class as Anonymous

Transaction dp = new Transaction()
{
public void process(int amt) {
System.out.println("Amt
deposited:"+amt);

thi
i

b.bal=b.bal+amt;

System.out.println("Balance

ipa

amt:"+b.getBal());

System.out.println("Transaction

Ma

Successfull...");
}

};

Ve
nk
ate
sh

dp.process(a2);//method_call

}else {

System.out.println("Invalid amt...");

}

break xyz;

default:

System.out.println("Invalid Choice...");
break xyz;//stop the loop

}//end of switch
}else {
System.out.println("PinNo donot exist..");

count++;
}
}else {
System.out.println("Invalid PinNo...");

thi
i

count++;
}
if(count==3) {

ipa

System.out.println("Sorry!Transaction Blocked...");

}
}//end of loop

Ve
nk
ate
sh

}

Ma

break;//stop the loop

}

-------------------------------------------------------

ClassFiles:

Balance.class

CheckPinNo.class
Transaction.class

BankMainClass.class(MainClass)
BankMainClass$1.class
BankMainClass$2.class

==============================================================
Model-3 : Interface and Implementation classes as LambdaExpressions
(LambdaExpressions)

thi
i

(Solution)

Ve
nk
ate
sh

CheckPinNo.java

Ma

package p1;
public class Balance {
public double bal=2000;
public double getBal() {
return bal;
}
}

ipa

Balance.java

package p1;
public class CheckPinNo {
public boolean verify(int pinNo) {
return switch(pinNo) {
case 1111 : yield true;
case 2222 : yield true;
case 3333 : yield true;
default : yield false;
};
}
}
Transaction.java
package p1;
//Functional Interface
public interface Transaction {
public static final Balance b=new Balance();

}

//Tightly Coupled reference
public abstract void process(int amt);

BankMainClass.java(MainClass)
package p2;

thi
i

import p1.*;

public class BankMainClass {
public static void main(String[] args) {

Ma

Scanner s = new Scanner(System.in);

ipa

import java.util.*;

int count=0;

Ve
nk
ate
sh

xyz:
while(true) {

System.out.println("Enter the PinNo:");
int pinNo = s.nextInt();

if(pinNo>=1111 && pinNo<=9999) {

CheckPinNo cpn = new CheckPinNo();
boolean k = cpn.verify(pinNo);
if(k) {

System.out.println("****Choice****");
System.out.println("\t1.WithDraw"
+ "\n\t2.Deposit");

System.out.println("Enter the Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the amt:");

if(a1>0 && a1%100==0) {

thi
i

int a1 = s.nextInt();

//WithDraw class as LambdaExpression

ipa

Transaction wd = (int amt)->

Ma

{

if(amt<=Transaction.b.bal) {
System.out.println("Amt

Ve
nk
ate
sh

WithDrawn:"+amt);

Transaction.b.bal =

Transaction.b.bal-amt;

System.out.println("Balance

amt:"+Transaction.b.getBal());

System.out.println("Transaction Successfully..");
}else {

System.out.println("InSufficient Fund...");
}
};

wd.process(a1);//method_call
}else {
System.out.println("Invalid amt...");
}

thi
i

break xyz;
case 2:

int a2 = s.nextInt();

ipa

System.out.println("Enter the amt:");

Ma

if(a2>0 && a2%100==0) {

//Deposit class as LambdaExpression
Transaction dp =(int amt)->

Ve
nk
ate
sh

{

System.out.println("Amt

deposited:"+amt);

Transaction.b.bal=Transaction.b.bal+amt;

System.out.println("Balance

amt:"+Transaction.b.getBal());

System.out.println("Transaction

Successfull...");

};
dp.process(a2);//method_call
}else {

System.out.println("Invalid amt...");
}
break xyz;
default:

break xyz;//stop the loop
}//end of switch

ipa

}else {

thi
i

System.out.println("Invalid Choice...");

count++;
}

Ve
nk
ate
sh

}else {

Ma

System.out.println("PinNo donot exist..");

System.out.println("Invalid PinNo...");
count++;

}

if(count==3) {

System.out.println("Sorry!Transaction Blocked...");
break;//stop the loop

}

}//end of loop
}

}
------------------------------------------------------ClassFiles:
Balance.class

thi
i

CheckPinNo.class
Transaction.class
BankMainClass.class(MainClass)

ipa

==========================================================

Ma

Note:

=>"Anonymous InnerClass as Implementation class" model is used
for Normal Interfaces.

Ve
nk
ate
sh

=>LambdaExpressions is used for Functional Interfaces.

===========================================================
*imp

Method References in Java:(Java8 - new feature)
=>The process in which abstract method of Functional interface is

attached with the body of method from a class where the class is
not related to interface,is known as Method References Concept.
=>method references are categorized into three types:
(a)reference to Constructor
(b)reference to Instance method
(c)reference to Static method

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 23/5/2023
(a)reference to Constructor:
=>The process in which abstract method of functional interface is
attached with the body of Costructor is known as reference to

syntax:
Func_Interface_name ob = Class_name :: new;

ipa

Ex:

Ma

ITest ob1 = Display :: new;

(b)reference to Instance method:

thi
i

Constructor.

Ve
nk
ate
sh

=>The process in which abstract method of functional interface is

attached with the body of Instance method is known as reference to
Instance method.
syntax:

Func_Interface_name ob = Object_name::method_name;
Ex:

Display d = new Display(1);
ITest ob2 = d :: m1;

(c)reference to Static method:
=>The process in which abstract method of functional interface is

attached with the body of static method is known as reference to
Static method
syntax:
Func_Interface_name ob = Class_name :: method_name;

thi
i

Ex:
ITest ob3 = Display :: m2;
---------------------------------------------------------

ipa

Ex-application:
ITest.java

Ve
nk
ate
sh

Ma

package p1;
public interface ITest {
public static final int p=600;
public abstract void dis(int k);
}
Display.java

package p1;
public class Display {
public Display(int x) {
System.out.println("****Constructor Body****");
System.out.println("The value x:"+x);
}
public void m1(int y) {
System.out.println("****Instance method Body****");
System.out.println("The value y:"+y);
}
public static void m2(int z) {
System.out.println("****Static method Body****");
System.out.println("The value z:"+z);
}
}

DemoMethodReferences.java(MainClass)

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import p1.*;
public class DemoMethodReferences {
public static void main(String[] args) {
System.out.println("*****LambdaExpression****");
ITest ob = (int k)->
{
System.out.println("The value k:"+k);
};
ob.dis(100);
//reference to Constructor
ITest ob1 = Display :: new;
ob1.dis(200);
Display d = new Display(1);//Con_Call
//reference to Instance method
ITest ob2 = d :: m1;
ob2.dis(300);
//reference to static method
ITest ob3 = Display :: m2;
ob3.dis(400);
}
}

o/p:

*****LambdaExpression****
The value k:100

****Constructor Body****
The value x:200
****Constructor Body****

The value x:1
****Instance method Body****
The value y:300
****Static method Body****

thi
i

The value z:400

Ve
nk
ate
sh

Ma

ipa

Diagram:

========================================================
*imp
=>The following are the models used in Providing body for abstract

method of Interface:

Model-1 : Using Interface-Implementation classes
(Implementation classes with name)

thi
i

Model-2 : Using Interface-Anonymous InnerClasses
(Anonymous InnerClasses as implementation classes)
Model-3 : Using LambdaExpressions

ipa

Model-4 : Using Method references

*imp
InnerClasses in Interfaces:

Ma

=======================================================

Ve
nk
ate
sh

=>we can also declare InnerClasses in interfaces and which are

automatically static member InnerClasses

*imp

InnerClasses in AbstractClasses:

=>we can also declare InnerClasses in AbstractClasses and which

can be static member InnerClasses or NonStatic member InnerClasses.

Ex-Program:
ITest.java
package p1;

thi
i

public interface ITest {
public static class SubClass1{
public void m1(int a) {
System.out.println("***m1(a)****");
System.out.println("The value a:"+a);
}
}//Static member InnerClass
}//OuterInterface
AClass.java

Ve
nk
ate
sh

Ma

ipa

package p1;
public abstract class AClass {
public static class SubClass2{
public void m2(int x) {
System.out.println("****m2(x)****");
System.out.println("The value x:"+x);
}
}//Static member InnerClass
public class SubClass22{
public void m22(int y) {
System.out.println("****m22(y)****");
System.out.println("The value y:"+y);
}
}//Instance member InnerClass
}//OuterClass
DemoInnerClass4.java(MainClass)

package p2;
import p1.*;
public class DemoInnerClass4 {
public static void main(String[] args) {
System.out.println("----InnerClass in Interface---");
ITest.SubClass1 ob1 = new ITest.SubClass1();
ob1.m1(11);
System.out.println("---Static InnerClass in
AbstractClass----");

ipa

thi
i

AClass.SubClass2 ob2 = new AClass.SubClass2();
ob2.m2(12);
System.out.println("----Instance InnerClass in
ABstractClass----");
AClass ob = new AClass()
{
//No members
};
AClass.SubClass22 ob22 = ob.new SubClass22();
ob22.m22(13);
}
}
o/p:

***m1(a)****
The value a:11

Ma

----InnerClass in Interface----

Ve
nk
ate
sh

---Static InnerClass in AbstractClass---****m2(x)****
The value x:12

----Instance InnerClass in ABstractClass---****m22(y)****
The value y:13

====================================================

*imp
InnerInterfaces in Java:

(i)InnerInterfaces in Classes:
=>we can also declare InnerInterfaces in Classes and which can
be static member InnerInterfaces or NonStatic member InnerInterfaces.

thi
i

(ii)InnerInterfaces in Interfaces:
=>we can also declare InnerInterfaces in Interfaces and which

Ma

(iii)InnerInterfaces in AbstractClasses:

ipa

are automatically Static member InnerInterfaces.

=>we can also declare InnerInterfaces in AbstractClasses and
which can be static member InnerInterfaces or NonStatic member

Ve
nk
ate
sh

InnerInterfaces.

------------------------------------------------------

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh

===========================================================

Dt : 24/5/2023
Ex-Program:(Demonstrating InnerInterfaces)
SubClass.java

Ve
nk
ate
sh

ITest.java

Ma

ipa

thi
i

package p1;
public class SubClass {
public interface ITest1{
public abstract void m1(int a);
}//Instance member InnerInterface
public static interface ITest11{
public abstract void m11(int b);
}//Static member InnerInterface
}//OuterClass

package p1;
public interface ITest {
public static interface ITest2{
public abstract void m2(int x);
}//Static member InnerInterface
}//OuterInterface
AClass.java

package p1;
public abstract class AClass {
public interface ITest3{
public abstract void m3(int p);

DemoInnerInterface.java(MainClass)

thi
i

}//Instance member InnerInterface
public static interface ITest33{
public abstract void m33(int q);
}//Static member InnerInterface
}//OuterAbstractClass

Ve
nk
ate
sh

Ma

ipa

package p2;
import p1.*;
public class DemoInnerInterface {
public static void main(String[]
args) {
System.out.println("****Interface in
Class****");
SubClass.ITest1 ob1 = (int a)->
{
System.out.println("----m1(a)--");
System.out.println("The valu
a:"+a);
};
SubClass.ITest11 ob11 = (int b)>
{
System.out.println("---m11(b)---");

System.out.println("The valu

Ve
nk
ate
sh

Ma

ipa

thi
i

b:"+b);
};
ob1.m1(11);
ob11.m11(12);
System.out.println("****Interface in
Interface****");
ITest.ITest2 ob2 = (int x)->
{
System.out.println("----m2(x)--");
System.out.println("The valu
x:"+x);
};
ob2.m2(13);
System.out.println("****Interface in
AbstractClass****");
AClass.ITest3 ob3 = (int p)->
{
System.out.println("----m3(p)--");
System.out.println("The valu
p:"+p);
};
AClass.ITest33 ob33 = (int q)->
{
System.out.println("---m33(q)---");

q:"+q);
};
ob3.m3(14);
ob33.m33(16);
}
}

ipa

o/p:
****Interface in Class****

----m11(b)---

Ma

----m1(a)--The valu a:11

thi
i

System.out.println("The valu

Ve
nk
ate
sh

The valu b:12

****Interface in Interface****
----m2(x)---

The valu x:13

****Interface in AbstractClass****
----m3(p)---

The valu p:14
----m33(q)---

The valu q:16
=======================================================
*imp

InnerAbstractClasses in Java:
(i)InnerAbstractClasses in Class:
=>we can also declare InnerAbstractClasses in Classes and which
can be Static member InnerAbstractClasses or NonStatic member

thi
i

InnerAbstractClasses.

(ii)InnerAbstractClasses in Interfaces:

ipa

=>we can also declare InnerAbstractClasses in Interfaces and

Ma

which are automatically Static member InnerAbstractClasses.

(iii)InnerAbstractClasses in AbstractClasses:

Ve
nk
ate
sh

=>we can also declare InnerAbstractClasses in AbstractClasses

and which can be Static member InnerAbstractClasses or NonStatic
member InnerAbstractClasses

Ex-Program:(Assignment)

==========================================================

*imp

Summary of Programming Components(Java Alphabets)
(a)Variables
1.Primitive Datatype variables(values)
(i)static

(ii)NonStatic
=>Instance
=>Local
2.NonPrimitive Datatype variables(object references)

thi
i

(i)static
(ii)NonStatic
=>Instance

ipa

=>Local

1.static methods

Ma

(b)Methods

Ve
nk
ate
sh

2.NonStatic methods(Instance methods)

(c)Blocks

1.static blocks

2.NonStatic blocks(Instance blocks)

(d)Constructors

=>NonStatic Constructor

(e)Classes
1.Static Classes(Only InnerClasses as static)
2.NonStatic Classes

(f)Interfaces
1.static Interfaces(Only InnerInterfaces as static)

thi
i

2.NonStatic Interfaces

(g)AbstractClasses

1.static AbstractClasses(Only InnerAbstractClasses as static)

ipa

2.NonStatic AbstractClasses

Ma

===========================================================
*imp

Ve
nk
ate
sh

Design Models used in Application development:

Design-Model-1 : In this model "Anonymous InnerClass as
implementation class" is declared inside the
method of SubClass.

Diagram:

Ex-program:
ITest.java

package p1;
public interface ITest {

ipa

thi
i

public abstract void m1(int x);
public default void m2(int y) {
System.out.println("****default
m2(y)****");
System.out.println("The value
y:"+y);
}
}
Access.java

Ve
nk
ate
sh

Ma

package p1;
public class Access {
public static ITest getRef() {
ITest ob = new ITest()
{
public void m1(int x)
{
System.out.println("****Implemented
m1(x)****");
System.out.println("The
value x:"+x);
}
};
return ob;
}//OuterClass method
}

DesignModel1.java(MainClass)

o/p:

Ve
nk
ate
sh

****Implemented m1(x)****

Ma

ipa

thi
i

package p2;
import p1.*;
public class DesignModel1 {
public static void main(String[]
args) {
ITest ob = Access.getRef();
ob.m1(11);
ob.m2(12);
}
}

The value x:11

****default m2(y)****
The value y:12

--------------------------------------------------------

Design-Model-2 : In this model "LambdaExpression" is declared
inside the method of SubClass.

Diagram:

Ex-program:

ITest.java

Access.java

Ma

ipa

thi
i

package p1;
public interface ITest {
public abstract void m1(int x);
public default void m2(int y) {
System.out.println("****default
m2(y)****");
System.out.println("The value
y:"+y);
}
}

Ve
nk
ate
sh

package p1;
public class Access {
public static ITest getRef() {
return (int x)->
{
System.out.println("****Implemented
m1(x)****");
System.out.println("The
value x:"+x);
};
}

}//OuterClass method

DesignModel2.java(MainClass)

Ve
nk
ate
sh

o/p:

Ma

ipa

thi
i

package p2;
import p1.*;
public class DesignModel2 {
public static void main(String[]
args) {
ITest ob = Access.getRef();
ob.m1(11);
ob.m2(12);
}
}

****Implemented m1(x)****
The value x:11

****default m2(y)****
The value y:12

============================================================
Dt : 25/5/2023
*imp

Exception Handling process in Java:

define Exception?

=>The disturbance which is occured from the application is known
as Exception.

define Exception handling process?

thi
i

=>The process which is used to handle the exception is known as
Exception handling process.

=>The following blocks are used in exception handling process:

ipa

1.try

3.finally

Ma

2.catch

=>These blocks are executed automatically when exception is raised

Ve
nk
ate
sh

---------------------------------------------------1.try:

=>"try" block will hold the statements which are going to raise

the exception.
syntax:
try
{

//statements

}

Execution behaviour of try:

=>when exception raised in try-block then one object is created
for exception-type-class and the object-reference is thrown onto
catch block.

thi
i

2.catch:
=>"catch" block will hold the object reference thrown from the

"try" block and the required msg generated from the catch-block.

ipa

syntax:

{
//msg

Ve
nk
ate
sh

}

Ma

catch(Exception-type-class ref-var)

3.finally:

=>"finally" block is part of exception handling process but

executed independently without depending on exception.
=>In realtime finally-block will hold resource closing operations

like IO Close,file close,DB close,...
syntax:
fially
{
//statements

}
=============================================================

*imp

thi
i

Use the following steps to handle User defined exception:

step-1 : The user defined class must be extended from pre-defined

Ma

ipa

java.lang.Exception class

step-2 : The user defined class must be declared with parameterized

Ve
nk
ate
sh

constructor with string as parameter.

step-3 : The parameterized constructor will pass the msg to Parent
class "Exception" using "super()"

step-4 : declare exception-condition

step-5 : If the exception-condition is "true" then create object
for User defined class and while object creation pass
exception-msg as parameter

step-6 : Throw the object-reference onto catch block using "throw"

keyword

step-7 : Display the msg from the catch block
--------------------------------------------------------------

wap to read bSal of an employee and calculate totSal?

ipa

(using Exception handling process)

thi
i

Ex-program:

Program : DemoException1.java

Ve
nk
ate
sh

Ma

package maccess;
import java.util.*;
public class DemoException1 extends Exception
{
public DemoException1(String msg)
{
super(msg);
}
public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
try
{
System.out.println("Enter the emp bSal:");
int bSal = s.nextInt();//Exception for
NonInteger value
if(bSal<12000)//Exception
{
DemoException1 ob =
new DemoException1("Invalid
bSal..");
throw ob;
}

float totSal =
bSal+(0.93F*bSal)+(0.61F*bSal);
System.out.println("****Details****");
System.out.println("BSal:"+bSal);
System.out.println("TotSal:"+totSal);

thi
i

value...");

}
catch(InputMismatchException ime)
{
System.out.println("Enter only Integer

Ve
nk
ate
sh

}

}

Ma

ipa

}
catch(DemoException1 ob)
{
System.out.println(ob.getMessage());
}
finally
{
s.close();
}

o/p:

Enter the emp bSal:
15000

****Details****
BSal:15000

TotSal:38100.0

Diagraam-1:(Demonstrating Pre-defined Exception)

thi
i
ipa

Ve
nk
ate
sh

Ma

Diagram-2:(Demonstrating User defined Exception)

==============================================================

Dt : 26/5/2023
define 'Throwable'?
=>"Throwable" is a class from java.lang package and which is
root of exception handling process.

thi
i

=>This "Throwable" class is extended to the following two
SubClasses:
1.Error class

Ma

Ve
nk
ate
sh

Hierarchy of Throwable:

ipa

2.Exception class

----------------------------------------------------1.Error class:
=>The distrurbance which is occured from the environment is known
as error.

the errors occurs from the environment.

ipa

=>There is no separate process to handle the error.

thi
i

=>"java.lang.Error" class is the SuperClass or ParentClass of all

Ma

2.Exception class:

=>The disturbance which is occured from the application is known
as exception.

Ve
nk
ate
sh

=>"java.lang.Exception" class is the SuperClass or ParentClass of

all the exceptions raised from the application.
---------------------------------------------------------------

*imp

Types of exceptions:

=>The exceptions raised from the application are categorized into

two types:

1.UnChecked Exceptions
2.Checked Exceptions

1.UnChecked Exceptions:

=>The exceptions which are not identified by the compiler at
Compilation stage will be raised at execution stage are known as
UnChecked Exceptions or Runtime Exceptions.

thi
i

2.Checked Exceptions:
=>The exceptions which are identified and raised by the compiler

at compilation stage are known as Checked Exceptions or Compile

Ma

Ve
nk
ate
sh

Diagram:

ipa

time exceptions

thi
i
ipa
Ma
Ve
nk
ate
sh

============================================================

*imp

Types of UnChecked Exceptions:

=>Unchecked Exceptions are categorized into two types:
(a)Pre-defined UnChecked Exceptions

(b)User defined UnChecked Exceptions

(a)Pre-defined UnChecked Exceptions:
=>The UnChecked exceptions which are defined and available from

JavaLib are known as Pre-defined UnChecked Exceptions or Built-in
UnChecked Exceptions.
Ex:
java.util.InputMismatchException

thi
i

java.lang.NumberFormatException

(b)User defined UnChecked Exceptions:

ipa

...

Ma

=>The UnChecked Exceptions which are defined by the programmer
are known as User defined UnChecked Exceptions.

Ve
nk
ate
sh

Ex:

above program : DemoException1.java

==============================================================

Ex-2 :

wap to raed 6 sub marks and calculate,totMarks and percentage?
(Validate marks using Exception handling process)

Program : DemoException2.java

package maccess;
import java.util.*;
public class DemoException2 extends Exception
{
public DemoException2(String msg)

{

super(msg);

Ve
nk
ate
sh

Ma

ipa

thi
i

}
public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
try
{
System.out.println("Enter number of
Subjects:");
int n = Integer.parseInt(s.nextLine());
//Exception for NonInteger value
int i=1,totM=0;
System.out.println("Enter the "+n+" Sub
marks...");
while(i<=n)
{
try
{
System.out.println("Enter the marks of
sub-"+i);
int sub =
Integer.parseInt(s.nextLine());
//Exception for NonInteger value
if(sub<0 || sub>100)//Exception
{
DemoException2 ob =
new
DemoException2("Invalid Marks..");
throw ob;
}
totM=totM+sub;
i++;
}
catch(NumberFormatException nfe)
{
System.out.println("Enter Only Integer
value");
}
catch(DemoException2 ob)

{

System.out.println(ob.getMessage());

}

Ve
nk
ate
sh

}

Ma

ipa

thi
i

}
}//end of of loop
System.out.println("****details****");
System.out.println("TotalMarks:"+totM);
float per = (float)totM/n;
System.out.println("Percentage:"+per);
}
catch(NumberFormatException e)
{
System.out.println("Enter only Integer
value..");
}
finally
{
s.close();
}

o/p:

Enter number of Subjects:
8

Enter the 8 Sub marks...

Enter the marks of sub-1
78

Enter the marks of sub-2
89
Enter the marks of sub-3

90
Enter the marks of sub-4
95
Enter the marks of sub-5

thi
i

96
Enter the marks of sub-6
97

ipa

Enter the marks of sub-7

Enter the marks of sub-8
94

Ve
nk
ate
sh

****details****

Ma

95

TotalMarks:734

Percentage:91.75

=============================================================

Dt : 27/5/2023
*imp
Types of Checked Exceptions:
=>Checked Exceptions are categorized into two types:
(a)Pre-defined Checked Exceptions

ath

ii

(b)User defined Checked Exceptions

(a)Pre-defined Checked Exceptions:

aip

=>The Checked Exceptions which are defined and available from
JavaLib are known as Pre-defined Checked Exceptions or Built-in

Ve
nk
ate
sM

Checked Exceptions.
Ex:

java.lang.ClassNotFoundException

java.lang.CloneNotSupportedException
java.io.IOException

java.sql.SQLException

---------------------------------------------------------faq:

define forName() method?
=>forName() method is from "java.lang.Class" and which is used
to load the class at runtime or execution time,which means the class

is loaded at execution stage.

Method Signature:
public static java.lang.Class<?> forName(java.lang.String)

ath

ii

throws java.lang.ClassNotFoundException;

Class c = Class.forName("Class_name");

Ve
nk
ate
sM

Note:

aip

syntac:

=>"throws" keyword with method signature specify to raise the

exception at method call.

=>when exception raised at method call,then compiler will identify

the exception and comes under Checked Exception or Compile time
Exception.

----------------------------------------------------

Note:

=>"new" keyword cannot create object for the class loaded at

execution time or runtime.
=>we use newInstance() method from java.lang.Class to create
object for the class loaded at runtime or execution time.

Method Signature:
public T newInstance() throws java.lang.InstantiationException,
java.lang.IllegalAccessException;

ath

ii

Ex-program :
Display.java

Ve
nk
ate
sM

aip

package p1;
public class Display {
public void dis(int x) {
System.out.println("****method dis(x)****");
System.out.println("The value x:"+x);
}
}
DemoException3.java

package p2;
public class DemoException3 {
public static void main(String[] args) {
try
{
Class c =
Class.forName("p1.Display");//method_call
p1.Display ob = (p1.Display)c.newInstance();
ob.dis(123);
}
catch(ClassNotFoundException cnfe)
{
cnfe.printStackTrace();
}
catch(InstantiationException ie)
{
ie.printStackTrace();

ath

ii

}

}

}
catch(IllegalAccessException iae)
{
iae.printStackTrace();
}
// Display d = new Display();
//d.dis(123);

****method dis(x)****
The value x:123

aip

o/p:

Ve
nk
ate
sM

===========================================================

Assignment:

Convert BankTransaction process-Model-1 into Exception Handling
process.

===============================================================

Dt : 29/5/2023
*imp
(b)User defined Checked Exceptions
=>The Checked Exceptions which are defined and raised by the

thi
i

programmer are known as User defined Checked Exceptions.
=>The use the following steps to define and raise user defined
Checked Exceptions:

ipa

step-1 : Add "throws" keyword to method signature and raise the

Ma

exception at method call

step-2 : Add "throw" keyword in catch-block and perform re-throwing

Ve
nk
ate
sh

process.

Program :

Calculate.java

package p1;
@SuppressWarnings("serial")
public class Calculate extends Exception
{
public Calculate(String msg)
{
super(msg);
}
public double cal(double val)throws Calculate
{
try
{

}
return Math.sqrt(val);
}//end of try
catch(Calculate c2)
{
throw c2;//re-throwing
}

ipa

}

DemoException4.java(MainClass)
package p2;

Ve
nk
ate
sh

import p1.Calculate;

Ma

}

throw c2;

thi
i

val...");

if(val<=0)//Exception
{
Calculate c2 = new Calculate
("Enter Only +ve numeric

import java.util.*;

public class DemoException4
{

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
try
{

System.out.println("Enter the value to cal SQRT:");
double v = Double.parseDouble(s.nextLine());

Calculate c1 = new Calculate("");
double res = c1.cal(v);
System.out.println("SQRT of "+v+" is "+res);
}//end of try

System.out.println(ob.getMessage());
}

Ma

catch(NumberFormatException nfe)

ipa

{

thi
i

catch(Calculate ob)

{

System.out.println("Enter only Numeric value...");

Ve
nk
ate
sh

}

finally
{

s.close();
}

}

}

o/p:

Enter the value to cal SQRT:
1234.56
SQRT of 1234.56 is 35.136306009596396

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:

=============================================================
faq:

define Exception re-throwing process?
=>The process of declaring "throw" keyword in catch-block and
throwing the exception is known as Exception re-throwing process.

=>In Exception re-throwing process the exception is thrown to
the catch-block of try-block where method call is declared.

faq:

thi
i

define Exception Propagation?
=>In Exception re-throwing process the exception is moved from

one method to another method is known as Exception Propagation.

ipa

=============================================================

wt is the diff b/w
(i)throw

Ve
nk
ate
sh

(ii)throws

Ma

faq:

(i)throw:

=>"throw" keyword will throw the object reference onto catch
block.

(ii)throws:

=>"throws" keyword added with method signature and raise the
exception at method call

=============================================================
faq:

define Annotation?

Annotations in Java are a form of metadata that can be added to various elements of a program, such
as classes, interfaces, methods, variables, and more. They provide additional information about the code
to the compiler, runtime environment, or other tools.

=>The tag based information which is added to the programming
component Class,Interface,method,variable is known as Annotation.
=>we use "@" symbol to add annotations in Java.

thi
i

=>Annotations will provide information to compiler at compilation
stage.

=>The following are some important annotations in CoreJava:

ipa

(i)@SuppressWarnings

(i)@SuppressWarnings:

Ma

(ii)@Override

Ve
nk
ate
sh

=>"@SuppressWarnings" annotation will give information to

compiler to close the raised warnings.

(ii)@Override:

=>"@Override" annotation will give information to Compiler to

check the method is Overriding method or not.
===========================================================

Annotations can serve multiple purposes, including:
Providing information to the compiler: Annotations can be used to specify additional details about classes, methods, or variables that the compiler
can use for processing or verification. For example, the "@Override" annotation indicates that a method is intended to override a superclass
method, and the compiler will generate an error if the method doesn't actually override any method.
Enabling runtime processing: Some annotations are used by the runtime environment or frameworks to perform certain actions or configurations at
runtime. For example, the "@Entity" annotation in Java Persistence API (JPA) marks a class as an entity to be persisted in a database.
Documentation and code organization: Annotations can be used to generate documentation or provide hints and guidelines to developers. For
example, the "@Deprecated" annotation indicates that a method or class is deprecated and should not be used anymore.
Customization and extension: Annotations can be created by developers to define custom behaviors, configurations, or restrictions within their
code or frameworks.

Dt : 1/6/2023
*imp
Handling Multiple Exceptions:
=>We use the following two ways to handle multiple exceptions:

thi
i

(i)Using Multiple catch blocks to a try block
syntax:
try

ipa

{

//Exception-2
}

Ve
nk
ate
sh

catch(Exception-1 ob)

Ma

//Exception-1

{

//msg

}

catch(Exception-2 ob)
{

//msg

}

(ii)From Java7 version onwards we use single catch-block to a
try-block

syntax:
try
{
//Exception-1

}
catch(Exception-1 | Exception-2 | ... ob)

ipa

{

Ma

//msg
}

thi
i

//Exception-2

================================================================

Ve
nk
ate
sh

faq:

define try-with-resource?

=>try-with-resource statement is introduced by Java7 version and

in which the try is declared with resource.
syntax:

try(resource1;resource2;...)
{

//statements

}

Ex:

try(Scanner s = new Scanner(System.in);)
{
//statements

Advantage:

thi
i

}

=>In try-with-resource statement the resources are closed

ipa

automatically,which means no need to use finally-block.

Ma

=>In try-with-resource statement catch-block is not manditory,
which means catch-block is optional.

Ve
nk
ate
sh

Coding Rule:

=>The resource-class which is used in try-with-resource Statement

must be implementation class of "java.lang.AutoCloseable" interface.

Ex:

"Scanner-class" is implementation of "AutoCloseable" interface

Diagram:

Ma

ipa

thi
i

It's important to note that for a resource class to be used with "try-with-resources", it must implement the AutoCloseable interface or its subinterface, Closeable. Otherwise, a compilation error will occur.

============================================================

Ve
nk
ate
sh

faq:

define Enhanced try-with-resource statement?
=>Enhanced try-with-resource statement introduced by Java9

version and in which the resources are declared outside the try and
resource-ref-variables are declared with try.

syntax:

resource1;resource2;...

try(res1_var;res2_var;...)
{
//statements

}

Ex:
Scanner s = new Scanner(System.in);

thi
i

try(s;)
{
//statements

ipa

}

Ex : BankTransaction-Model

Ve
nk
ate
sh

Balance.java

Ma

==============================================================

CheckPinNo.java
Transaction.java
WithDraw.java
Deposit.java

=>Code not modified

DemoException5.java

(MainClass Modified with Exception handling process)
package p2;
import java.util.*;

import p1.*;
@SuppressWarnings("serial")
public class DemoException5 extends Exception
{

thi
i

public DemoException5(String msg)
{

}

Ma

public static void main(String[] args)

ipa

super(msg);

{

Scanner s = new Scanner(System.in);

Ve
nk
ate
sh

try(s;){

int count=0;

xyz:while(true) {
try
{

System.out.println("Enter the PinNo:");
int pinNo = s.nextInt();
if(!(pinNo>=1111 && pinNo<=9999))//Exception
{
DemoException5 de = new

DemoException5

("Invalid pinNo..");
throw de;
}
CheckPinNo cpn = new CheckPinNo();

thi
i

boolean k = cpn.verify(pinNo);
if(!k)//Exception
{

ipa

DemoException5 de = new
DemoException5

Ma

("PinNo donot exits...");

throw de;

Ve
nk
ate
sh

}

System.out.println("****Choice****");
System.out.println("\t1.WithDraw"
+ "\n\t2.Deposit");

System.out.println("Enter the Choice:");
switch(s.nextInt()) {
case 1:

try
{

System.out.println("Enter the
amt:");

int a1 = s.nextInt();
if(!(a1>0 &&
a1%100==0))//Exception
{
DemoException5 de = new

thi
i

DemoException5
("Invalid amt..");

}

ipa

throw de;

Ma

WithDraw wd = new WithDraw();
wd.process(a1);

}//end of try

Ve
nk
ate
sh

catch(DemoException5 ob)
{

System.out.println(ob.getMessage());

break xyz;

}

break xyz;

case 2:

try
{

System.out.println("Enter the
amt:");
int a2 = s.nextInt();
if(!(a2>0 &&
a2%100==0))//Exception

thi
i

{
DemoException5 de = new
DemoException5

ipa

("Invalid amt..");

Ma

throw de;

}

Deposit dp = new Deposit();

Ve
nk
ate
sh

dp.process(a2);

}//end of try
catch(DemoException5 ob)
{

System.out.println("Invalid amt..");

}

break xyz;

default:

System.out.println("Invalid Choice...");
}//end of switch
}//end of try

catch(DemoException5 ob)
{
System.out.println(ob.getMessage());
count++;

thi
i

if(count==3)
{

System.out.println("Transaction

ipa

blocked..");

}
}

Ve
nk
ate
sh

}//end of loop

Ma

break xyz;//stop the loop

}//end of try

}

}

========================================================

Dt : 2/6/2023
faq:
wt is diff b/w
(i)getMessage()

thi
i

(ii)toString()

ipa

(iii)printStackTrace()

Ma

(i)getMessage():

=>getMessage() method is used to display only msg available
exception object.

Ve
nk
ate
sh

syntax:

String msg = ob.getMessage();

(ii)toString():

=>toString() method is used to display exception-class and

msg.

syntax:

String msg = ob.toString();

(iii)printStackTrace():
=>printStackTrace() method is used to display the complete details

of exception like exception-class-name,msg,method_name and Line_no.
syntax:
ob.printStackTrace();
==========================================================

thi
i

faq:
wt is the diff b/w
(i)InputMismatchException

Ma

ipa

(ii)NumberFormatException

=>exception in parseMethods will be NumberFormatException.

Ve
nk
ate
sh

=>exception in Scanner-methods will be InputMismatchException

faq:

define NullPointerException?

=>"NullPointerException" is raised when we perform operations

using NonPrimitive datatype variables holding "null" value.

EX-program : DemoException6.java(MainClass)
package maccess;
import java.util.*;
public class DemoException6
{
public static String name;

Ve
nk
ate
sh

Ma

ipa

thi
i

public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
try(s;)
{
try
{
System.out.println("Enter the value-1:");
int v1 =
Integer.parseInt(s.nextLine());
System.out.println("Enter the value2:");
int v2 = s.nextInt();
System.out.println("*****Values****");
System.out.println("Value-1:"+v1);
System.out.println("Value-2:"+v2);
System.out.println("Name : "+name);
System.out.println("length of name :
"+name.length());
}
catch(InputMismatchException |
NumberFormatException ob)
{
System.out.println("Only Integer
values...");
System.out.println(ob.getClass());
}
catch(NullPointerException npe)
{
System.out.println("Using Reference
Variable holding null value..");
System.out.println(npe.getClass());
}
}//end of try with resource

}

}

o/p:
Enter the value-1:
12
Enter the value-2:

thi
i

13
*****Values****
Value-1:12

ipa

Value-2:13

Ma

Name : null
Using Reference Variable holding null value..
class java.lang.NullPointerException

Ve
nk
ate
sh

======================================================

*imp

PolyMorphism in Java:

=>The process in which programming components having more than

one form is known as PolyMorphism.
Poly - Many

Morphism - Forms

=>PolyMorphism is categorized into two types:
1.Dynamic PolyMorphism
2.Static PolyMorphism

1.Dynamic PolyMorphism:
=>The PolyMorphism at execution stage is known as Dynamic
PolyMorphism or Runtime PolyMorphism.
Ex:

thi
i

Method Overriding process.

Note:

ipa

=>Through Method Overriding process we can provide more than

Ma

one form of same method at execution stage,because of this reason
Method Overriding process comes under Dynamic PolyMorphism.

Ve
nk
ate
sh

2.Static PolyMorphism:

=>The PolyMorphism at compilation stage is known as Static

PolyMorphism or Compile time PolyMorphism.
Ex:

Method Overloading process

Note:

=>Through Method Overloading process we can provide more than

one form by changing para_list or para_type at compilation stage,
because of this reason Method Overloading process comes under
Static PolyMorphism or Compiletime PolyMorphims

Ex:
add(int,int)
add(int,int,int)

thi
i

add(int,float)

public class Addition
{

ipa

public void add(int x,int y) {}

public void add(int x,float y) {}

Ve
nk
ate
sh

}

Ma

public void add(int x,int y,int z) {}

=========================================================

*imp

=>Compiler at compilation stage will understand the behaviour of

the following keywords:
1.static

2.private
3.final

1.static:
=>The following are the static programming components:

(a)static variables
(b)static methods
(c)static blocks
(d)static classes

(f)static AbstractClasses

-----------------------------------------------------------

2.private:

Ma

*imp

ipa

=>There is no concept of static Constructors in Java.

thi
i

(e)static Interfaces

=>The following are the private programming components:

Ve
nk
ate
sh

(a)private variables
(b)private methods

(c)private Constructors
(d)private Classes

=>There is no concept of private blocks,private Interfaces and

private abstractclasses.

Dt : 3/6/2023
(a)private variables:
=>The variables which are declared with "private" keyword are
known as private variables

thi
i

Coding Rule:
=>Private variables are accessed by the methods of same class.

ipa

(b)private methods:

known as private methods.
Coding Rule:

Ma

=>The methods which are declared with private keyword are

Ve
nk
ate
sh

=>private methods are accessed by the NonPrivate methods of

Same class.

Note:

=>In realtime private variables are used in Bean classes of Servlet
programming.

=>In realtime private methods are less used.

*imp
(c)private Constructors:
=>The Constructors which are declared with private keyword are

known as private Constructors.
Coding Rule:
=>Private Constructor is executed when the object is created

thi
i

inside the same class where private Constructor is declared.

Note:

(d)private Classes:

Ma

creations from externally(outside the class).

ipa

=>In realtime private constructors are used to restrict object

=>The classes which are declared with private keyword are known

Ve
nk
ate
sh

as private classes.

=>These private classes can be declared only as InnerClass,which

means we cannot declare OuterClasses as private.
Coding Rule:

=>Private Classes objects are created inside the same class

where they are declared.
Note:

=>In realtime private classes are used part of Security.

Ex-program:
Display.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package maccess;
public class Display {
private int a=10;
private static int b=20;
private Display() {}
public static Display d = new Display();//Con_call
private void dis1() {
System.out.println("***Instance private
dis1()****");
System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
}
private static void dis2() {
System.out.println("***Static private
dis2()****");
//System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
}
private class SubClass1{
public void m1() {
System.out.println("---InnerClass m1()---");
System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
}
}//private Instance member InnerClass
private SubClass1 ob1 = new SubClass1();
private static class SubClass2{
public void m2() {
System.out.println("---InnerClass m2()---");
//System.out.println("The value a:"+a);
System.out.println("The value b:"+b);
}
}//private Static member InnerClass
private SubClass2 ob2 = new SubClass2();
public void access() {
this.dis1();
Display.dis2();
ob1.m1();
ob2.m2();
}

}
DemoPoly1.java(MainClass)

thi
i

package maccess;
public class DemoPoly1 {
public static void main(String[] args) {
Display.d.access();
}
}

ipa

o/p:

The value a:10
The value b:20

Ve
nk
ate
sh

***Static private dis2()****

Ma

***Instance private dis1()****

The value b:20

---InnerClass m1()--The value a:10
The value b:20

---InnerClass m2()--The value b:20

----------------------------------------------------------

Note:
=>Private method Overriding process is not available,but we can
perform Private method Overloading process.

Ex-program:
PClass.java

ipa

thi
i

package maccess;
public class PClass {
private void m1(int x) {
System.out.println("===PClass m1(x)===");
System.out.println("The value x:"+x);
}
}
CClass.java

Ve
nk
ate
sh

Ma

package maccess;
public class CClass extends PClass{
private void m1(int x) {
System.out.println("===CClass m1(x)===");
System.out.println("The value x:"+x);
}
private void m1(int x,int y) {
System.out.println("===CClass m1(x,y)===");
System.out.println("The value x:"+x);
System.out.println("The value y:"+y);

}

}
public void access() {
this.m1(11);
this.m1(12, 13);
}

DemoPoly2.java(MainClass)
package maccess;
public class DemoPoly2 {
public static void main(String[] args) {

}

}

CClass ob = new CClass();
ob.access();

o/p:

thi
i

===CClass m1(x)===
The value x:11

ipa

===CClass m1(x,y)===
The value x:12

Ma

The value y:13

=============================================================
*imp

Ve
nk
ate
sh

3.final:

=>The following are the final programming components:
(a)final variables
(b)final methods
(d)final classes

=>There is no concept of final blocks,final constructors,final

Interfaces and final AbstractClasses.

(a)final variables:
=>The variables which are declared with "final" keyword in
classes are known as final variables.

Coding Rule:
=>final variables must be initialized with values and once
initialized cannot be modified.
(final variables are also known as constant variables or Secured

thi
i

variables)
Note:

ipa

=>final varibles in classes can be intialized using Constructor.

Ma

(b)final methods:

=>The methods which are declared with final keyword are known as
final methods.

Ve
nk
ate
sh

Coding Rule:

=>final methods cannot be overrided.

(d)final classes:

=>The classes which are declared with final keyword are known

as final classes.
Coding Rule:

=>final classes cannot be extended,which there is no inheritance

process for final classes.
------------------------------------------------------Note:

=>In realtime using final programming components we can construct
"Immutable Classes".
-------------------------------------------------------*imp

thi
i

define Immutable Classes?
=>The classes which are declared with the following rules are

Rule-1 : The classes must be final classes

ipa

known as Immutable Classes.

Ma

Rule-2 : The variables in classes must be "private and final"
(These variables are initialized with constructor)

Rule-3 : The classes must be declared only with "Getter methods"

Ve
nk
ate
sh

Rule-4 : These "Getter methods" must be final methods

Note:

=>These Immutable Classes will generate "Immutable Objects",which

means the Objects once created cannot be modified.
(Immutable Objects are also known as Constant Objects or Secured
Objects)

---------------------------------------------------------------

Immutable objects provide numerous advantages in programming:
1.Thread Safety: Immutable objects are inherently thread-safe, as their state cannot be modified once created. This eliminates the need for locks or synchronization mechanisms when working with
multiple threads, simplifying concurrent programming and reducing the risk of data inconsistency or race conditions.
2.Simplified and Predictable Behavior: Immutable objects have a fixed state that cannot be changed. This makes their behavior predictable, as you can rely on their state remaining constant
throughout the program. This simplifies debugging and reasoning about code, leading to fewer bugs and easier maintenance.
3.Caching and Reusability: Immutable objects can be safely cached and shared among different parts of the program. Since their state remains constant, they can be reused without concern for side
effects or unexpected changes. This improves performance by reducing the need for object creation and garbage collection.
4.Security and Integrity: Immutable objects are resistant to unauthorized modifications, making them useful in security-critical scenarios. They ensure the integrity of data, as the object's state
cannot be tampered with once created. Immutable objects can be safely passed between components without fear of their values being compromised.
5.Hashability: Immutable objects can be easily used as keys in hash-based data structures, such as HashMaps or HashSets. Since the object's state is constant, its hash code remains the same,
ensuring consistent behavior when used in collections.
Overall, the use of immutable objects promotes safer, more efficient, and more maintainable code. By preventing changes to the object's state, you can avoid synchronization issues, simplify code
logic, improve performance, and ensure data integrity.

Dt : 5/6/2023
Ex-program : (Demonstrating Immutable Classes)
TransLog.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package test;
import java.util.Date;
public final class TransLog {
private final long hAccNo,bAccNo;
private final float amt;
private final Date dTime;
public TransLog(long hAccNo,long bAccNo,float amt,
Date dTime) {
this.hAccNo=hAccNo;
this.bAccNo=bAccNo;
this.amt=amt;
this.dTime=dTime;
}
public final long gethAccNo() {
return hAccNo;
}
public final long getbAccNo() {
return bAccNo;
}
public final float getAmt() {
return amt;
}
public final Date getdTime() {
return dTime;
}
}

DemoPoly3.java(MainClass)
package maccess;
import java.util.*;

import test.TransLog;
public class DemoPoly3 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);

try {

long hAccNo = s.nextLong();

ipa

System.out.println("Enter Home AccNo:");

thi
i

try(s;){

Ma

System.out.println("Enter beneficiery AccNo:");
long bAccNo = s.nextLong();

System.out.println("Enter the amt to be transferred:");

Ve
nk
ate
sh

float amt = s.nextFloat();

Date dTime = new Date();

TransLog ob = new TransLog(hAccNo,bAccNo,amt,dTime);
System.out.println("====Display Trans-Details====");
System.out.println("HAccNo:"+ob.gethAccNo());
System.out.println("BAccNo:"+ob.getbAccNo());
System.out.println("Amount:"+ob.getAmt());
System.out.println("DateTime:"+ob.getdTime());

}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}

}
o/p:
Enter Home AccNo:
6123456

thi
i

Enter beneficiery AccNo:
313131
Enter the amt to be transferred:

ipa

5000

HAccNo:6123456
BAccNo:313131

Ve
nk
ate
sh

Amount:5000.0

Ma

====Display Trans-Details====

DateTime:Mon Jun 05 18:36:42 IST 2023

==============================================================

Note:

=>In realtime Immutable Objects are used to hold transaction

details in Banking Domain applications and these Immutable Objects
are stored in Database.

=============================================================

*imp
"Record" in Java:(Java17 - new feature)
=>"Record" is an abstract class from java.lang package and which

is used to generate record-objects and which are Immutable Objects.
=>The following is the structure of "Record" and which is
introduced by Java17 version:

{
protected java.lang.Record();

ipa

public abstract boolean equals(java.lang.Object);

thi
i

public abstract class java.lang.Record

Ma

public abstract int hashCode();
public abstract java.lang.String toString();

Ve
nk
ate
sh

}

=>we use the following pre-defined standard syntax to create

record-objects:

record Record_name(para_list)
{

//record_body

}

Ex-Program:
TransLog.java

DemoRecord.java(MainClass)
package maccess;

Ve
nk
ate
sh

import java.util.*;

Ma

ipa

thi
i

package test;
import java.util.*;
public record TransLog(long hAccNo,long bAccNo,float
amt,
Date dTime)
{
public TransLog
{
if(amt<=0)
{
throw new IllegalArgumentException("Invalid
amt");
}
}
}

import test.TransLog;

public class DemoRecord {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
try(s;){
try {

System.out.println("Enter the hAccNo:");
long hAccNo = s.nextLong();
System.out.println("Enter the bAccNo:");
long bAccNo = s.nextLong();

System.out.println("Enter the amt to be transferred:");
float amt = s.nextFloat();
Date dTime = new Date();
TransLog ob = new TransLog(hAccNo,bAccNo,amt,dTime);

thi
i

//Con_Call
System.out.println("===Display Trans-details===");
System.out.println("HAccNo:"+ob.hAccNo());

ipa

System.out.println("BAccNo:"+ob.bAccNo());

Ma

System.out.println("Amt:"+ob.amt());

System.out.println("HAccNo:"+ob.dTime());

Ve
nk
ate
sh

}catch(Exception e) {

System.out.println(e.getMessage());
}

}//end of try
}

}

o/p:

Enter the hAccNo:
4545123
Enter the bAccNo:

232323
Enter the amt to be transferred:
7000
===Display Trans-details===

thi
i

HAccNo:4545123
BAccNo:232323

HAccNo:Mon Jun 05 19:05:01 IST 2023

Advantages of Record:

Ma

------------------------------------------------------

ipa

Amt:7000.0

(i)Auto generated Parameterized contructor to initialize instance

Ve
nk
ate
sh

Variables and the Constructor is known as "Canonical
Constructor"

(ii)Auto generated "Getter methods" to display the data from the
Objects.

(iii)Record is used to replace Immutable Classes part of
application development.

------------------------------------------------------

Note:

=>we use "Compact Constructor" in records to validate parameters
=================================================================
*imp

Sealed classes in Java:(Java17 - new feature)
=>The classes which are declared with "sealed" keyword are known
as "sealed classes" and these sealed classes will specify the

syntax:
sealed class Class_name permits Class1,Class2,...

}

No, you cannot directly create an object of a sealed class in Java. Sealed classes are designed
to have a limited set of subclasses that are explicitly defined within the sealed class
declaration. They provide control over the inheritance hierarchy by restricting the subclasses
to a specific set.

Ma

//body

ipa

can i create object for sealed class?

{

thi
i

permission for extention using "permits" keyword

Sealed classes are typically used when you want to define a closed set of subclasses that can
extend the sealed class. To create an instance of a sealed class, you need to create an object
of one of its subclasses.

Ve
nk
ate
sh

Coding Rules:

(i)sealed classes must specify the permissions.
(ii)The classes which are extended from sealed classes must be

final classes or non-sealed classes or another sealed class

Ex:

A.java

package test;
public sealed class A permits B,C,D
{
public void mA()
{
System.out.println("***mA()****");
}

}
B.java

ipa

thi
i

package test;
public final class B extends A
{
public void mB()
{
System.out.println("***mB()***");
}
}
C.java

Ve
nk
ate
sh

Ma

package test;
public non-sealed class C extends A
{
public void mC()
{
System.out.println("***mC()***");
}
}
D.java

package test;

public sealed class D extends A permits E
{
public void mD()
{
System.out.println("***mD()****");
}
}
E.java

thi
i

package test;
public final class E extends D
{
public void mE()
{
System.out.println("***mE()***");
}
}
DemoSealed.java(MainClass)

Ve
nk
ate
sh

Ma

ipa

package maccess;
import test.*;
public class DemoSealed {
public static void main(String[] args) {
System.out.println("-----Class-B----");
B ob1 = new B();
ob1.mA();
ob1.mB();
System.out.println("-----Class-C----");
C ob2 = new C();
ob2.mA();
ob2.mC();
System.out.println("-----Class-E----");
E ob3 = new E();
ob3.mA();
ob3.mD();
ob3.mE();
}
}
o/p:

-----Class-B---***mA()****
***mB()***

-----Class-C---***mA()****
***mC()***
-----Class-E----

thi
i

***mA()****
***mD()****

ipa

***mE()***

Ve
nk
ate
sh

Ma

Diagram:

===================================================
Benefits of sealed classes:

1.Enhanced encapsulation and abstraction: Sealed classes define a closed set of subclasses that are tightly related, improving
encapsulation and abstraction in your code.
2.Improved maintainability: By restricting the set of subclasses, sealed classes help maintain a stable and predictable inheritance
hierarchy, reducing the chances of unintended or incompatible subclass extensions.
3.Support for pattern matching: Sealed classes work in conjunction with pattern matching, enabling exhaustive checking at compiletime and enhancing type-based conditional logic.
4.Foundation for future language features: Sealed classes provide a foundation for potential future language features and
enhancements that rely on a well-defined and controlled class hierarchy.
Overall, sealed classes in Java offer a way to define closed hierarchies, promoting code maintainability, encapsulation, and abstraction.
They provide better control over inheritance and enable the adoption of future language features

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 6/6/2023
Selead Interfaces in Java:
=>The interfaces which are declared with "selead" keyword are
known as sealed-interfaces.

thi
i

=>selead interfaces must specify the permissions for
implementation classes.

=>The implementation classes can be final classes or non-sealed

sealed interface Interface_name

Ve
nk
ate
sh

{

Ma

structure of sealed interfaces:

ipa

classes or sealed classes.

//body

}

Ex-Program:
ITest.java

package test;
public sealed interface ITest permits IClass{
public abstract void m1(int x);
public default void m2(int y) {
System.out.println("****default m2(y)****");
System.out.println("The value y:"+y);
}
}

IClass.java

thi
i

package test;
public non-sealed class IClass implements ITest{
public void m1(int x) {
System.out.println("****m1(x)****");
System.out.println("The value x:"+x);
}
}

ipa

DemoSealed2.java(MainClass)

Ve
nk
ate
sh

Ma

package maccess;
import test.*;
public class DemoSealed2 {
public static void main(String[] args) {
IClass ob = new IClass();
ob.m1(11);
ob.m2(12);
}
}
o/p:

****m1(x)****
The value x:11

****default m2(y)****
The value y:12

============================================================
*imp

=>Based on Security the objects in java are categorized into two
types:
(i)Mutable Objects

thi
i

(ii)Immutable Objects

(i)Mutable Objects:

=>The Objects once created can be modified are known as Mutable

Ma

(ii)Immutable Objects:

ipa

Objects.

=>The Objects once created cannot be modified are known as

Ve
nk
ate
sh

Immutable Objects.

=>These Immutable Objects are also known as Constant Objects or

Secured Objects.

==========================================================

*imp

Strings in Java:

=>The sequenced collection of characters which are represented in

double quotes is known as string.
Ex:
"hyd","nit",...

=>Characters in string are organized based on index values.

=>Strings in java are not Arrays.
=>The following are pre-defined classes from java.lang package
to create string-objects:
1.String class

thi
i

2.StringBuffer class
3.StringBuilder class

ipa

1.String class:

Ma

=>The objects which are generated from "java.lang.String" class
are automatically Immutable objects.

=>16 Constructors by Java8 version and 15 Constructors from

Ve
nk
ate
sh

Java17 version.

=>we use the following syntaxes to create "String-class" objects:
syntax-1 : Using "String literal process"
String s1 = "nit";

syntax-2 : Using "new" operator process
String s2 = new String("hyd");

Diagrams:

thi
i
ipa
Ma
Ve
nk
ate
sh
Hierarchy of "String":

thi
i
ipa
Ma

-----------------------------------------------------Ex-program-1 : DemoString1.java

Ve
nk
ate
sh

package maccess;
public class DemoString1 {
public static void main(String[] args) {
System.out.println("****String Literal
Process***");
String s1 = "nit";
int len1 = s1.length();
char ch1 = s1.charAt(1);
System.out.println("s1 : "+s1.toString());
System.out.println("length of s1 : "+len1);
System.out.println("char at index 1 : "+ch1);
System.out.println("****new operator
process****");
String s2 = new String("Hyd");
int len2 = s2.length();
char ch2 = s1.charAt(0);
System.out.println("s2 : "+s2.toString());
System.out.println("length of s2 : "+len2);
System.out.println("char at index 0 : "+ch2);

}

}

o/p:
****String Literal Process***

thi
i

s1 : nit
length of s1 : 3

ipa

char at index 1 : i

s2 : Hyd
length of s2 : 3

Ve
nk
ate
sh

char at index 0 : n

Ma

****new operator process****

===============================================
faq:

define length() method?

=>length() method is used to find the length of Strings.

syntax:

int len = s1.length();

faq:
define chatAt() method?
=>charAt() method is used to retrieve char from the string based

on index value.
syntax:
char ch = s1.charAt(index);

thi
i

faq:
define toString() method?

=>toString() method is used to display the content from the Object

ipa

syntax:

Note:

Ma

String data = s1.toString();

Ve
nk
ate
sh

=>toString() method is auto executable method and which is

executed automatically when we display object reference variable.
==============================================================

Assignment:

wap to display the String in reverse?

==============================================================

Dt : 7/6/2023
Assignment:
wap to display the String in reverse?
program : DemoString2.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package maccess;
import java.util.*;
public class DemoString2 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the String:");
String str = s.nextLine();
System.out.println("====Normal
String===");
System.out.println("Str :
"+str.toString());
int len = str.length();
System.out.println("length of str :"+len);
System.out.println("****Stringreverse****");
for(int i=len-1;i>=0;i--)
{
char ch = str.charAt(i);
System.out.print(ch);
}//end of loop
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}
}
o/p:
Enter the String:
java program

====Normal String===
Str : java program
length of str :12
****String-reverse****

thi
i

margorp avaj
=======================================================
faq:

ipa

define ASCII code?

Ma

=>ASCII stands for "American Standard Code for Information

Interchange" and which is a numeric value generated for each

Ve
nk
ate
sh

character entered from the keyboard.

UpperCase Letters(A to Z) : 65 to 90

LowerCase Letters(a to z) : 97 to 122
Numeric Numbers(0 to 9) : 48 to 57

Program : DemoString3.java

package maccess;
public class DemoString3 {
public static void main(String[] args) {
System.out.println("****UpperCase
Letters****");
for(int i=65;i<=90;i++)
{
char ch = (char)i;//Convert ASCII to char
System.out.print(ch+" ");

o/p:

Ma

ipa

thi
i

}//end of loop
System.out.println("\n****LowerCase
Letters****");
for(int i=97;i<=122;i++)
{
char ch = (char)i;//Convert ASCII to char
System.out.print(ch+" ");
}//end of loop
System.out.println("\n****Numeric
Numbers****");
for(int i=48;i<=57;i++)
{
char ch = (char)i;
System.out.print(ch+" ");
}//end of loop
}
}

Ve
nk
ate
sh

****UpperCase Letters****

ABCDEFGHIJKLMNOPQRSTUVWXYZ
****LowerCase Letters****

abcdefghijklmnopqrstuvwxyz
****Numeric Numbers****
0123456789

=======================================================

Ex-program:

wap to read a String and display the Consonents and count of
Consonents?

Program : DemoString4.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package maccess;
import java.util.*;
public class DemoString4 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the String:");
String str = s.nextLine();
int len = str.length();
int count=0;
System.out.print("Consonents : ");
for(int i=0;i<=len-1;i++)
{
char ch = str.charAt(i);
int k = (int)ch;//char to ASCII code
if((k>=65 && k<=90) || (k>=97 &&
k<=122))
{
switch(ch)
{
case 'a':
case 'A':
break;
case 'e':
case 'E':
break;
case 'i':
case 'I':
break;
case 'o':
case 'O':
break;
case 'u':
case 'U':
break;
default:
System.out.print(ch+" ");

count++;
}//end of switch

thi
i

}
}//end of loop
System.out.println("\nCount of
Consonents:"+count);
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}
}

ipa

o/p:
Enter the String:

Consonents : J v s L T S p r d c t b y
Count of Consonents:13

Ma

Java17 is LTS product by 2021

Ve
nk
ate
sh

==============================================

Assignment:

wap to read a String and display the following:
Count of Vowels

:

Count of Consonents :
Count of Numbers :
Sum of Numbers
Count of others

i/P:

:

:

Java17 is LTS product by 2021

O/p:

:5

thi
i

Count of Vowels

Count of Consonents : 13
Count of Numbers : 6

ipa

Count of others

: 13
:5

Ma

Sum of Numbers

==============================================================
faq:

Ve
nk
ate
sh

define String Concatenation process?

=>The process of combining multiple Strings into a single String

is known as String Concatenation process.

=>We use the following to perform Concatenation process in Java:
(i)Using "+" symbol

(ii)Using "concat()" method

Program : DemoString5.java

package maccess;
public class DemoString5 {
public static void main(String[] args) {
String s1 = "Java";
String s2 = "Language";

thi
i

}

}

String s3 = "Programming";
String s4 = s1+" "+s2+" "+s3;
System.out.println("s4 : "+s4.toString());
String s5 = s1.concat(" "+s3);
System.out.println("s5 : "+s5.toString());
String s6 = s1.concat(" "+s2).concat(" "+s3);
System.out.println("s6 : "+s6.toString());

o/p:

ipa

s4 : Java Language Programming

s6 : Java Language Programming

Ma

s5 : Java Programming

---------------------------------------------------

Ve
nk
ate
sh

Note:

=>In String-Concatenation process separate String is created to

hold concatenated Strings,because the existing string-objects are
Immutable objects.

========================================================

faq:

define substring() method?

=>substring() method is used to display sub-string based on index

values
Method Signature:
public java.lang.String substring(int);

public java.lang.String substring(int,int);

Ex-program:

thi
i

Wap to read Stu rollNo and display the details?

Program : DemoString6.java

Ve
nk
ate
sh

Ma

ipa

package maccess;
import java.util.*;
public class DemoString6 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the
StuRollNo:");
String rNo = s.nextLine();
int len = rNo.length();
if(len==10) {
String yoj = rNo.substring(0, 2);
String cc = rNo.substring(2, 6);
String bc = rNo.substring(6, 8);
String no = rNo.substring(8);
System.out.println("===Details===");
System.out.println("Year of
Joining:20"+yoj);
System.out.println("College
Code:"+cc);
System.out.println("Branch Code:"+bc);
System.out.println("Number in
batch:"+no);
}else {
System.out.println("Invalid RollNo");
}
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

}

}

o/p:
Enter the StuRollNo:

thi
i

19E11A05G1
===Details===

ipa

Year of Joining:2019
College Code:E11A

Number in batch:G1

Ma

Branch Code:05

Ve
nk
ate
sh

===========================================================

Dt : 8/6/2023
*imp
define String Comparision?
=>The process of comparing two strings is known as String

thi
i

Comparision process.
=>String Comparision process can be done in two ways:
(a)using equals() method

Ma

(a)using equals() method:

ipa

(b)using compareTo() method

=>equals() method is used to compare two strings and generate

Ve
nk
ate
sh

boolean result.

Method Signatures:

public boolean equals(java.lang.Object);

public boolean equalsIgnoreCase(java.lang.String);

Ex-program : DemoString7.java

package maccess;
import java.util.*;
public class DemoString7 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s){
System.out.println("Enter the String-1:");
String str1 = s.nextLine().trim();
System.out.println("Enter the String-2:");

String str2 = s.nextLine().trim();
System.out.println("*****equals()*****");
boolean k = str1.equals(str2);
if(k) {
System.out.println("Strings are equal...");
}else {
System.out.println("String are NotEqual..");
}

Ma

ipa

thi
i

System.out.println("****equalsIgnoreCase()****");
boolean z = str1.equalsIgnoreCase(str2);
if(z) {
System.out.println("Strings are equal...");
}else {
System.out.println("String are NotEqual..");
}
}//end of try with resource
}
}

Ve
nk
ate
sh

o/p:

Enter the String-1:
nit

Enter the String-2:
nit

*****equals()*****
Strings are equal...

****equalsIgnoreCase()****
Strings are equal...

----------------------------------------------------------Note:

=>In realtime equals() method is used for user authentication
process.
=========================================================
Assignment:

(i)The rollNo must be 10 digits,else Invalid rollNo
(Msg through catch-block)

thi
i

wap to read stuRollNo and display the rollNo branch?

ipa

(ii)If the rollNo is validated then display branch based on

Ex-branch-codes:
01 - CIVIL

Ve
nk
ate
sh

02 - EEE

Ma

branch code.

03 - MECH
04 - ECE
05 - CSE
12 - IT

=>In brCode not not matched with any available codes,then
display the msg as "RollNo holding invalid brCode"
(Msg through catch-block)

==========================================================
(b)using compareTo() method:

=>compareTo() method also used to compare two strings and
generate int-result.
Method Signatures:
public int compareTo(java.lang.String);

thi
i

public int compareToIgnoreCase(java.lang.String);

Ex:

if p>0 , then str1>str2

Ve
nk
ate
sh

if p<0 , then str1<str2

Ma

if p==0 , then Strings are equal

ipa

int p = str1.compareTo(str2);

Note:

=>In realtime compareTo() method is used for sorting process

Ex-program : DemoString8.java

package maccess;
import java.util.*;
public class DemoString8 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s){
System.out.println("Enter the String-1:");
String str1 = s.nextLine().trim();
System.out.println("Enter the String-2:");

str2");

}else {
System.out.println("str1 is less than

thi
i

str2");

String str2 = s.nextLine().trim();
System.out.println("*****compareTo()*****");
int k = str1.compareTo(str2);
if(k==0) {
System.out.println("Strings are equal...");
}else if(k>0){
System.out.println("str1 is greater than

}

Ve
nk
ate
sh

Ma

ipa

System.out.println("****compareToIgnoreCase()****");
int z = str1.compareToIgnoreCase(str2);
if(z==0) {
System.out.println("Strings are equal...");
}else if(z>0){
System.out.println("str1 is greater than
str2");
}else {
System.out.println("str1 is less than
str2");
}
}//end of try with resource
}
}
o/p:

Enter the String-1:
java

Enter the String-2:
nit
*****compareTo()*****

str1 is less than str2
****compareToIgnoreCase()****
str1 is less than str2
=========================================================

thi
i

faq:
wt is the diff b/w "String literal process" and "new Operator
process" in Object creation?

ipa

=>In String literal process,the execution-control will check the

Ma

"String Constant pool" is any object having same data,
=>If object not available then new Object is created

=>If Object is available then reference of existing object

Ve
nk
ate
sh

is used without creating new object.

=>In new Operator process,one object is created directly in
HeapArea and the object will hold the reference of object
created in "String Constant Pool".

Diagram:

thi
i
ipa
Ma

Note:

Ve
nk
ate
sh

=>"is equal to"(==) operator will compare object references,
because of this reason "is equal to"(==) operator is not preferable
to use on NonPrimitive datatypes.

Program : DemoString9.java

package maccess;
public class DemoString9 {
public static void main(String[] args) {
//String Literal
String s1 = "nit";
String s2 = "nit";
//new operator process
String s3 = new String("hyd");
String s4 = new String("hyd");
System.out.println("====String Literal
process===");

o/p:

Ve
nk
ate
sh

====String Literal process===

Ma

ipa

thi
i

if(s1==s2) {
System.out.println("Strings are equal..");
}else {
System.out.println("String are Notequal..");
}
System.out.println("====new Operator
process====");
if(s3==s4) {
System.out.println("Strings are equal..");
}else {
System.out.println("Strings are Notequal...");
}
}
}

Strings are equal..

====new Operator process====
Strings are Not-equal...

====================================================

faq:

define String Constant pool?

=>The separate partition of HeapArea where String-objects are

created is known as String Constant pool.
=>String Constant pool will restrict duplicate Object creations
and saves the execution time and high performance of an application.

faq:
why String-objects are immutable?
=>The object references of String Constant pool are available

thi
i

to more than one reference variables and we must retrict
modifications,because of this reason String-objects are immutable

ipa

objects.

define String pooling?

Ma

faq:

=>The process of organizing multiple String-objects in a separate

Ve
nk
ate
sh

location of HeapArea is known as "String Pooling"

===========================================================

Dt : 9/6/2023
2.StringBuffer class:
=>The objects which are created from "StringBuffer" are
Mutable Objects.

thi
i

=>The following are some important constructors from
StringBuffer class:

public java.lang.StringBuffer(int);

ipa

public java.lang.StringBuffer();

Ma

public java.lang.StringBuffer(java.lang.String);

public java.lang.StringBuffer(java.lang.CharSequence);

Ve
nk
ate
sh

Case-1 : Creating object using "StringBuffer()" constructor
syntax:

StringBuffer sb = new StringBuffer();

=>In this syntax StringBuffer object is created with the
default capacity 16.

=>we use append() method to add the data to StringBuffer
Object.

=>when length crosses the capacity then the capacity

increases automatically by doubling the capacity and adding 2.
16->(16+16+2)->34--->

Ex-program : DemoString10.java

Ve
nk
ate
sh

}

Ma

ipa

thi
i

package maccess;
public class DemoString10 {
public static void main(String[] args) {
StringBuffer sb = new StringBuffer();
System.out.println("default
capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("java language");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append(" programming");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
}

o/p:

default capacity:16
length of sb:0

sb:java language
capacity:16

length of sb:13
sb:java language programming
capacity:34
length of sb:25

-------------------------------------------------Case-2:Creating object using "StringBuffer(int)" constructor
syntax:
StringBuffer sb = new StringBuffer(5);

thi
i

=>In this syntax StringBuffer object is created with the
capacity equal to the value passed as parameter while object

ipa

creation.

Ex-program : DemoString11.java

Ve
nk
ate
sh

Ma

package maccess;
public class DemoString11 {
public static void main(String[] args) {
StringBuffer sb = new StringBuffer(5);
System.out.println("default
capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("java");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("AB");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());

}

}

o/p:
default capacity:5
length of sb:0
sb:java

thi
i

capacity:5
length of sb:4
sb:javaAB

ipa

capacity:12

Ma

length of sb:6
------------------------------------------------

Case-3:Creating object using "StringBuffer(String)"

Ve
nk
ate
sh

constructor

syntax:

StringBuffer sb = new StringBuffer("NIT");

=>In this syntax the StringBuffer object is created with

default capacity equal to the sum of "16 + length of String
passed as parameter".

Ex-program : DemoString12.java

package maccess;
public class DemoString12 {
public static void main(String[] args) {
StringBuffer sb = new StringBuffer("NIT");

Ve
nk
ate
sh

o/p:

Ma

}

}

ipa

thi
i

System.out.println("default
capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("java language Program");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());
sb.append("AB");
System.out.println("sb:"+sb.toString());
System.out.println("capacity:"+sb.capacity());
System.out.println("length of
sb:"+sb.length());

default capacity:19
length of sb:3

sb:NITjava language Program
capacity:40

length of sb:24

sb:NITjava language ProgramAB
capacity:40

length of sb:26
----------------------------------------------------Case-4:Creating object using "StringBuffer(CharSequence)"

constructor
syntax:
StringBuffer sb1 = new StringBuffer("NIT");

thi
i

StringBuffer sb2 = new StringBuffer(sb1);

=>This syntax is used to interlink two StringBuffer Objects,

ipa

which means sb2-object is holding the reference of sb1-object

Ex-program : DemoString13.java

Ve
nk
ate
sh

Ma

package maccess;
public class DemoString13 {
public static void main(String[] args) {
StringBuffer sb1 = new StringBuffer("NIT");
StringBuffer sb2 = new StringBuffer(sb1);
System.out.println("sb2:"+sb2.toString());
System.out.println("default
capacity:"+sb2.capacity());
System.out.println("length of
sb:"+sb2.length());

}

}

o/p:

sb2:NIT
default capacity:19
length of sb:3

======================================================
Note:
=>StringBuffer will support some important methods:
(i)insert()

thi
i

(ii)delete()
(iii)reverse()

ipa

Ex-program : DemoString14.java

Ve
nk
ate
sh

Ma

package maccess;
public class DemoString14 {
public static void main(String[] args) {
StringBuffer sb = new StringBuffer();
sb.append("JavaLanguageProgram");
System.out.println("sb:"+sb.toString());
sb.insert(4, " NIT-HYD ");
System.out.println("sb:"+sb.toString());
sb.delete(4, 8);
System.out.println("sb:"+sb.toString());
sb.reverse();
System.out.println("sb:"+sb.toString());
}

}

o/p:

sb:JavaLanguageProgram

sb:Java NIT-HYD LanguageProgram
sb:Java-HYD LanguageProgram
sb:margorPegaugnaL DYH-avaJ

=================================================
Assignment:
wap to read a String and check the String is palindrome
String or not?

Note:
=>StringBuffer class is synchronized class.

thi
i

==================================================

ipa

================================================

define synchronized class?

Ma

faq:

=>The class which is declared with synchronized methods is

Ve
nk
ate
sh

known as synchronized class

faq:

define synchronized methods?

=>The methods which are declared with synchronized keyword

are known as synchronized methods.

Note:

=>These synchronized methods will be under the lock and the
methods are available to one user at-a-time.
--------------------------------------------------

3.StringBuilder class:
=>StringBuilder also generate mutable objects,but it is
NonSynchronized class.
=>The following are some important constructors from

public java.lang.StringBuilder();
public java.lang.StringBuilder(int);

ipa

public java.lang.StringBuilder(java.lang.String);

thi
i

StringBuilder:

Ma

public java.lang.StringBuilder(java.lang.CharSequence);
=>StringBuilder internally having same behaviour like
StringBuffer.

Ve
nk
ate
sh

=====================================================

summary:

String - Immutable objects

- Holding protected data
- ThreadSafe class

StringBuffer - Mutable Objects
- Synchronized Class
- ThreadSafe class

- Used in Multi-user Applications
(Server Applications)

StringBuilder - Mutable Objects
- NonSynchronized Class

- Used in Single User Applications
(NonServer Applications)

thi
i

- NonThreadSafe class

Ve
nk
ate
sh

Ma

ipa

========================================================

Dt : 10/6/2023
Assignment:(Solution)
wap to read a String and display the following:
Count of Vowels

:

thi
i

Count of Consonents :
Count of Numbers :
Sum of Numbers

Program : DemoString15.java

ipa

:

Ma

Count of others

:

Ve
nk
ate
sh

package maccess;
import java.util.*;
public class DemoString15 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the String:");
String str = s.nextLine();
int len = str.length();
int ac=0,vc=0,nc=0,sum=0;
for(int i=0;i<=len-1;i++)
{
char ch = str.charAt(i);
int k = (int)ch;//Char to ASCII
if((k>=65 && k<=90) || (k>=97 &&
k<=122))
{
switch(ch)
{
case 'a':
case 'A':

Ve
nk
ate
sh

Ma

ipa

thi
i

case 'e':
case 'E':
case 'i':
case 'I':
case 'o':
case 'O':
case 'u':
case 'U':vc++;
break;
}//end of switch
ac++;
}//end of if
if(k>=48 && k<=57)
{
nc++;
String sr =
String.valueOf(ch);//Char to String
int v = Integer.parseInt(sr);
//String to number
sum=sum+v;
}//end of if
}//end of loop
System.out.println("Count of
alphabets:"+ac);
System.out.println("Count of Vowels:"+vc);
System.out.println("Count of
Consonents:"+(ac-vc));
System.out.println("Count of
Numbers:"+nc);
System.out.println("Sum of Numbers:"+sum);
System.out.println("Count of
Others:"+(len-(ac+nc)));

}

}

}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

o/p:
Enter the String:
Java17 is LTS product by 2021
Count of alphabets:18

thi
i

Count of Vowels:5
Count of Consonents:13
Count of Numbers:6

ipa

Sum of Numbers:13

Ma

Count of Others:5

==============================================================

Ve
nk
ate
sh

Assignment:(Solution)

wap to read stuRollNo and display the rollNo branch?
(i)The rollNo must be 10 digits,else Invalid rollNo
(Msg through catch-block)

(ii)If the rollNo is validated then display branch based on
branch code.

Ex-branch-codes:
01 - CIVIL
02 - EEE
03 - MECH
04 - ECE

05 - CSE
12 - IT

=>In brCode not not matched with any available codes,then

thi
i

display the msg as "RollNo holding invalid brCode"
(Msg through catch-block)

ipa

Program :
GenerateBranch.java

Ve
nk
ate
sh

Ma

package test;
public class GenerateBranch
{
public String generate(String brCode)
{
return switch(brCode)
{
case "01":yield "CIVIL";
case "02":yield "EEE";
case "03":yield "MECH";
case "04":yield "ECE";
case "05":yield "CSE";
default : yield null;
};
}
}
DemoString16.java
package maccess;
import java.util.*;

import test.GenerateBranch;
@SuppressWarnings("serial")
public class DemoString16 extends Exception
{

thi
i

public DemoString16(String msg)
{

}

Ma

public static void main(String[] args)

ipa

super(msg);

{

Scanner s = new Scanner(System.in);

Ve
nk
ate
sh

try(s)
{

try
{

System.out.println("Enter the stuRollNo:");
String rollNo = s.nextLine();

if(rollNo.length()!=10)//Exception-condition
{

throw new DemoString16("Invalid rollNo..");
}
String brCode = rollNo.substring(6,8);

GenerateBranch gb = new GenerateBranch();
String br = gb.generate(brCode);
if(br==null)//Exception-Condition
{

("RollNo holding Invalid brCode...");
}

thi
i

throw new DemoString16

ipa

System.out.println("RollNo belongs to "+br);

catch(DemoString16 ob)
{

Ma

}//end of try

Ve
nk
ate
sh

System.out.println(ob.getMessage());

}

}//end of try with resource
}

}

o/p:

Enter the stuRollNo:
1234560590

RollNo belongs to CSE
==========================================================

define Utility Classes?
=>The classes which perform operations on other objects are
known as Utility Classes.
=>The following are some important utility classes on

thi
i

string-objects:
(i)StringTokenizer class

ipa

(ii)StringJoiner class

Ma

(i)StringTokenizer class:

=>"StringTokenizer" class is from java.util package and

which is used to break the given String into pieces based on

Ve
nk
ate
sh

delimiter.(delimiter means break specification)

=>The following are some important methods of

StringTokenizer:

(a)hasMoreTokens()
(b)nextToken()

(c)countTokens()

(a)hasMoreTokens():

=>hasMoreTokens() method will check the token available or
not,and generate boolean result.
Method Signature:

public boolean hasMoreTokens();

(b)nextToken():
=>nextToken() method is used to delete and retrieve the

Method Signature:

ipa

public java.lang.String nextToken();

thi
i

token from StringTokenizer object.

Ma

(c)countTokens():

=>countTokens() method is used to count number of tokens
from the StringTokenizer Object.

Ve
nk
ate
sh

Method Signature:

public int countTokens();

------------------------------------------------

Ex-program : DemoString17.java

package maccess;
import java.util.*;
public class DemoString17 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the String:");
String str = s.nextLine();
System.out.println("Enter the
delimiter:");
String dl = s.nextLine();

ipa

thi
i

StringTokenizer ob = new
StringTokenizer(str,dl);
System.out.println("count of
Tokens:"+ob.countTokens());
System.out.println("****DisplayTokens****");
while(ob.hasMoreTokens())
{
String tk = ob.nextToken();
System.out.println(tk);
}//end of loop
System.out.println("****After retrieveprocess****");
System.out.println("count of
Tokens:"+ob.countTokens());

Ma

Ve
nk
ate
sh

}

}

}catch(Exception e) {e.printStackTrace();}
}//end of try

o/p:

Enter the String:

java is simple,java is secure,Java i MulT.Java is DD.
Enter the delimiter:
,.

count of Tokens:12

****Display-Tokens****
java
is
simple

java
is
secure
Java

thi
i

i
MulT
Java

ipa

is

****After retrieve-process****

Ve
nk
ate
sh

count of Tokens:0

Ma

DD

Diagram:

================================================

Assignment-1:

Wap to read a String and display reverse of words in the
String?

i/p : java is good language programming
o/p : avaj si doog egaugnal gnimmargorp

Assignment-2:
wap to read a String and display the reverse of words which
starts with Consonent?

thi
i

i/p : Cat is under the table
o/p : taC is under eht elbat

=================================================

ipa

Dt : 12/6/2023

Ma

*imp
(ii)StringJoiner class:

=>StringJoiner class is from java.util package introduced by Java8

Ve
nk
ate
sh

version and which is used to join the Strings based on delimiter.
=>The following are some important methods of StringJoiner class:
public java.util.StringJoiner setEmptyValue
(java.lang.CharSequence);

public java.lang.String toString();

public java.util.StringJoiner add(java.lang.CharSequence);
public java.util.StringJoiner merge(java.util.StringJoiner);
public int length();

Program : DemoString18.java
package maccess;

Ve
nk
ate
sh

Ma

ipa

thi
i

import java.util.*;
public class DemoString18 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
StringJoiner sj1 = new
StringJoiner("/");
sj1.setEmptyValue("No Joining date
available");
System.out.println("Date of
Joining:"+sj1.toString());
System.out.println("Enter the date:");
sj1.add(s.nextLine());
System.out.println("Enter the month:");
sj1.add(s.nextLine());
System.out.println("Enter the year:");
sj1.add(s.nextLine());
System.out.println("Date of
Joining:"+sj1.toString());
StringJoiner sj2 = new StringJoiner("");
sj2.setEmptyValue("No Address
available..");
System.out.println("Address =>
"+sj2.toString());
System.out.println("Enter the city:");
sj2.add(s.nextLine());
System.out.println("Enter the State:");
sj2.add(s.nextLine());
System.out.println("Enter the
PinCode:");
sj2.add(s.nextLine());
System.out.println("Address =>
"+sj2.toString());
System.out.println("****After
merging***");
sj1.merge(sj2);
System.out.println(sj1);

System.out.println("length of sj1 =>
"+sj1.length());
}catch(Exception e) {e.printStackTrace();}
}//end of try
}
}

Date of Joining:No Joining date available

ipa

Enter the date:
21

Enter the year:

Ve
nk
ate
sh

1990

Ma

Enter the month:
11

Date of Joining:21/11/1990

Address => No Address available..
Enter the city:
Hyd

Enter the State:
TS

Enter the PinCode:
600123
Address => Hyd-TS-600123
****After merging***

thi
i

o/p:

21/11/1990/Hyd-TS-600123
length of sj1 => 24
============================================================
*imp

thi
i

WrapperClasses in Java:
=>The pre-defined classes from java.lang package which are used to

make primitive datatypes available in the form of Objects are known as

ipa

WrapperClasses.

are eight WrapperClasses.

Ma

=>Every primitive datatype will have its own WrapperClass and there

=>The following are the list of WrapperClasses:
WrapperClass

Ve
nk
ate
sh

datatype
byte

Byte

short

Short

int

Integer

long

Long

float

Float

double
char

boolean

Double

Character

Boolean

Hierarchy of WrapperClasses:

===============================================================
faq:
define Boxing Process?
=>The process of binding primitive datatypes into WrapperClass objects

thi
i

is known as Boxing process.
=>This Boxing process can be performed using Constructors.

WrapperClass

List-of-Constructors

Byte(byte),Byte(String)

Short

Short(short),Short(String)

Integer

Ma

Byte

ipa

=>The following are the list of constructors from WrapperClasses:

Integer(int),Integer(String)
Long(long),Long(String)

Float

Float(float),Float(double),Float(String)

Ve
nk
ate
sh

Long

Double

Double(double),Double(String)

Character

Character(char)

Boolean

Boolean(boolean)

----------------------------------------------------------Ex-program : DemoWrapperClass1.java

package maccess;
public class DemoWrapperClass1 {
@SuppressWarnings({ "unused", "removal" })
public static void main(String[] args) {
//Boxing Process
Integer ob1 = new Integer(12);
Integer ob2 = new Integer("13");

Float ob3 = new Float(12.34F);
Float ob4 = new Float(1234.56);
Float ob5 = new Float("11.23F");
Character ob6 = new Character('A');

Ma

ipa

thi
i

Boolean ob7 = new Boolean(true);
Boolean ob8 = new Boolean(false);
System.out.println("====Display from
Objects====");
System.out.println("ob1:"+ob1.toString());
System.out.println("ob2:"+ob2.toString());
System.out.println("ob3:"+ob3.toString());
System.out.println("ob4:"+ob4.toString());
System.out.println("ob5:"+ob5.toString());
System.out.println("ob6:"+ob6.toString());
System.out.println("ob7:"+ob7.toString());
System.out.println("ob8:"+ob8.toString());
}

Ve
nk
ate
sh

}

o/p:

====Display from Objects====
ob1:12
ob2:13

ob3:12.34

ob4:1234.56
ob5:11.23
ob6:A
ob7:true

ob8:false
====================================================
faq:
define UnBoxing process?

Objects is known as UnBoxing process.

thi
i

=>The process of taking primitive datatype values outof WrapperClass

=>we use the following pre-defined methods to perform UnBoxing

ipa

process:

public short shortValue();
public int intValue();

Ve
nk
ate
sh

public long longValue();

Ma

public byte byteValue();

public float floatValue();

public double doubleValue()
public char charValue();

public boolean booleanValue();

Ex-program : DemoWrapperClass2.java

package maccess;
public class DemoWrapperClass2{
@SuppressWarnings({ "removal" })
public static void main(String[] args) {
//Boxing Process
Integer ob1 = new Integer(12);
Integer ob2 = new Integer("13");

Float ob3 = new Float(12.34F);
Float ob4 = new Float(1234.56);
Float ob5 = new Float("11.23F");
Character ob6 = new Character('A');

thi
i

Boolean ob7 = new Boolean(true);
Boolean ob8 = new Boolean("false");

Ma

ipa

//UnBoxing process
int i1 = ob1.intValue();
int i2 = ob2.intValue();
float f1 = ob3.floatValue();
double d = ob4.doubleValue();
float f2 = ob5.floatValue();
char ch = ob6.charValue();
boolean b1 = ob7.booleanValue();
boolean b2 = ob8.booleanValue();

Ve
nk
ate
sh

System.out.println("====Display Values====");
System.out.println("i1:"+i1);
System.out.println("i2:"+i2);
System.out.println("f1:"+f1);
System.out.println("d:"+d);
System.out.println("f2:"+f2);
System.out.println("ch:"+ch);
System.out.println("b1:"+b1);
System.out.println("b2:"+b2);

}

}

o/p:
====Display Values====

i1:12
i2:13
f1:12.34
d:1234.56005859375

thi
i

f2:11.23
ch:A
b1:true

ipa

b2:false

faq:
define AutoBoxing process?

Ma

===========================================================

Ve
nk
ate
sh

=>The boxing process which is performed automatically is known as

AutoBoxing process.

=>In AutoBoxing process the NonPrimitive datatype variables are

assigned with primitive datatype values.

faq:

define AutoUnBoxing process?

=>The UnBoxing process which is performed automatically is known as

AutoUnBoxing process.
=>In AutoUnBoxing process the Primitive datatype variable assigned
with NonPrimitive datatype variables.

Program : DemoWrapperClass3.java

thi
i

package maccess;
public class DemoWrapperClass3{
public static void main(String[] args) {
//AutoBoxing Process
Integer ob1 = 12;
Float ob3 = 12.34F;

Boolean ob7 = true;

ipa

Character ob6 = 'A';

Ve
nk
ate
sh

Ma

//AutoUnBoxing process
int i1 = ob1;
float f1 = ob3;
char ch = ob6;
boolean b1 = ob7;

System.out.println("====Display Values====");
System.out.println("i1:"+i1);
System.out.println("f1:"+f1);
System.out.println("ch:"+ch);
System.out.println("b1:"+b1);

}

}

o/p:
====Display Values====
i1:12

f1:12.34
ch:A
b1:true

Ve
nk
ate
sh

Ma

ipa

thi
i

===============================================================

6/14/23, 8:32 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

String4.png

1/1

6/14/23, 8:33 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

WrapperClass1.png

1/1

Dt : 13/6/2023
faq:
why we have to make primitive datatypes available in the form of
Objects?

thi
i

=>Java Frameworks and tools will accept data only in the form of
Objects,because of this reason we have to make primitive datatypes
available in the form of Objects.

ipa

=============================================================

Arrays in Java:

Ma

*imp

=>The sequenced collection of elements of same date type is known as

Ve
nk
ate
sh

Array.
(or)

=>According to Java,Array is a sequenced Collection of Objects
generated from the same class

Types of Arrays:

=>In Java,Arrays are categorized into two types:
1.Single Dimensional Arrays
2.Multi Dimensional Arrays

1.Single Dimensional Arrays:

=>The Arrays which are declared with single dimension are known as
Single-D Arrays or 1-D Arrays.
syntax:
Class_name arr_var[] = new Class_name[size];

thi
i

--------------------------------------------------Ex-program :

ipa

Wap to read and display Integer WrapperClass objects using Array?

Program : DemoArray1.java

Ve
nk
ate
sh

Ma

package p2;
import java.util.*;
public class DemoArray1 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the size of
Array:");
int n = s.nextInt();
Integer a[] = new Integer[n];
System.out.println("Enter "+n+" Integer
eles..");
for(int i=0;i<a.length;i++)
{
a[i] = new Integer(s.nextInt());
}//end of loop
System.out.println("====Using Old for
loop===");
for(int i= 0;i<a.length;i++)
{
System.out.print(a[i].toString()+" ");
}//end of loop

Ma

ipa

thi
i

System.out.println("\n****Using Extended
for(Java5)****");
for(Integer k : a)
{
System.out.print(k.toString()+" ");
}//end of loop
System.out.println("\n****Uisng
Spliterator<T>(Java8)***");
Spliterator<Integer> sp =
Arrays.spliterator(a);
sp.forEachRemaining((k)->
{
System.out.print(k.toString()+" ");
});
}catch(Exception e) {e.printStackTrace();}
}//end of try
}
}

Ve
nk
ate
sh

o/p:

Enter the size of Array:
5

Enter 5 Integer eles..
11
10
9

18
17

====Using Old for loop===
11 10 9 18 17

****Using Extended for(Java5)****
11 10 9 18 17
****Uisng Spliterator<T>(Java8)***
11 10 9 18 17

thi
i

-------------------------------------------------faq:
define Extended-for?

ipa

=>Extended-for introduced by Java5 version and which is used to

Enhanced-for-loop
syntax:

Ma

retrieve elements from Array-Objects and which is also known as

Ve
nk
ate
sh

for(data_type var : Container_name)
{

//loop_body

}

Advantage:

=>In Extended-for we specify only Container-name and type of data.
=>In Extended-for,

=>no initialization
=>no Condition
=>no Increment-decrement

=>Extended-for is Auto-executable loop
==========================================================
*imp
define Spliterator<T>?

thi
i

=>Spliterator<T> is an interface from java.util package introduced
by Java8 version and which is used to retrieve elements from Array and
Collection<E> objects.

Ma

public default void forEachRemaining

ipa

=>Spliterator<T> will provide the one important method:

(java.util.function.Consumer<? super T>);

=>we use spliterator() method from java.util.Arrays class to create

Ve
nk
ate
sh

implementation object for "Spliterator<T>" interface

method Signature of spliterator():

public static <T> java.util.Spliterator<T> spliterator(T[]);

syntax:

Spliteratot<T> sp = Arrays.spliterator(T[]);
Ex:

Spliterator<Integer> sp = Arrays.spliterator(a);

faq:

define Consumer<T>?
=>Consumer<T> is a functional interface from java.util.function
package introduced by Java8 version and which provide method "accept(T)"
to hold LambdaExpression passed as parameter to forEachRemaining()

Structure of Consumer<T>:

ipa

public interface java.util.function.Consumer<T>

thi
i

method.

public abstract void accept(T);
...

Ve
nk
ate
sh

}

Ma

{

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh

================================================================
Assignment:

wap to read and display multiple Strings using Arrays?
==============================================================

Dt : 14/6/2023
Assignment:(Solution)
wap to read and display multiple Strings using Arrays?

Program : DemoArray2.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoArray2 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter the size of
Array:");
int n = Integer.parseInt(s.nextLine());
String a[] = new String[n];
System.out.println("Enter "+n+" String
eles..");
for(int i=0;i<a.length;i++)
{
a[i] = new String(s.nextLine());
}//end of loop
System.out.println("====Using Old for
loop===");
for(int i= 0;i<a.length;i++)
{
System.out.println(a[i].toString()+"
");
}//end of loop
System.out.println("****Using Extended
for(Java5)****");
for(String k : a)
{
System.out.println(k.toString()+" ");
}//end of loop

ipa

thi
i

System.out.println("****Uisng
Spliterator<T>(Java8)***");
Spliterator<String> sp =
Arrays.spliterator(a);
sp.forEachRemaining((k)->
{
System.out.println(k.toString()+" ");
});
}catch(Exception e) {e.printStackTrace();}
}//end of try
}
}

Enter the size of Array:

Ve
nk
ate
sh

5

Ma

o/p:

Enter 5 String eles..
java is Secured
java is PI

Java is AN

Java is Thread
Java is Robust

====Using Old for loop===
java is Secured
java is PI
Java is AN

Java is Thread
Java is Robust
****Using Extended for(Java5)****
java is Secured

thi
i

java is PI
Java is AN

Java is Robust

java is Secured
java is PI

Ve
nk
ate
sh

Java is AN

Ma

****Uisng Spliterator<T>(Java8)***

ipa

Java is Thread

Java is Thread
Java is Robust

==============================================================

Ex-program:

wap to read and display multiple employee details using Array?

Employee.java

package p1;
public class Employee extends Object
{
public String eId,eName,eDesg;
public int bSal;

thi
i

public float totSal;
@Override
public String toString()
{
return
eId+"\t"+eName+"\t"+eDesg+"\t"+bSal+"\t"+totSal;
}
}
DemoArray3.java(MainClass)

ipa

package p2;
import p1.Employee;

Ma

import java.util.*;
public class DemoArray3 extends Exception
{

Ve
nk
ate
sh

public DemoArray3(String msg)
{

super(msg);

}

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
try(s;){
try {

System.out.println("Enter the nymber of Employees:");

int n = Integer.parseInt(s.nextLine());
Employee ob[] = new Employee[n];
System.out.println("Enter "+n+" Employee details...");
int i=0;

thi
i

while(i<ob.length)
{
try

ipa

{

Ma

System.out.println("Enter details of Employee-"+(i+1));
ob[i] = new Employee();

System.out.println("Enter the EmpId:");

Ve
nk
ate
sh

ob[i].eId = s.nextLine();

System.out.println("Enter the EmpName:");
ob[i].eName = s.nextLine();
System.out.println("Enter the EmpDesg:");
ob[i].eDesg = s.nextLine();
System.out.println("Enter the EmpBSal:");
ob[i].bSal = Integer.parseInt(s.nextLine());
if(ob[i].bSal<12000)//Exception Condition
{
throw new DemoArray3("Invalid bSal..");
}

ob[i].totSal =
ob[i].bSal+(0.93F*ob[i].bSal)+(0.63F*ob[i].bSal);
i++;
}//end of try
catch(DemoArray3 da)

thi
i

{

System.out.println(da.getMessage());

ipa

}
}//end of loop

Ma

System.out.println("====EmployeeDetails====");

Spliterator<Employee> sp = Arrays.spliterator(ob);

Ve
nk
ate
sh

sp.forEachRemaining((k)->System.out.println(k));
}catch(Exception e) {e.printStackTrace();}

}//end of try with resource
}

}

o/p:

Enter the nymber of Employees:
2

Enter 2 Employee details...
Enter details of Employee-1
Enter the EmpId:

A001
Enter the EmpName:
Raj
Enter the EmpDesg:

thi
i

SE
Enter the EmpBSal:
-12000

ipa

Invalid bSal..

Enter the EmpId:
A123

Ve
nk
ate
sh

Enter the EmpName:

Ma

Enter details of Employee-1

Raj

Enter the EmpDesg:
SE

Enter the EmpBSal:
18000

Enter details of Employee-2
Enter the EmpId:
123
Enter the EmpName:
Ram

Enter the EmpDesg:
TE
Enter the EmpBSal:
18000

A123 Raj

1800046080.0

Ram TE

1800046080.0

Ve
nk
ate
sh

Ma

ipa

123

SE

thi
i

====EmployeeDetails====

==========================================================
Assignment:
wap to read and display multiple Student-details?
(rollNo,name,branch,totM,per,result)

==========================================================
faq:
define Object-Array?
=>The Array which is declared with "java.lang.Object" class is known

thi
i

as Object-Array.
=>Object-Array will hold Dis-Similer Objects,which means objects

ipa

generated from different classes.

Object o[] = new Object[size];

Ve
nk
ate
sh

Ex-program :

Ma

syntax:

User.java

package p1;
public class User extends Object
{
public String name;
public long phNo;
public User(String name,long phNo)
{
this.name=name;
this.phNo=phNo;
}
@Override
public String toString()
{
return name+"\t"+phNo;
}
}

DemoArray4.java
package p2;
import java.util.*;

thi
i

import p1.User;
public class DemoArray4

@SuppressWarnings("removal")

{
Object o[] = new Object[3];

Ma

public static void main(String[] args)

ipa

{

Ve
nk
ate
sh

o[0] = new Integer(121);//Integer WrapperClass Object
o[1] = new String("NIT-JAVA");//String-Class Object
o[2] = new User("Raj",9898981234L);

System.out.println("****Object-Array****");
Spliterator<Object> sp = Arrays.spliterator(o);
sp.forEachRemaining((k)->System.out.println(k));
}

}

o/p:
****Object-Array****

121
NIT-JAVA
Raj

9898981234

=============================================================

thi
i

2.Multi Dimensional Arrays:
=>The Arrays which are declared with multiple dimensions are known
as Multi-Dimensional Arrays

ipa

Ex:

3-D Arrays
4-D Arrays

Ve
nk
ate
sh

...

Ma

2-D Arrays

syntax of 2-D Array:

Class_name ob[][] = new Class_name[size][size];

------------------------------------------------------------Ex-program : DemoArray5.java

package p2;
import java.util.*;
public class DemoArray5 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {

Ve
nk
ate
sh

Ma

ipa

thi
i

Integer a[][] = new Integer[3][3];
System.out.println("Enter 3X3 Matrix:");
for(int i=0;i<=2;i++)//Rows
{
for(int j=0;j<=2;j++)//Cols
{
a[i][j] = new Integer(s.nextInt());
}//InnerLoop
}//OuterLoop
System.out.println("====Display 3x3
Matrix===");
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
System.out.print(a[i][j]+" ");
}//InnerLoop
System.out.println();
}//OuterLoop
System.out.println("***Spliterator<T>****");
Spliterator<Integer[]> sp1 =
Arrays.spliterator(a);
sp1.forEachRemaining((i)->
{
Spliterator<Integer> sp2 =
Arrays.spliterator(i);
sp2.forEachRemaining((j)->
{
System.out.print(j+" ");
});
System.out.println();
});
}catch(Exception e) {e.printStackTrace();}
}//end of try
}
}
o/p:
Enter 3X3 Matrix:

11
12
13
14

thi
i

15
16
17

ipa

18

====Display 3x3 Matrix===
11 12 13

Ve
nk
ate
sh

14 15 16

Ma

19

17 18 19

***Spliterator<T>****
11 12 13
14 15 16
17 18 19

==============================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 15/6/2022

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:(Representing 2-D Array)

===============================================================
faq:
define Jagged Array?

=>The Array which is holding Array-Objects is known as Jagged-Array

Note:
=>2-D Array we can call as Jagged Array

thi
i

=============================================================
Ex-program:

ipa

wap to add two 3X3 Matrices?

Addition.java

Ma

Program :

Ve
nk
ate
sh

package p1;
public class Addition
{
public Integer[][] add(Integer x[][],Integer y[][])
{
Integer z[][] = new Integer[3][3];
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
z[i][j]=x[i][j]+y[i][j];
}//InnerLoop
}//outerLoop
return z;
}
}
DemoArra6.java
package p2;
import java.util.*;

Ve
nk
ate
sh

Ma

ipa

thi
i

import p1.Addition;
public class DemoArra6
{
public static void main(String[] args)
{
Scanner s = new Scanner(System.in);
try(s;){
try {
System.out.println("Enter 3X3 Matrix A");
Integer a[][] = new Integer[3][3];
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
a[i][j] = s.nextInt();
}//end of loop
}//end of loop
System.out.println("Enter 3X3 Matrix B");
Integer b[][] = new Integer[3][3];
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
b[i][j] = s.nextInt();
}//end of loop
}//end of loop
Addition ad = new Addition();
Integer c[][] = ad.add(a, b);//method call
System.out.println("====MatrixAddition====");
for(int i=0;i<=2;i++)
{
for(int j=0;j<=2;j++)
{
System.out.print(c[i][j]+" ");
}//end of loop
System.out.println();
}//end of loop
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

}
}
o/p:
Enter 3X3 Matrix A

thi
i

1
1

ipa

1

1
1

Ve
nk
ate
sh

1

Ma

1

1
1

Enter 3X3 Matrix B
1
1
1
1
1
1
1

1
1
====Matrix-Addition====
222

thi
i

222
222

===========================================================

ipa

Assignment-1:

Sum of all elements=
Small element from Array=

Ve
nk
ate
sh

Largest element from Array=

Ma

wap to read 1-D Integer Array and display the following:

Assignment-2:

Wap to read 2-D Integer Array and display the sum of diagonal elements?

Assignment-3:

wap to perform Matrix Multiplication on 3X3 Matrices?
=========================================================

faq:
can we pass parameters to standard main() method?
=>Yes,we can pass parameters to Standard main() method while execution

command,because main() method call is available in execution command.

syntax:

thi
i

java Class_name arg1 arg2 arg3 ...

Ex:

ipa

java DemoMain Text 12.34 A 123

import java.util.*;
class DemoMain

Ve
nk
ate
sh

{

Ma

Ex-program : DemoMain.java

static public void main(String...p)
{

System.out.println("****Display from args[]****");
Spliterator<String> sp = Arrays.spliterator(p);
sp.forEachRemaining((k)->
{

System.out.println(k);

});

}

}
o/p:

D:\Demo146>javac DemoMain.java

thi
i

D:\Demo146>java DemoMain Text 12.34 A 123
****Display from args[]****
Text

ipa

12.34

123

Ma

A

Ve
nk
ate
sh

===================================================
faq:

define Command Line argument Program?

=>The program in which we pass arguments to main() method is known as

Command Line argument Program.

faq:

wt is the diff b/w
(i)arguments
(ii)parameters

=>arguments means passing values to method while method call
=>parameters means passing variables to methods while method call
=============================================================
*imp

public static void main(String[] args)
static public void main(String[] args)

ipa

public static void main(String args[])

thi
i

=>we can represent standard main() method in the following ways:

Ma

public static void main(String...args) <====Var-args format
public static void main(String[] p)

================================================================

Ve
nk
ate
sh

Dis-Advantage of Arrays:

=>Array size once defined cannot be modified at runtime,because of

this reason arrays are not preferable in realtime to hold dynamic and
runtime data.

Note:

=>DisAdvantage of Arrays can be Overcomed using Collection<E>

==================================================================

Dt : 16/6/2023
*imp
Java Collection Framework(JCF):

thi
i

define collection?(General definition)
=>The process of collecting group of elements together is known as

ipa

collection.

Ma

*imp
define Collection<E>?(Java Component)

=>Collection<E> is an interface from java.util package and which

Ve
nk
ate
sh

is root of Java Collection<E> framework.

=>This Collection<E> interface is extended into the following

SubInterfaces:
1.Set<E>

2.List<E>

3.Queue<E>

Hierarchy of Collection<E>:

thi
i
ipa
Ma
Ve
nk
ate
sh
---------------------------------------------------------

faq:

define Framework?

=>The structure which is ready constructed and available for

application development is known as Framework.

thi
i
ipa
Ma
Ve
nk
ate
sh

==============================================================
*imp

Complete Structure of Collection<E> Framework:

thi
i
ipa

=================================================

Ma

faq:

define Generic Programming Components?

Ve
nk
ate
sh

=>The components which are ready to accept any type are known
as Generic Programming Components

=>The following are some important generic Programming components:
1.Generic Types

2.Generic Methods
3.Generic Classes

4.Generic Interfaces

1.Generic Types:
=>The types which are ready to accept any type of data are known
as Generic Types.

T - Type
E - Element
K - Key

thi
i

V - Value

2.Generic Methods:

parameters are known as Generic Methods.

<T>return_type method_name(T)
{

Ve
nk
ate
sh

//method_name

Ma

Structure:

ipa

=>The methods which are ready to accept any type of data as

}

3.Generic Classes:

=>The classes which generate objects and the Objects are ready

to hold any type of data are known as Generic Classes.
Structure:

class Class_name<T>
{
//Class_body
}

4.Generic Interfaces:
=>Generic Interfaces are implemented to Generic Classes.

thi
i

Structure:
interface Interface_name<T>
{

ipa

//Interface_body

Ma

}

===========================================================

Ve
nk
ate
sh

Ex-program:(Demonstrating User defined Generic Class)

Diusplay.java

package p1;
public class Display<T>
{
public T ob;
public Display(T ob)
{
this.ob = ob;
}
public T getRef()
{
return ob;
}
}
User.java
package p1;

thi
i

public class User {
public String name,mId;
public User(String name,String mId) {
this.name=name;
this.mId=mId;
}
public String toString() {
return name+"\t"+mId;
}
}

ipa

DemoGeneric.java(MainClass)

Ve
nk
ate
sh

Ma

package p2;
import p1.*;
public class DemoGeneric {
@SuppressWarnings("removal")
public static void main(String[] args) {
Display<Integer> ob1 = new Display<Integer>(new
Integer(12));
Display<String> ob2 = new Display<String>("NIT");
Display<User> ob3 = new Display<User>(new
User("Raj","r@.."));
System.out.println(ob1.getRef());
System.out.println(ob2.getRef());
System.out.println(ob3.getRef());
}

}

Diagram:

thi
i
ipa
Ma

Ve
nk
ate
sh

===========================================================

dt : 17/6/2023
1.Set<E>:
=>Set<E> is an interface from java.util package and which is
extended from "Collectionb<E>".

thi

=>Set<E> organizes elements without index values and which cannot
hold duplicate elements.

ipa

(Set<E> means no index and no duplicate)
=>The following are some important methods of Set<E>:

Ma

public abstract int size();
public abstract boolean isEmpty();

public abstract boolean contains(java.lang.Object);

Ve
nk
ate
sh

public abstract boolean add(E);

public abstract boolean remove(java.lang.Object);
public abstract boolean containsAll(java.util.Collection<?>);
public abstract boolean addAll

(java.util.Collection<? extends E>);

public abstract boolean retainAll(java.util.Collection<?>);
public abstract boolean removeAll(java.util.Collection<?>);
public abstract void clear();

public static <E> java.util.Set<E> of();

public abstract java.util.Iterator<E> iterator();

public default java.util.Spliterator<E> spliterator();

public abstract java.lang.Object[] toArray();
public abstract <T> T[] toArray(T[]);

thi

-----------------------------------------------=>The following are the implementattion classes of Set<E>:

ipa

(a)HashSet<E>
(b)LinkedHashSet<E>

(a)HashSet<E>:

Ma

(c)TreeSet<E>

Ve
nk
ate
sh

=>HashSet<E> will hold elements without any order.

(b)LinkedHashSet<E>:

=>LinkedHashSet<E> will hold elements in insertion order.

(c)TreeSet<E>:

=>TreeSet<E> will hold elements automatically in ascending order

==================================================================

Ex-program:(Demonstrating Operations on Set<E>)

Program : DemoSet1.java

Ve
nk
ate
sh

Ma

ipa

thi

package p2;
import java.util.*;
public class DemoSet1 {
@SuppressWarnings("removal")
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
Set<Integer> ob = null;
String nm = null;
while(true) {
System.out.println("****Choice****");
System.out.println("\t1.HashSet"
+ "\n\t2.LinkedHashSet"
+ "\n\t3.TreeSet"
+ "\n\t4.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
ob = new HashSet<Integer>();
nm = "HashSet";
break;
case 2:
ob = new LinkedHashSet<Integer>();
nm = "LinkedHashSet";
break;
case 3:
ob = new TreeSet<Integer>();
nm = "TreeSet";
break;
case 4:
System.out.println("Operatios
Stopped on Set");
System.exit(0);//Stop the program
default:
System.out.println("Invalid
Choice");
continue;//skip below lines within
the loop
}//end of switch

System.out.println("---->Perform
operations on "+nm);
xyz:while(true) {

Ma

ipa

thi

System.out.println("====Choice====");
System.out.println("\t1.add(E)"
+ "\n\t2.remove(Object)"
+ "\n\t3.DisplayElements"
+ "\n\t4.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
ele:");
ob.add(new
Integer(s.nextInt()));

Ve
nk
ate
sh

System.out.println(ob.toString());
break;
case 2:
if(ob.isEmpty()) {
System.out.println("Set is
empty..");
}else {
the ele to be removed:");
Integer(s.nextInt()))) {

System.out.println("Enter

if(ob.remove(new

System.out.println("Ele removed Successfully..");
System.out.println(ob.toString());
}else {
System.out.println("Ele
not found in the Set...");
}
}
break;

empty...");

case 3:
if(ob.isEmpty()) {
System.out.println("Set is
}else {

thi

System.out.println("====Iterator<E>====");
Iterator<Integer> it1 =
ob.iterator();
while(it1.hasNext()) {

ipa

System.out.print(it1.next()+" ");
}//end of loop

Ma

System.out.println("\n====Iterator<E>forEachRemaing()=====");
Iterator<Integer> it2 =
ob.iterator();
it2.forEachRemaining((k)>System.out.print(k+" "));

Ve
nk
ate
sh

System.out.println("\n====Spliterator<T>(Java8)====");
Spliterator<Integer> sp =
ob.spliterator();
sp.forEachRemaining((k)>System.out.print(k+" "));
System.out.println("\n=====forEach()(Java8)====");
ob.forEach((k)>System.out.print(k+" "));
System.out.println();
}//end of else
break;
case 4:
System.out.println("Operations
Stopped on "+nm);
break xyz;//Stopping InnerLoop
default:
System.out.println("Invalid
Choice...");

}

}

}//end of switch
}//InnerLoop
}//OuterLoop
}//end of try-with-resource

thi

o/p:
****Choice****

ipa

1.HashSet
2.LinkedHashSet

4.exit
Enter the Choice:

Ve
nk
ate
sh

3

Ma

3.TreeSet

---->Perform operations on TreeSet
====Choice====
1.add(E)

2.remove(Object)

3.DisplayElements
4.exit

Enter the Choice:
1
Enter the ele:
11

[11]
====Choice====
1.add(E)
2.remove(Object)

thi

3.DisplayElements
4.exit

ipa

Enter the Choice:
1

12
[11, 12]

Ve
nk
ate
sh

====Choice====

Ma

Enter the ele:

1.add(E)

2.remove(Object)

3.DisplayElements
4.exit

Enter the Choice:
1

Enter the ele:
14
[11, 12, 14]

====Choice====

1.add(E)
2.remove(Object)
3.DisplayElements
4.exit

thi

Enter the Choice:

ipa

10
Invalid Choice...

1.add(E)
2.remove(Object)

Ve
nk
ate
sh

3.DisplayElements

Ma

====Choice====

4.exit

Enter the Choice:
1

Enter the ele:
9

[9, 11, 12, 14]

====Choice====
1.add(E)

2.remove(Object)
3.DisplayElements

4.exit
Enter the Choice:
1
Enter the ele:

thi

10
[9, 10, 11, 12, 14]

ipa

====Choice====
1.add(E)

3.DisplayElements
4.exit

Ma

2.remove(Object)

Ve
nk
ate
sh

Enter the Choice:
3

====Iterator<E>====
9 10 11 12 14

====Iterator<E>-forEachRemaing()=====
9 10 11 12 14

====Spliterator<T>(Java8)====
9 10 11 12 14

=====forEach()(Java8)====
9 10 11 12 14
====Choice====

1.add(E)
2.remove(Object)
3.DisplayElements
4.exit

thi

Enter the Choice:
4

ipa

Operations Stopped on TreeSet
****Choice****

2.LinkedHashSet
3.TreeSet

Ma

1.HashSet

Ve
nk
ate
sh

4.exit

Enter the Choice:
4

Operatios Stopped on Set

===========================================================

Dt : 21/6/2023
*imp
define Iterator<E>?
=>Iterator<E> is an interface from java.util package and which is

thi
i

used to retrieve elements from Collection<E>-Objects in forward
direction.

public abstract boolean hasNext();

public default void remove();

Ma

public abstract E next();

ipa

=>The following are some important methods of Iterator<E>:

public default void forEachRemaining

Ve
nk
ate
sh

(java.util.function.Consumer<? super E>);

hasNext() : This method will check the ele available or not,and returns
boolean result

next() : This method is used to retrieve ele from Collection<E>
Object

remove() : This method is used to remove the ele from the Collection<E>
Object

forEachRemaining() : This method is also used to retrieve elements from

Collection<E> object using LambdaExpression as
method argument.
-------------------------------------------------------------=>we use iterator() method to create implementation object for

thi
i

Iterator<E> interface.
syntax:

ipa

Iterator<Integer> it1 = ob.iterator();

define Spliterator<T>?

Ma

===================================================================

=>Spliterator<T> is a normal interface introduced by Java8 version

Ve
nk
ate
sh

and which is used to display elements from Array objects and
Collection<E> Objects.

=>Spliterator<T> is having the following method:
public default void forEachRemaining

(java.util.function.Consumer<? super T>);

=>we use spliterator() method to create implementation object for

Spliterator<T> interface.
syntax:

Spliterator<Integer> sp = ob.spliterator();

Diagram:

===============================================================
Assignment-1:
Update above program to display only Prime numbers?

thi
i

Assignment-2:
Update above program to perform operations on User defined Class
Product Objects?

ipa

===================================================================

*imp
define Predicate<T>?

Ma

Dt : 22/6/2023

Ve
nk
ate
sh

=>Predicate<T> is a functional interface from java.util.function package

and which is used to perform conditional operation on Collection<E> objects.

structure of Predicate<T>:

public interface java.util.function.Predicate<T>
{

public abstract boolean test(T);
...

}

syntax:
Predicate<Class_name> pr = (T)->
{
...

Assignment-1:(Solution)

Program : DemoSet2.java
package p2;

Ve
nk
ate
sh

import java.util.*;

Ma

ipa

Update above program to display only Prime numbers?

thi
i

};

import java.util.function.*;
public class DemoSet2 {

@SuppressWarnings("removal")

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
try(s;){

try {

LinkedHashSet<Integer> ob = new
LinkedHashSet<Integer>();
System.out.println("Enter the number of eles:");

int n = s.nextInt();
System.out.println("Enter "+n+" elements...");
for(int i=1;i<=n;i++)
{

}//end of loop

thi
i

ob.add(new Integer(s.nextInt()));

System.out.println("***All elements***");

ipa

System.out.println(ob.toString());

Ma

System.out.println("****Prime Numbers****");
Predicate<Integer> pr = (k)->
{

Ve
nk
ate
sh

int count=0;

for(int i=1;i<=k;i++)
{

if(k%i==0)
{

count++;

}

}//end of loop
if(count==2)
{

return true;

}
else
{
return false;

thi
i

}
};
ob.forEach((z)->

ipa

{

{

Ma

if(pr.test(z))

System.out.print(z+" ");

Ve
nk
ate
sh

}

});

}catch(Exception e) {e.printStackTrace();}

}//end of try with resource

}

}

o/p:

Enter the number of eles:
11
Enter 11 elements...

13
20
16
14

thi
i

56
17
21

ipa

43

77
27

Ve
nk
ate
sh

***All elements***

Ma

41

[13, 20, 16, 14, 56, 17, 21, 43, 41, 77, 27]
****Prime Numbers****
13 17 43 41

==========================================================

Note:

=>when we want to perform Sorting process on User defined class Objects

using TreeSet<E>,the user defined class must be modified with the following:

step-1 : The User defined class must be implemented from
"java.lang.Comparable" interface

Structure of Comparable:
public interface java.lang.Comparable<T>
{
public abstract int compareTo(T);

thi
i

}

step-2 : The user defined class must construct body for "compareTo()"

Ma

ipa

method and which holds sort-specification-logic.

---------------------------------------------------------------Assignment-2:(Solution)

Ve
nk
ate
sh

Update above program to perform operations on User defined Class
Product Objects?

Product.java

package p1;
@SuppressWarnings("rawtypes")
public class Product extends Object implements
Comparable
{
public String code,name;
public float price;
public int qty;
public Product(String code,String name,float price,
int qty)
{
this.code=code;

this.name=name;
this.price=price;
this.qty=qty;

}

Ma

ipa

thi
i

}
@Override
public String toString()
{
return code+"\t"+name+"\t"+price+"\t"+qty;
}
@Override
public int compareTo(Object o)
{
Product p = (Product)o;
int x = code.compareTo(p.code);
if(x==0) return 0;
else if(x>0) return 1;
else return -1;
}

Ve
nk
ate
sh

DemoSet3.java(MainClass)
package p2;

import java.util.*;

import p1.Product;

public class DemoSet3 {

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
try(s;){

Set<Product> ob = null;
String nm = null;
while(true) {

System.out.println("****Choice****");
System.out.println("\t1.HashSet"
+ "\n\t2.LinkedHashSet"
+ "\n\t3.TreeSet"

System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {

ipa

case 1:

thi
i

+ "\n\t4.exit");

Ma

ob = new HashSet<Product>();
nm = "HashSet";
break;

Ve
nk
ate
sh

case 2:

ob = new LinkedHashSet<Product>();
nm = "LinkedHashSet";
break;

case 3:

ob = new TreeSet<Product>();
nm = "TreeSet";
break;

case 4:
System.out.println("Operatios Stopped on Set");
System.exit(0);//Stop the program

default:
System.out.println("Invalid Choice");
continue;//skip below lines within the loop
}//end of switch

xyz:while(true) {

thi
i

System.out.println("---->Perform operations on "+nm);

System.out.println("====Choice====");

ipa

System.out.println("\t1.add(E)"

Ma

+ "\n\t2.remove(Object)"

+ "\n\t3.DisplayElements"
+ "\n\t4.exit");

Ve
nk
ate
sh

System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {
case 1:

System.out.println("---ProductDetails---");
System.out.println("Enter the ProdCode:");
String code = s.nextLine();
System.out.println("Enter the ProdName:");
String name = s.nextLine();
System.out.println("Enter the ProdPrice:");
float price = Float.parseFloat(s.nextLine());
System.out.println("Enter the ProdQty:");

int qty = Integer.parseInt(s.nextLine());
ob.add(new Product(code,name,price,qty));
ob.forEach((k)->System.out.println(k));
break;

thi
i

case 2:
if(ob.isEmpty()) {

System.out.println("Set is empty..");

Ma

ipa

}else {

System.out.println("Enter the code remove
product:");

Ve
nk
ate
sh

String cd = s.nextLine();

Iterator<Product> it = ob.iterator();
while(it.hasNext())
{

Product p = (Product)it.next();
if(cd.equals(p.code))
{

it.remove();
//Product Object removed from the

Set
System.out.println

("Product deleted successfully..");
break;
}
}//end of loop

thi
i

ob.forEach((k)->System.out.println(k));
}

case 3:

Ma

if(ob.isEmpty()) {

ipa

break;

System.out.println("Set is empty...");
}else {

Ve
nk
ate
sh

System.out.println("====Iterator<E>====");
Iterator<Product> it1 = ob.iterator();
while(it1.hasNext()) {
System.out.println(it1.next()+" ");

}//end of loop
System.out.println("====Iterator<E>-

forEachRemaing()=====");

Iterator<Product> it2 = ob.iterator();
it2.forEachRemaining((k)-

>System.out.println(k+" "));

System.out.println("====Spliterator<T>(Java8)====");

Spliterator<Product> sp = ob.spliterator();
sp.forEachRemaining((k)>System.out.println(k+" "));
System.out.println();
}//end of else

thi
i

break;
case 4:

ipa

System.out.println("Operations Stopped on "+nm);

default:

Ma

break xyz;//Stopping InnerLoop

System.out.println("Invalid Choice...");

Ve
nk
ate
sh

}//end of switch
}//InnerLoop

}//OuterLoop

}//end of try-with-resource
}

}

------------------------------------------------------------------

6/22/23, 9:34 AM

https://classroom.google.com/c/NjAyNDU2MTk5MTI4/m/NjE0OTIyNDg3NTE5/details

Collection2.png

1/1

-----------------------------------------------------------------Dt : 23/6/2023
Note:
=>TreeSet<E> internally uses Quick-sorting process for string-objects and

thi
i

WrapperClass-objects.
=>TreeSet<E> internally uses Merge-sorting process for User defined class

ipa

Objects.

Ve
nk
ate
sh

Ma

Diagram:

thi
i
ipa
Ma
Ve
nk
ate
sh

==================================================================
*imp

2.List<E>:

=>List<E> is an interface from java.util package and extended from
"Collection<E>".

=>List<E> organizes elements based on index values and which can hold
duplicate elements.
=>The following are some important methods of List<E>:

public abstract int size();
public abstract boolean isEmpty();
public abstract boolean contains(java.lang.Object);

public abstract boolean remove(java.lang.Object);

thi
i

public abstract boolean add(E);

public abstract boolean containsAll(java.util.Collection<?>);

ipa

public abstract boolean addAll(java.util.Collection<? extends E>);

Ma

public abstract boolean addAll(int, java.util.Collection<? extends E>);
public abstract boolean removeAll(java.util.Collection<?>);
public abstract boolean retainAll(java.util.Collection<?>);

Ve
nk
ate
sh

public default void replaceAll(java.util.function.UnaryOperator<E>);
public default void sort(java.util.Comparator<? super E>);
public abstract void clear();

public abstract E get(int);

public abstract E set(int, E);

public abstract void add(int, E);
public abstract E remove(int);

public abstract int indexOf(java.lang.Object);
public abstract int lastIndexOf(java.lang.Object);
public abstract java.util.List<E> subList(int, int);

public static <E> java.util.List<E> of();

public abstract java.util.Iterator<E> iterator();

thi
i

public abstract java.util.ListIterator<E> listIterator();
public abstract java.util.ListIterator<E> listIterator(int);

Ma

public abstract java.lang.Object[] toArray();

ipa

public default java.util.Spliterator<E> spliterator();

public abstract <T> T[] toArray(T[]);

-------------------------------------------------------------------

Ve
nk
ate
sh

=>The following are the implementation classes of List<E>:
(a)ArrayList<E>

(b)LinkedList<E>
(c)Vector<E>

(a)ArrayList<E>:

=>ArrayList<E> organizes elements in sequence and which is NonSynchronized
class.

=>ArrayList<E> is a replacement of Arrays.
syntax:
ArrayList<Class_name> al = new ArrayList<Class_name>();

Ve
nk
ate
sh

Ma

ipa

thi
i

-------------------------------------------------------------

Dt : 24/6/2023
Ex-program:
DemoList1.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoList1 {
@SuppressWarnings("removal")
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
ArrayList<Integer> al = new
ArrayList<Integer>();
while(true) {
System.out.println("****Choice****");
System.out.println("\t1.add(E)"
+ "\n\t2.add(index,E)"
+ "\n\t3.remove(Object)"
+ "\n\t4.remove(index)"
+ "\n\t5.get(index)"
+ "\n\t6.set(index,E)"
+ "\n\t7.Sorting"
+ "\n\t8.Exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
ele:");
al.add(new Integer(s.nextInt()));
System.out.println(al.toString());
break;
case 2:
if(al.isEmpty()) {
System.out.println("List is
empty..");
}else {

System.out.println("Enter the

index:");

int i1 = s.nextInt();
if(i1>=0 && i1<al.size()) {
System.out.println("Enter

Integer(s.nextInt()));

al.add(i1, new

System.out.println(al.toString());
}else {

ipa

System.out.println("Invalid index..");
}
}

thi
i

the ele:");

Ma

empty..");

break;
case 3:
if(al.isEmpty()) {
System.out.println("List is

Ve
nk
ate
sh

}else {
System.out.println("Enter the
ele to be removed:");
Integer el = new
Integer(s.nextInt());
if(al.remove(el)) {
System.out.println("ele
removed Successfully..");
System.out.println(al.toString());
}else {
System.out.println("Ele
not found...");
}
}
break;
case 4:
if(al.isEmpty()) {

empty...");

System.out.println("List is

thi
i

}else {
System.out.println("Enter the
index to remove the element:");
int i2 = s.nextInt();
if(i2>=0 && i2<al.size()) {
al.remove(i2);
System.out.println("Ele
removed Successfully...");

Ve
nk
ate
sh

Ma

ipa

System.out.println(al.toString());
}else {
System.out.println("Invalid
index...");
}
}
break;
case 5:
if(al.isEmpty()) {
System.out.println("List is
empty..");
}else {
System.out.println("Enter the
index to get the ele:");
int i3 = s.nextInt();
if(i3>=0 && i3<al.size()){
Integer el2 = al.get(i3);
System.out.println(el2.toString());
}else {
System.out.println("Invalid
index..");
}
}
break;
case 6:
if(al.isEmpty()) {
System.out.println("List is
empty...");

int i4 = s.nextInt();
if(i4>=0 && i4<al.size()) {
System.out.println("Enter

the new-ele:");
Integer(s.nextInt());

Integer el3 = new
al.set(i4, el3);

ipa

System.out.println(al.toString());
}else {

thi
i

intex to set ele:");

}else {
System.out.println("Enter the

Ve
nk
ate
sh

Ma

System.out.println("Invalid Index...");
}
}
break;
case 7:
if(al.isEmpty()) {
System.out.println("List is
empty...");
}else {
System.out.println("****Before
Sorting****");
System.out.println(al.toString());
Collections.sort(al);//Sorting
Process
System.out.println("****After
Sorting****");
System.out.println(al.toString());
}

Stopped..");

break;
case 8:
System.out.println("Operations

Choice...");

}//end of switch
}//end of loop
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

thi
i

}

}

System.exit(0);
default:
System.out.println("Invalid

ipa

o/p:
****Choice****

2.add(index,E)
3.remove(Object)

Ve
nk
ate
sh

4.remove(index)

Ma

1.add(E)

5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:
7

List is empty...
****Choice****
1.add(E)

2.add(index,E)
3.remove(Object)
4.remove(index)
5.get(index)

thi
i

6.set(index,E)
7.Sorting
8.Exit

ipa

Enter the Choice:

Enter the ele:
10

Ve
nk
ate
sh

[10]

Ma

1

****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:

1
Enter the ele:
11
[10, 11]

thi
i

****Choice****
1.add(E)
2.add(index,E)

ipa

3.remove(Object)

5.get(index)
6.set(index,E)

Ve
nk
ate
sh

7.Sorting

Ma

4.remove(index)

8.Exit

Enter the Choice:
1

Enter the ele:
9

[10, 11, 9]

****Choice****
1.add(E)

2.add(index,E)
3.remove(Object)

4.remove(index)
5.get(index)
6.set(index,E)
7.Sorting

thi
i

8.Exit
Enter the Choice:
1

ipa

Enter the ele:

[10, 11, 9, 45]
****Choice****

Ve
nk
ate
sh

1.add(E)

Ma

45

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:
1
Enter the ele:

23
[10, 11, 9, 45, 23]
****Choice****
1.add(E)

thi
i

2.add(index,E)
3.remove(Object)
4.remove(index)

ipa

5.get(index)

7.Sorting
8.Exit

Ve
nk
ate
sh

Enter the Choice:

Ma

6.set(index,E)

1

Enter the ele:
8

[10, 11, 9, 45, 23, 8]
****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit
Enter the Choice:

thi
i

1
Enter the ele:
17

ipa

[10, 11, 9, 45, 23, 8, 17]

1.add(E)
2.add(index,E)

Ve
nk
ate
sh

3.remove(Object)

Ma

****Choice****

4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:
7

****Before Sorting****
[10, 11, 9, 45, 23, 8, 17]
****After Sorting****

[8, 9, 10, 11, 17, 23, 45]
****Choice****
1.add(E)
2.add(index,E)

thi
i

3.remove(Object)
4.remove(index)
5.get(index)

ipa

6.set(index,E)

8.Exit
Enter the Choice:

Ve
nk
ate
sh

8

Ma

7.Sorting

Operations Stopped..

=============================================================

faq:

wt is the diff b/w
(i)Collection<E>
(ii)Collections

=>Collection<E> is an ineterface from java.util package and which is root
of Java Collection Framework.
=>Collections is a class from java.util package and which provide some

Pre-defined methods to perform operations on List<E> objects.
Ex:
sort()

thi
i

binarySearch()

ipa

===================================================================
==

Ma

Method Signatures of sort():

public static <T extends java.lang.Comparable<? super T>>

Ve
nk
ate
sh

void sort(java.util.List<T>);
public static <T> void sort(java.util.List<T>,

java.util.Comparator<? super T>);

Method Signatures of binarySearch():

public static <T> int binarySearch(java.util.List
<? extends java.lang.Comparable<? super T>>, T);

public static <T> int binarySearch(java.util.List<? extends T>, T,
java.util.Comparator<? super T>);

===================================================================
====
Assignment:
Update above program with User defined class Objects.(Product-Objects)

Ve
nk
ate
sh

Ma

ipa

thi
i

===================================================================
=

Dt : 26/6/2023
Assignment:(Solution)
Update above program with User defined class Objects.(Product-Objects)

Product.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
@SuppressWarnings("rawtypes")
public class Product extends Object implements
Comparable
{
public String code,name;
public float price;
public int qty;
public Product(String code,String name,float price,
int qty)
{
this.code=code;
this.name=name;
this.price=price;
this.qty=qty;
}
@Override
public String toString()
{
return code+"\t"+name+"\t"+price+"\t"+qty;
}
@Override
public int compareTo(Object o)
{
Product p = (Product)o;
/*int x = code.compareTo(p.code);
if(x==0) return 0;
else if(x>0) return 1;
else return -1;*/
if(price==p.price) return 0;

}

}

else if(price>p.price) return 1;
else return -1;

DemoList2.java(MainClass)

thi
i

package p2;
import java.util.*;

public class DemoList2{

Ma

@SuppressWarnings({ "unchecked" })

ipa

import p1.Product;

public static void main(String[] args) {
Scanner s = new Scanner(System.in);

Ve
nk
ate
sh

try(s;){

try {

ArrayList<Product> al = new ArrayList<Product>();
while(true) {

System.out.println("****Choice****");
System.out.println("\t1.add(E)"
+ "\n\t2.add(index,E)"
+ "\n\t3.remove(Object)"
+ "\n\t4.remove(index)"
+ "\n\t5.get(index)"
+ "\n\t6.set(index,E)"

+ "\n\t7.Sorting"
+ "\n\t8.Exit");
System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {

thi
i

case 1:
System.out.println("****ProductDetails****:");
System.out.println("Enter the ProductCode:");

ipa

String code = s.nextLine();

Ma

System.out.println("Enter the ProductName:");
String name = s.nextLine();

System.out.println("Enter the ProductPrice:");

Ve
nk
ate
sh

float price = Float.parseFloat(s.nextLine());
System.out.println("Enter the ProductQty:");
int qty = Integer.parseInt(s.nextLine());

al.add(new Product(code,name,price,qty));
al.forEach((k)->System.out.println(k));
break;

case 2:

if(al.isEmpty()) {
System.out.println("List is empty..");
}else {

System.out.println("Enter the index:");
int i1 = Integer.parseInt(s.nextLine());
if(i1>=0 && i1<al.size()) {
System.out.println("****ProductDetails****:");

thi
i

System.out.println("Enter the ProductCode:");
String code2 = s.nextLine();

System.out.println("Enter the ProductName:");

ipa

String name2 = s.nextLine();

Ma

System.out.println("Enter the ProductPrice:");
float price2 = Float.parseFloat(s.nextLine());
System.out.println("Enter the ProductQty:");

Ve
nk
ate
sh

int qty2 = Integer.parseInt(s.nextLine());

al.add(i1, new
Product(code2,name2,price2,qty2));
al.forEach((k)->System.out.println(k));

}else {

System.out.println("Invalid index..");

}
}

break;
case 3:

if(al.isEmpty()) {
System.out.println("List is empty..");
}else {
System.out.println("Enter the prodCode to
delete Product Details::");

thi
i

String pCode = s.nextLine();

Iterator<Product> it = al.iterator();

ipa

while(it.hasNext()) {

Product p = (Product)it.next();

Ma

if(pCode.equals(p.code)) {
al.remove(p);

System.out.println("Product

Ve
nk
ate
sh

deleted Successfully...");

break;

}

}//end of loop
al.forEach((k)->System.out.println(k));

}

break;

case 4:
if(al.isEmpty()) {
System.out.println("List is empty...");

}else {
System.out.println("Enter the index to remove
the element:");
int i2 = Integer.parseInt(s.nextLine());

al.remove(i2);

thi
i

if(i2>=0 && i2<al.size()) {

System.out.println("Product deleted Successfully...");

}else {

ipa

al.forEach((k)->System.out.println(k));

}

Ve
nk
ate
sh

}

Ma

System.out.println("Invalid index...");

break;

case 5:

if(al.isEmpty()) {

System.out.println("List is empty..");

}else {

System.out.println("Enter the index to get the

ele:");

int i3 = Integer.parseInt(s.nextLine());
if(i3>=0 && i3<al.size()){
Product el2 = al.get(i3);

System.out.println(el2.toString());
}else {
System.out.println("Invalid index..");
}

case 6:
if(al.isEmpty()) {

ipa

break;

thi
i

}

}else {

Ma

System.out.println("List is empty...");

System.out.println("Enter the intex to set

Ve
nk
ate
sh

Product:");

int i4 = Integer.parseInt(s.nextLine());
if(i4>=0 && i4<al.size()) {
System.out.println("****New

ProductDetails****:");

System.out.println("Enter the ProductCode:");
String code3 = s.nextLine();
System.out.println("Enter the ProductName:");
String name3 = s.nextLine();
System.out.println("Enter the ProductPrice:");
float price3 = Float.parseFloat(s.nextLine());

System.out.println("Enter the ProductQty:");
int qty3 = Integer.parseInt(s.nextLine());
al.set(i4, new
Product(code3,name3,price3,qty3));

}else {

thi
i

al.forEach((k)->System.out.println(k));

System.out.println("Invalid Index...");

ipa

}

break;
case 7:

Ma

}

Ve
nk
ate
sh

if(al.isEmpty()) {

System.out.println("List is empty...");

}else {

System.out.println("****Before Sorting****");

al.forEach((k)->System.out.println(k));
Collections.sort(al);//Sorting Process
System.out.println("****After Sorting****");
al.forEach((k)->System.out.println(k));

}

break;
case 8:
System.out.println("Operations Stopped..");

thi
i

System.exit(0);
default:

}//end of switch

Ma

}//end of loop

ipa

System.out.println("Invalid Choice...");

}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

Ve
nk
ate
sh

}

}

o/p:

****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)
6.set(index,E)
7.Sorting

8.Exit
Enter the Choice:
1
****ProductDetails****:

thi
i

Enter the ProductCode:
A001
Enter the ProductName:

ipa

Mou

Ma

Enter the ProductPrice:
1200
Enter the ProductQty:

Ve
nk
ate
sh

12

A001 Mou 1200.0
****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

12

Enter the Choice:
1
****ProductDetails****:
Enter the ProductCode:

thi
i

A006
Enter the ProductName:
CDR

ipa

Enter the ProductPrice:

Enter the ProductQty:
10
12

A006 CDR 1000.0

10

Ve
nk
ate
sh

A001 Mou 1200.0

Ma

1000

****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:
1
****ProductDetails****:
Enter the ProductCode:

thi
i

A004
Enter the ProductName:
FDD

ipa

Enter the ProductPrice:

Enter the ProductQty:
11
12

A006 CDR 1000.0

10

A004 FDD 1100.0

11

Ve
nk
ate
sh

A001 Mou 1200.0

Ma

1100

****Choice****
1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)
6.set(index,E)
7.Sorting

8.Exit
Enter the Choice:
7

A001 Mou 1200.0

12

A006 CDR 1000.0

10

A004 FDD 1100.0

11

thi
i

****Before Sorting****

10

A004 FDD 1100.0

11

A001 Mou 1200.0

12

Ve
nk
ate
sh

****Choice****

Ma

A006 CDR 1000.0

ipa

****After Sorting****

1.add(E)

2.add(index,E)

3.remove(Object)
4.remove(index)
5.get(index)

6.set(index,E)
7.Sorting
8.Exit

Enter the Choice:
8

Operations Stopped..
==============================================================
*imp
Limitation of ArrayList<E>:

thi
i

=>when we perform add-by-index the elements are moved backward and when
we perform remove-by-index the elements are moved forward,which consumes

ipa

execution time and degrades the performance of an application.

Ma

Note:

(i)In realtime ArrayList<E> is used in the applications having less number
of add and remove operations.

Ve
nk
ate
sh

Ex:

User-Login

(ii)Limitation of ArrayList<E> can be overcomed using LinkedList<E>.

===================================================================
===
*imp

(b)LinkedList<E>:

=>LinkedList<E> organizes elements in NonSequence and which is also
NonSynchronized class.
=>In LinkedList<E> elements are available in the form of Nodes.
=>This LinkedList<E> node is divided into the following partitions:

(i)Previous Node Address
(ii)Data
(iii)Next Node Address

thi
i

Diagram:

ipa

syntax:

Ve
nk
ate
sh

Ex : DemoList3.java

Ma

LinkedList<Class_name> ob = new LinkedList<Class_name>();

o/p:

[13, 14, 15, 16, 17]

****Iterator<E>-forward***
13 14 15 16 17

****Iterator<E>-backward***
17 16 15 14 13

***ListIterator<E>-forward-backward***
Forward : 13 14 15 16 17
Backward : 17 16 15 14 13

Ve
nk
ate
sh
ipa

Ma

thi
i

Diagrams:

thi
i
ipa
Ma

Ve
nk
ate
sh

=================================================================

Dt : 27/6/2023
faq:
wt is the diff b/w
(i)iterator()

thi
i

(ii)descendingIterator()

generated pointing before the first-element.

ipa

=>If Iterator<E> object is created using iterator() method the cursor is

Ma

=>If Iterator<E> object is created using descendingIterator() method then
the cursor is generated pointing after the last-element.

=================================================================

Ve
nk
ate
sh

faq:

define ListIterator<T>?

=>ListIterator<T> is an interface from java.util package and which is used

to retrieve elements from List<E> objects in both directions
(forward and backward).

=>The following are some important methods of ListIterator<T>:
public abstract boolean hasNext();
public abstract E next();

public abstract boolean hasPrevious();
public abstract E previous();
public abstract int nextIndex();

public abstract int previousIndex();
public abstract void remove();
public abstract void set(E);
public abstract void add(E);

syntax:

Note:

Ma

ListIterator<Class_name> li = al.listIterator();

ipa

ListIterator<T> interface.

thi
i

=>we use listIterator() method to create implementation object for

=>ListIterator<E> is a ChildInterface of Iterator<E>,which means

Ve
nk
ate
sh

ListIterator<E> extends Iterator<E>

==================================================================

Assignment:

wap to read n Integer elements and display?

Condition : While displaying replace odd number to next mutiple of 10.

i/p : 11 13 16 18 19 20

o/p : 20 20 16 18 20 20
==================================================================
*imp

(c)Vector<E>:
=>Vector<E> class extends from List<E> and which organizes elements in
Sequence.
=>Vector<E> is synchronized class and Thread-safe class

thi
i

=>Vector<E> is known as Legacy Class,because having unique features
Compared to other components.

public synchronized int capacity();

Ve
nk
ate
sh

public synchronized int size();

Ma

ipa

=>The following are some important methods of Vector<E>:

public synchronized E elementAt(int);
public synchronized E firstElement();
public synchronized E lastElement();

public synchronized void setElementAt(E, int);
public synchronized void removeElementAt(int);
public synchronized void insertElementAt(E, int);
public synchronized void addElement(E);

public synchronized boolean removeElement(java.lang.Object);
public synchronized void removeAllElements();

public java.util.Enumeration<E> elements();

-------------------------------------------------------------Ex-program : DemoVector.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoVector {
@SuppressWarnings("removal")
public static void main(String[] args) {
Vector<Integer> ob = new Vector<Integer>();
System.out.println("default
capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());
for(int i=11;i<=20;i++) {
ob.addElement(new Integer(i));
}//end of loop
System.out.println("*****Vector<E>****");
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());
ob.addElement(new Integer(500));
System.out.println("*****Vector<E>****");
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());
System.out.println("****Vector<E>****");
System.out.println("FisrtElement:"+ob.firstElement());
System.out.println("LastElement:"+ob.lastElement());
ob.setElementAt(new Integer(800), 2);
System.out.println(ob.toString());
Integer el = ob.elementAt(4);
System.out.println("Ele at index 4 : "+el);
ob.removeElementAt(2);
System.out.println(ob.toString());
ob.insertElementAt(new Integer(900), 5);

Ve
nk
ate
sh

}

}

Ma

ipa

thi
i

System.out.println(ob.toString());
ob.removeElement(new Integer(14));
System.out.println(ob.toString());
System.out.println("****Enumeration<E>****");
Enumeration<Integer> e1 = ob.elements();
while(e1.hasMoreElements()) {
System.out.print(e1.nextElement()+" ");
}//end of loop
System.out.println("\n****Enumeratin<E>asIterator()***");
Enumeration<Integer> e2 = ob.elements();
Iterator<Integer> it = e2.asIterator();
it.forEachRemaining((k)->System.out.print(k+"
"));
System.out.println("\n****Vector<E>****");
ob.removeAllElements();
System.out.println(ob.toString());
System.out.println("capacity:"+ob.capacity());
System.out.println("size of Vector:"+ob.size());

o/p:

default capacity:10
size of Vector:0

*****Vector<E>****

[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
capacity:10
size of Vector:10
*****Vector<E>****

[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 500]
capacity:20
size of Vector:11
****Vector<E>****

[11, 12, 800, 14, 15, 16, 17, 18, 19, 20, 500]
Ele at index 4 : 15

Ma

[11, 12, 14, 15, 16, 17, 18, 19, 20, 500]

ipa

LastElement:500

thi
i

FisrtElement:11

[11, 12, 14, 15, 16, 900, 17, 18, 19, 20, 500]
[11, 12, 15, 16, 900, 17, 18, 19, 20, 500]

Ve
nk
ate
sh

****Enumeration<E>****

11 12 15 16 900 17 18 19 20 500

****Enumeratin<E>-asIterator()***
11 12 15 16 900 17 18 19 20 500
****Vector<E>****
[]

capacity:20

size of Vector:0

============================================================
faq:
define Enumeration<E>?

=>Enumeration is an interface from java.util package and which is used to
retrieve elements from Vector<E> objects in forward direction
=>The following are some important methods of Enumeration<E>:
public abstract boolean hasMoreElements();

public default java.util.Iterator<E> asIterator();

thi
i

public abstract E nextElement();

=>we use elements() method to create implementation object for

ipa

Enumeration<E>.

Ma

syntax:

Enumeration<Class_name> e = ob.elements();

Ve
nk
ate
sh

===================================================================

Ve
nk
ate
sh
ipa

Ma

thi
i

Dt : 28/6/2023

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:

define asIterator()?

=>asIterator() method will create implementation object for Iterator<E>,

but the Iterator<E> Object will hold reference of Enumeration<E> Object.
===================================================================
==

Note:
=>"java.util.StringTokenizer" class is the implementation of
"java.util.Enumeration<E>" interface.
===================================================================
==

thi
i

Note:

=>In realtime Enumeration<E> is used in Servlet-programming.

ipa

===================================================================
====

define Cursor statements?

Ma

*imp

=>The statements which are used to retrieve elements from Collection-Objects

Ve
nk
ate
sh

are known as Cursor Statements.

=>The following are some important Cursor Statements:
(a)Iterator<E> - used on Collection-Objects
(b)ListIterator<E> - used on List-Objects

(c)Enumeration<E> - used on Vector-Objects
(d)Spliterator<T> - used on Array-Objects and Collection-Objects

===================================================================
====
Summary:
(i)ArrayList<E> used for User-Login
(ii)LinkedList<E> used for Admin-Login

(iii)Vector<E> used for Connection-Pooling concept.
(Organizing multiple Database connections among multiple users)
===================================================================
======
*imp

thi
i

define Stack<E>?

=>Stack<E> is a child-class of Vector<E> and which organizes elements

ipa

based on the algorithm First-In-Last-Out or Last-In-First-Oout

public E push(E);
public synchronized E pop();

Ve
nk
ate
sh

public synchronized E peek();

Ma

=>The following are some important methods of Stack<E>:

public boolean empty();

public synchronized int search(java.lang.Object);

push(E) : method is used to add the element to Stack<E>
pop() : method is used to delete the element from top-of-stack
peek() : method is used to display the element from top-of-stack
empty() : method is used to check Stack<E> is empty or not
search(Object) : method is used to search the element from top-of-stack to
bottom of stack and display position of an element

Ex-program : DemoStack.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoStack {
@SuppressWarnings("removal")
public static void main(String[] args) {
Scanner s = new Scanner(System.in);
try(s;){
try {
Stack<Integer> ob = new Stack<Integer>();
while(true) {
System.out.println("****Choice*****");
System.out.println("\t1.push(E)"
+ "\n\t2.pop()"
+ "\n\t3.peek()"
+ "\n\t4.search(Object)"
+ "\n\t5.exit");
System.out.println("Enter the
Choice:");
switch(s.nextInt()) {
case 1:
System.out.println("Enter the
element:");
ob.push(new Integer(s.nextInt()));
System.out.println(ob.toString());
break;
case 2:
if(ob.empty()) {
System.out.println("Stack is
empty...");
}else {
ob.pop();
System.out.println(ob.toString());
}
break;
case 3:
if(ob.empty()) {

empty..");
"+ob.peek());

System.out.println("Stack is
}else {
System.out.println("peek ele :

Ve
nk
ate
sh

Ma

ipa

thi
i

System.out.println(ob.toString());
}
break;
case 4:
if(ob.empty()) {
System.out.println("Stack is
empty...");
}else {
System.out.println("Enter the
ele to be searched:");
Integer ele = new
Integer(s.nextInt());
int pos = ob.search(ele);
if(pos>0) {
System.out.println("Ele
found at position:"+pos);
}else {
System.out.println("Ele
not found...");
}
}
break;
case 5:
System.out.println("Stack
operations Stopped..");
System.exit(0);
default:
System.out.println("Invalid
Choice...");
}//end of switch
}//end of loop
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}

}
o/p:
****Choice*****
1.push(E)

thi
i

2.pop()
3.peek()

ipa

4.search(Object)

Enter the Choice:
4

Ve
nk
ate
sh

Stack is empty...

Ma

5.exit

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
1

Enter the element:
22

[22]
****Choice*****
1.push(E)
2.pop()

thi
i

3.peek()
4.search(Object)
5.exit

ipa

Enter the Choice:

Enter the element:
21

Ve
nk
ate
sh

[22, 21]

Ma

1

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
1

Enter the element:
30

[22, 21, 30]
****Choice*****
1.push(E)
2.pop()

thi
i

3.peek()
4.search(Object)
5.exit

ipa

Enter the Choice:

Enter the element:
42

Ve
nk
ate
sh

[22, 21, 30, 42]

Ma

1

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
1

Enter the element:
67

[22, 21, 30, 42, 67]
****Choice*****
1.push(E)
2.pop()

thi
i

3.peek()
4.search(Object)
5.exit

ipa

Enter the Choice:

Enter the element:
56

Ve
nk
ate
sh

[22, 21, 30, 42, 67, 56]

Ma

1

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
1

Enter the element:
57

[22, 21, 30, 42, 67, 56, 57]
****Choice*****
1.push(E)
2.pop()

thi
i

3.peek()
4.search(Object)
5.exit

ipa

Enter the Choice:

Enter the element:
78

Ve
nk
ate
sh

[22, 21, 30, 42, 67, 56, 57, 78]

Ma

1

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
4

Enter the ele to be searched:
21

Ele found at position:7
****Choice*****
1.push(E)
2.pop()

thi
i

3.peek()
4.search(Object)
5.exit

ipa

Enter the Choice:

Enter the ele to be searched:
100

Ve
nk
ate
sh

Ele not found...

Ma

4

****Choice*****
1.push(E)
2.pop()

3.peek()

4.search(Object)
5.exit

Enter the Choice:
5

Stack operations Stopped..
==============================================================

Ve
nk
ate
sh
ipa

Ma

thi
i

Dt : 29/6/2023
3.Queue<E>:
=>Queue<E> is an interface from from java.util package and extends from
"Collection<E>".

thi
i

=>Queue<E> organizes elements based on the algorithm First-In-First-Out
or Last-In-Last-Out

Ve
nk
ate
sh

Ma

ipa

Diagram:

=>The following are some important methods of Queue<E>:
public abstract boolean add(E);
public abstract boolean offer(E);

public abstract E remove();
public abstract E poll();
public abstract E element();
public abstract E peek();

thi
i

=>PriorityQueue<E> is an implementation of Queue<E> and which organizes

ipa

elements based on elements-priority

Ma

add(E) : method is used to add element to Queue-Object
offer(E) : method is used to add element to Queue-Object

Ve
nk
ate
sh

(This method internally activates algorithm)

remove() : method is used to remove the element from FrontEnd
poll() : method is also used remove the element from FrontEnd
(This method internally activates algorithm)

peek() : method will display the element from FrontEnd
element() : method also display the element from FrontEnd
(This method internally activates algorithm)

program : DemoQueue1.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoQueue1 {
@SuppressWarnings("removal")
public static void main(String[] args) {
PriorityQueue<Integer> pq =
new PriorityQueue<Integer>();
for(int i=1;i<=5;i++)
{
pq.add(new Integer(i));
}//end of loop
System.out.println(pq.toString());
pq.offer(new Integer(600));
System.out.println(pq.toString());
pq.remove();
System.out.println(pq.toString());
pq.poll();
System.out.println(pq.toString());
System.out.println("peek : "+pq.peek());
System.out.println("element : "+pq.element());
}
}
o/p:

[1, 2, 3, 4, 5]

[1, 2, 3, 4, 5, 600]
[2, 4, 3, 600, 5]
[3, 4, 5, 600]
peek : 3
element : 3

==============================================================

Note:
=>In realtime Stack<E> and Queue<E> are used in Algorithmic designs part
of Product-based development.
==============================================================

thi
i

faq:
define Deque<E>?

=>Deque<E> is an extention of Queue<E> and which organizes elements on

Ve
nk
ate
sh

Diagram:

Ma

ipa

both ends,and which is also known as Double-ended-queue

=>The following are some important methods of Deque<E>:

public abstract void addFirst(E);
public abstract void addLast(E);
public abstract boolean offerFirst(E);
public abstract boolean offerLast(E);

thi
i

public abstract E removeFirst();
public abstract E removeLast();
public abstract E pollFirst();

ipa

public abstract E pollLast();

public abstract E getLast();
public abstract E peekFirst();

Ve
nk
ate
sh

public abstract E peekLast();

Ma

public abstract E getFirst();

public abstract boolean removeFirstOccurrence(java.lang.Object);
public abstract boolean removeLastOccurrence(java.lang.Object);

public abstract java.util.Iterator<E> iterator();
public abstract java.util.Iterator<E> descendingIterator();

----------------------------------------------------------------=>The following are the implementation classes of Deque<E>
(a)ArrayDeque<E> - Organizes elements in sequence
(b)LinkedList<E> - Organiges elements in NonSequence

----------------------------------------------------------------Ex-program: DemoQueue2.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p2;
import java.util.*;
public class DemoQueue2 {
@SuppressWarnings("removal")
public static void main(String[] args) {
ArrayDeque<Integer> ad = new
ArrayDeque<Integer>();
for(int i=1;i<=5;i++)
{
ad.add(new Integer(i));
}//end of loop
System.out.println(ad.toString());
ad.addFirst(new Integer(200));
ad.addLast(new Integer(400));
System.out.println(ad.toString());
ad.removeFirst();
ad.removeLast();
System.out.println(ad.toString());
ad.offerFirst(new Integer(4));
ad.offerLast(new Integer(2));
System.out.println(ad.toString());
ad.removeFirstOccurrence(new Integer(4));
System.out.println(ad.toString());
ad.removeLastOccurrence(new Integer(2));
System.out.println(ad.toString());
}

}

o/p:

[1, 2, 3, 4, 5]
[200, 1, 2, 3, 4, 5, 400]
[1, 2, 3, 4, 5]

[4, 1, 2, 3, 4, 5, 2]
[1, 2, 3, 4, 5, 2]
[1, 2, 3, 4, 5]

Ve
nk
ate
sh

Ma

ipa

thi
i

========================================================

Dt : 30/6/2023
faq:
define Iterable<E>?
=>Iterable<E> is an interface from java.lang package and which is

thi
i

Parant-Interface of Collection<E>
=>This Iterable<E> will provide the following methods to support
iterations on Collection<E> Objects:

ipa

(a)iterator() - used to create implementation of Iterator<E> interface

interface

Ma

(b)spliterator() - used to create implementation of Spliterator<T>

(c)forEach() - forEach() introduced by Java8 version and which is

Ve
nk
ate
sh

used to retrieve elements from Collection<E> objects
directly.

=>The following are the method signatures:
public abstract java.util.Iterator<T> iterator();
public default java.util.Spliterator<T> spliterator();
public default void forEach(java.util.function.Consumer<? super T>);

===============================================================
Limitation of Collection<E>:

=>Collection<E> cannot differentiate Primary-key and NonPrimary-key-values
while holding Database table data

Note:
=>Collection<E> can be Overcomed using Map<K,V>
==============================================================
*imp

thi
i

Map<K,V> in Java:
=>Map<K,V> is an interface from java.util package and which organizes
elements in the form of Key-value pairs

ipa

K - Key

Ma

V - Value

=>The following are some important methods of Map<K,V>:

Ve
nk
ate
sh

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean containsKey(java.lang.Object);
public abstract boolean containsValue(java.lang.Object);
public abstract V get(java.lang.Object);
public abstract V put(K, V);

public abstract V remove(java.lang.Object);
public abstract void putAll(java.util.Map<? extends K, ? extends V>);
public abstract void clear();
public abstract java.util.Set<K> keySet();
public abstract java.util.Collection<V> values();

public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
public default void forEach(java.util.function.BiConsumer<? super K,
? super V>);
public static <K, V> java.util.Map<K, V> of();

thi
i

----------------------------------------------------------=>The following are the implementation classes of Map<K,V>:
(a)HashMap<K,V>

ipa

(b)LinkedHashMap<K,V>

(d)Hashtable<K,V>

Ve
nk
ate
sh

(a)HashMap<K,V>:

Ma

(c)TreeMap<K,V>

=>HashMap<K,V> organizes elements without any order and which is
NonSynchronized class.

(b)LinkedHashMap<K,V>:

=>LinkedHashMap<K,V> organizes elements in insertion order and which is
also NonSynchronized class.

(c)TreeMap<K,V>:
=>TreeMap<K,V> organizes elements automatically in ascending order based
on

primary-key and which is also NonSynchronized class.

(d)Hashtable<K,V>:
=>Hashtable<K,V> organized elements without any order,bute it is

----------------------------------------------------------------Dt : 1/7/2023

ipa

Ex-application:

NAME

DESG

Ma

Consider the following Table data:

ID

thi
i

Synchronized and Thread-safe class.

BSAL

TOTSAL

Ve
nk
ate
sh

---------- --------------- ---------- ---------- ---------A121

Raj

A003

Ram

A122

Ram

SE

12000

30720

TE

1400

3584

SE

12000

30720

Step-1 : Construct one user defined class with variables equal to
NonPrimary-key-values

EmpValues.java

Ma

ipa

thi
i

package p1;
public class EmpValues {
public String name,desg;
public int bSal;
public float totSal;
public EmpValues(String name,String desg,int bSal,
float totSal) {
this.name=name;
this.desg=desg;
this.bSal=bSal;
this.totSal=totSal;
}
public String toString() {
return name+"\t"+desg+"\t"+bSal+"\t"+totSal;
}
}

Ve
nk
ate
sh

step-2 : Construct Map<K,V> to hold elements in the form of Key-value pairs
K - String(id)

V - EmpValues(name,desg,bSal,totSal)

Map<String,EmpValues>

Designation.java

package p1;
public class Designation {
public boolean verify(String desg) {
return switch(desg) {
case "SE":yield true;
case "TE":yield true;
case "ME":yield true;
case "EE":yield true;
default:yield false;

}

};
}

DemoMap.java(MainClass)
package p2;

thi
i

import java.util.*;

@SuppressWarnings("serial")

{
public DemoMap(String msg)

Ve
nk
ate
sh

{

Ma

public class DemoMap extends Exception

ipa

import p1.*;

super(msg);

}

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
try(s;){

try {

Map<String,EmpValues> ob = null;
String nm=null;
while(true) {

System.out.println("----Choice----");
System.out.println("\t1.HashMap"
+ "\n\t2.LinkedHashMap"
+ "\n\t3.TreeMap"

thi
i

+ "\n\t4.Hashtable"
+ "\n\t5.exit");

System.out.println("Enter the Choice:");

ipa

switch(Integer.parseInt(s.nextLine())) {

Ma

case 1:

ob = new HashMap<String,EmpValues>();
nm="HashMap";

Ve
nk
ate
sh

break;

case 2:

ob = new LinkedHashMap<String,EmpValues>();
nm="LinkedHashMap";
break;

case 3:

ob = new TreeMap<String,EmpValues>();
nm="TreeMap";
break;

case 4:
ob = new Hashtable<String,EmpValues>();

nm="Hashtable";
break;
case 5:
System.out.println("Operations Stopped on Map...");

thi
i

System.exit(0);
default:

System.out.println("Invalid Choice..");

ipa

continue;

Ma

}//end of switch

System.out.println("Perform operations on "+nm);
xyz:

Ve
nk
ate
sh

while(true) {

System.out.println("====Choice====");
System.out.println("\t1.put(K,V)"
+ "\n\t2.remove(Object)"
+ "\n\t3.get(Object)"
+ "\n\t4.keySet()"
+ "\n\t5.values()"
+ "\n\t6.Display-using-entrySet()"
+ "\n\t7.exit");
System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {

case 1:
while(true) {
try {

System.out.println("****EmployeeDetails****");

thi
i

System.out.println("Enter the
EmpId:");

ipa

String id = s.nextLine();

System.out.println("Enter the

Ma

EmpName:");

String name = s.nextLine();
System.out.println("Enter the

Ve
nk
ate
sh

EmpDesg:");

String desg =

s.nextLine().toUpperCase();

boolean z = new

Designation().verify(desg);

if(!z)//Exception
{
throw new DemoMap("Invalid

Designation...");

}
System.out.println("Enter the
bSal:");

int bSal =
Integer.parseInt(s.nextLine());
if(bSal<12000)//Exception
{
throw new

thi
i

DemoMap("InValid bsal...");
}

float totSal =

ipa

bSal+(0.93F*bSal)+(0.61F*bSal);

Ma

ob.put(new String(id),
new

EmpValues(name,desg,bSal,totSal));

ob.forEach((k,v)-

Ve
nk
ate
sh

>System.out.println(k+"\t"+v));

break;//stop the loop

}catch(Exception e) {
System.out.println(e.getMessage());
}

}//end of loop

break;
case 2:
if(ob.isEmpty()) {

System.out.println("Map is empty...");
}else {
System.out.println("Enter the EmpId to
remove details:");
String eId2 = s.nextLine();

thi
i

if(ob.containsKey(eId2)) {
ob.remove(eId2);

ipa

System.out.println("Emp-details
removed...");

Ma

ob.forEach((k,v)>System.out.println(k+"\t"+v));

}else {

Ve
nk
ate
sh

System.out.println("Invalid

empId...");

}

}

break;

case 3:

if(ob.isEmpty()) {
System.out.println("Map is empty...");

}else {
System.out.println("Enter the empId:");
String eId3 = s.nextLine();

if(ob.containsKey(eId3)) {
EmpValues ev = ob.get(eId3);
System.out.println(ev);
}else {
System.out.println("Invalid

thi
i

empId...");

}

case 4:

Ma

break;

ipa

}

if(ob.isEmpty()) {

Ve
nk
ate
sh

System.out.println("Map is empty...");

}else {

Set<String> st = ob.keySet();
System.out.println("****Key-Set****");
st.forEach((k)->System.out.println(k));

}

break;

case 5:

if(ob.isEmpty()) {
System.out.println("Map is empty...");
}else {

Collection<EmpValues> c = ob.values();
System.out.println("****Values****");
c.forEach((v)->System.out.println(v));
}

case 6:
if(ob.isEmpty()) {

thi
i

break;

ipa

System.out.println("Map is empty...");

Ma

}else {

System.out.println("****entrySet()****");

for(Map.Entry<String, EmpValues> en :

Ve
nk
ate
sh

ob.entrySet())
{

System.out.println(en.getKey()+"\t"+en.getValue());
}//end of loop
}

break;

case 7:
System.out.println("Operations Stooped on
"+nm);
break xyz;

}//end of switch
}//End of InnerLoop
}//end of OuterLoop
}catch(Exception e) {e.printStackTrace();}

thi
i

}//end of try with resource
}
}

----Choice---1.HashMap

Ve
nk
ate
sh

2.LinkedHashMap

Ma

ipa

o/p:

3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
2

Perform operations on LinkedHashMap
====Choice====

1.put(K,V)
2.remove(Object)
3.get(Object)

4.keySet()
5.values()
6.Display-using-entrySet()
7.exit

thi
i

Enter the Choice:
1
****EmployeeDetails****

ipa

Enter the EmpId:

Enter the EmpName:
Raj

Ve
nk
ate
sh

Enter the EmpDesg:

Ma

A001

SE

Enter the bSal:
1200

InValid bsal...

****EmployeeDetails****
Enter the EmpId:
1

Enter the EmpName:
Raj
Enter the EmpDesg:

SE
Enter the bSal:
12000
1

Raj

SE

1200030480.0

thi
i

====Choice====
1.put(K,V)
2.remove(Object)

ipa

3.get(Object)

5.values()
6.Display-using-entrySet()

Ve
nk
ate
sh

7.exit

Ma

4.keySet()

Enter the Choice:
1

****EmployeeDetails****
Enter the EmpId:
2

Enter the EmpName:
Ram

Enter the EmpDesg:
TE
Enter the bSal:

17000
1

Raj

SE

1200030480.0

2

Ram TE

1700043180.0

====Choice====

thi
i

1.put(K,V)
2.remove(Object)
3.get(Object)

ipa

4.keySet()

6.Display-using-entrySet()
7.exit

Ve
nk
ate
sh

Enter the Choice:

Ma

5.values()

7

Operations Stooped on LinkedHashMap
----Choice----

1.HashMap

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
3

Perform operations on TreeMap
====Choice====
1.put(K,V)
2.remove(Object)

thi
i

3.get(Object)
4.keySet()
5.values()

ipa

6.Display-using-entrySet()

Enter the Choice:
1

Ve
nk
ate
sh

****EmployeeDetails****

Ma

7.exit

Enter the EmpId:
E10

Enter the EmpName:
Raj

Enter the EmpDesg:
SE

Enter the bSal:
120000
E10

Raj

SE

====Choice====

120000

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

E5

Ma

1

Enter the EmpName:
Ram

Enter the EmpDesg:
TE

Enter the bSal:
180000
E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)

2.remove(Object)
3.get(Object)
4.keySet()
5.values()

thi
i

6.Display-using-entrySet()
7.exit
Enter the Choice:

ipa

1

Ma

****EmployeeDetails****
Enter the EmpId:
A

Ve
nk
ate
sh

Enter the EmpName:
Rah

Enter the EmpDesg:
TE

Enter the bSal:
16788
A

Rah TE

1678842641.52

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)

2.remove(Object)
3.get(Object)
4.keySet()
5.values()

thi
i

6.Display-using-entrySet()
7.exit
Enter the Choice:

ipa

1

Ma

****EmployeeDetails****
Enter the EmpId:
B34

Ve
nk
ate
sh

Enter the EmpName:
Rkk

Enter the EmpDesg:
TE

Enter the bSal:
19000
A

Rah TE

1678842641.52

B34 Rkk

TE

1900048260.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Ma

1
****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

C23

Enter the EmpName:
Ra

Enter the EmpDesg:
TE

Enter the bSal:
17000
A

Rah TE

1678842641.52

B34 Rkk

TE

1900048260.0

C23

Ra

TE

1700043180.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)
2.remove(Object)

thi
i

3.get(Object)
4.keySet()
5.values()

ipa

6.Display-using-entrySet()

Enter the Choice:
1

Ve
nk
ate
sh

****EmployeeDetails****

Ma

7.exit

Enter the EmpId:
D24

Enter the EmpName:
Rt

Enter the EmpDesg:
SE

Enter the bSal:
16000
A

Rah TE

B34 Rkk

TE

1678842641.52
1900048260.0

C23

Ra

TE

1700043180.0

D24 Rt

SE

1600040640.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

thi
i

====Choice====
1.put(K,V)
2.remove(Object)

ipa

3.get(Object)

5.values()
6.Display-using-entrySet()

Ve
nk
ate
sh

7.exit

Ma

4.keySet()

Enter the Choice:
7

Operations Stooped on TreeMap
----Choice----

1.HashMap

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit
Enter the Choice:

4
Perform operations on Hashtable
====Choice====
1.put(K,V)

thi
i

2.remove(Object)
3.get(Object)
4.keySet()

ipa

5.values()

Ma

6.Display-using-entrySet()
7.exit
Enter the Choice:

Ve
nk
ate
sh

1

****EmployeeDetails****
Enter the EmpId:
E12

Enter the EmpName:
Raj

Enter the EmpDesg:
SE

Enter the bSal:
120000
E12

Raj

SE

120000

304800.0

====Choice====
1.put(K,V)
2.remove(Object)
3.get(Object)

thi
i

4.keySet()
5.values()
6.Display-using-entrySet()

ipa

7.exit

Ma

Enter the Choice:
1
****EmployeeDetails****

Ve
nk
ate
sh

Enter the EmpId:
A11

Enter the EmpName:
Ram

Enter the EmpDesg:
SE

Enter the bSal:
19000

A11 Ram SE

1900048260.0

E12

120000

Raj

SE

====Choice====

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Ma

1
****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

Z23

Enter the EmpName:
Ram

Enter the EmpDesg:
SE

Enter the bSal:
18000

A11 Ram SE

1900048260.0

Z23

Ram SE

1800045720.0

E12

Raj

120000

SE

====Choice====

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Operations Stooped on Hashtable
----Choice----

Ve
nk
ate
sh

1.HashMap

Ma

7

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
5

Operations Stopped on Map...

=====================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 30/6/2023
faq:
define Iterable<E>?
=>Iterable<E> is an interface from java.lang package and which is

thi
i

Parant-Interface of Collection<E>
=>This Iterable<E> will provide the following methods to support
iterations on Collection<E> Objects:

ipa

(a)iterator() - used to create implementation of Iterator<E> interface

interface

Ma

(b)spliterator() - used to create implementation of Spliterator<T>

(c)forEach() - forEach() introduced by Java8 version and which is

Ve
nk
ate
sh

used to retrieve elements from Collection<E> objects
directly.

=>The following are the method signatures:
public abstract java.util.Iterator<T> iterator();
public default java.util.Spliterator<T> spliterator();
public default void forEach(java.util.function.Consumer<? super T>);

===============================================================
Limitation of Collection<E>:

=>Collection<E> cannot differentiate Primary-key and NonPrimary-key-values
while holding Database table data

Note:
=>Collection<E> can be Overcomed using Map<K,V>
==============================================================
*imp

thi
i

Map<K,V> in Java:
=>Map<K,V> is an interface from java.util package and which organizes
elements in the form of Key-value pairs

ipa

K - Key

Ma

V - Value

=>The following are some important methods of Map<K,V>:

Ve
nk
ate
sh

public abstract int size();

public abstract boolean isEmpty();

public abstract boolean containsKey(java.lang.Object);
public abstract boolean containsValue(java.lang.Object);
public abstract V get(java.lang.Object);
public abstract V put(K, V);

public abstract V remove(java.lang.Object);
public abstract void putAll(java.util.Map<? extends K, ? extends V>);
public abstract void clear();
public abstract java.util.Set<K> keySet();
public abstract java.util.Collection<V> values();

public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
public default void forEach(java.util.function.BiConsumer<? super K,
? super V>);
public static <K, V> java.util.Map<K, V> of();

thi
i

----------------------------------------------------------=>The following are the implementation classes of Map<K,V>:
(a)HashMap<K,V>

ipa

(b)LinkedHashMap<K,V>

(d)Hashtable<K,V>

Ve
nk
ate
sh

(a)HashMap<K,V>:

Ma

(c)TreeMap<K,V>

=>HashMap<K,V> organizes elements without any order and which is
NonSynchronized class.

(b)LinkedHashMap<K,V>:

=>LinkedHashMap<K,V> organizes elements in insertion order and which is
also NonSynchronized class.

(c)TreeMap<K,V>:
=>TreeMap<K,V> organizes elements automatically in ascending order based
on

primary-key and which is also NonSynchronized class.

(d)Hashtable<K,V>:
=>Hashtable<K,V> organized elements without any order,bute it is

----------------------------------------------------------------Dt : 1/7/2023

ipa

Ex-application:

NAME

DESG

Ma

Consider the following Table data:

ID

thi
i

Synchronized and Thread-safe class.

BSAL

TOTSAL

Ve
nk
ate
sh

---------- --------------- ---------- ---------- ---------A121

Raj

A003

Ram

A122

Ram

SE

12000

30720

TE

1400

3584

SE

12000

30720

Step-1 : Construct one user defined class with variables equal to
NonPrimary-key-values

EmpValues.java

Ma

ipa

thi
i

package p1;
public class EmpValues {
public String name,desg;
public int bSal;
public float totSal;
public EmpValues(String name,String desg,int bSal,
float totSal) {
this.name=name;
this.desg=desg;
this.bSal=bSal;
this.totSal=totSal;
}
public String toString() {
return name+"\t"+desg+"\t"+bSal+"\t"+totSal;
}
}

Ve
nk
ate
sh

step-2 : Construct Map<K,V> to hold elements in the form of Key-value pairs
K - String(id)

V - EmpValues(name,desg,bSal,totSal)

Map<String,EmpValues>

Designation.java

package p1;
public class Designation {
public boolean verify(String desg) {
return switch(desg) {
case "SE":yield true;
case "TE":yield true;
case "ME":yield true;
case "EE":yield true;
default:yield false;

}

};
}

DemoMap.java(MainClass)
package p2;

thi
i

import java.util.*;

@SuppressWarnings("serial")

{
public DemoMap(String msg)

Ve
nk
ate
sh

{

Ma

public class DemoMap extends Exception

ipa

import p1.*;

super(msg);

}

public static void main(String[] args)
{

Scanner s = new Scanner(System.in);
try(s;){

try {

Map<String,EmpValues> ob = null;
String nm=null;
while(true) {

System.out.println("----Choice----");
System.out.println("\t1.HashMap"
+ "\n\t2.LinkedHashMap"
+ "\n\t3.TreeMap"

thi
i

+ "\n\t4.Hashtable"
+ "\n\t5.exit");

System.out.println("Enter the Choice:");

ipa

switch(Integer.parseInt(s.nextLine())) {

Ma

case 1:

ob = new HashMap<String,EmpValues>();
nm="HashMap";

Ve
nk
ate
sh

break;

case 2:

ob = new LinkedHashMap<String,EmpValues>();
nm="LinkedHashMap";
break;

case 3:

ob = new TreeMap<String,EmpValues>();
nm="TreeMap";
break;

case 4:
ob = new Hashtable<String,EmpValues>();

nm="Hashtable";
break;
case 5:
System.out.println("Operations Stopped on Map...");

thi
i

System.exit(0);
default:

System.out.println("Invalid Choice..");

ipa

continue;

Ma

}//end of switch

System.out.println("Perform operations on "+nm);
xyz:

Ve
nk
ate
sh

while(true) {

System.out.println("====Choice====");
System.out.println("\t1.put(K,V)"
+ "\n\t2.remove(Object)"
+ "\n\t3.get(Object)"
+ "\n\t4.keySet()"
+ "\n\t5.values()"
+ "\n\t6.Display-using-entrySet()"
+ "\n\t7.exit");
System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {

case 1:
while(true) {
try {

System.out.println("****EmployeeDetails****");

thi
i

System.out.println("Enter the
EmpId:");

ipa

String id = s.nextLine();

System.out.println("Enter the

Ma

EmpName:");

String name = s.nextLine();
System.out.println("Enter the

Ve
nk
ate
sh

EmpDesg:");

String desg =

s.nextLine().toUpperCase();

boolean z = new

Designation().verify(desg);

if(!z)//Exception
{
throw new DemoMap("Invalid

Designation...");

}
System.out.println("Enter the
bSal:");

int bSal =
Integer.parseInt(s.nextLine());
if(bSal<12000)//Exception
{
throw new

thi
i

DemoMap("InValid bsal...");
}

float totSal =

ipa

bSal+(0.93F*bSal)+(0.61F*bSal);

Ma

ob.put(new String(id),
new

EmpValues(name,desg,bSal,totSal));

ob.forEach((k,v)-

Ve
nk
ate
sh

>System.out.println(k+"\t"+v));

break;//stop the loop

}catch(Exception e) {
System.out.println(e.getMessage());
}

}//end of loop

break;
case 2:
if(ob.isEmpty()) {

System.out.println("Map is empty...");
}else {
System.out.println("Enter the EmpId to
remove details:");
String eId2 = s.nextLine();

thi
i

if(ob.containsKey(eId2)) {
ob.remove(eId2);

ipa

System.out.println("Emp-details
removed...");

Ma

ob.forEach((k,v)>System.out.println(k+"\t"+v));

}else {

Ve
nk
ate
sh

System.out.println("Invalid

empId...");

}

}

break;

case 3:

if(ob.isEmpty()) {
System.out.println("Map is empty...");

}else {
System.out.println("Enter the empId:");
String eId3 = s.nextLine();

if(ob.containsKey(eId3)) {
EmpValues ev = ob.get(eId3);
System.out.println(ev);
}else {
System.out.println("Invalid

thi
i

empId...");

}

case 4:

Ma

break;

ipa

}

if(ob.isEmpty()) {

Ve
nk
ate
sh

System.out.println("Map is empty...");

}else {

Set<String> st = ob.keySet();
System.out.println("****Key-Set****");
st.forEach((k)->System.out.println(k));

}

break;

case 5:

if(ob.isEmpty()) {
System.out.println("Map is empty...");
}else {

Collection<EmpValues> c = ob.values();
System.out.println("****Values****");
c.forEach((v)->System.out.println(v));
}

case 6:
if(ob.isEmpty()) {

thi
i

break;

ipa

System.out.println("Map is empty...");

Ma

}else {

System.out.println("****entrySet()****");

for(Map.Entry<String, EmpValues> en :

Ve
nk
ate
sh

ob.entrySet())
{

System.out.println(en.getKey()+"\t"+en.getValue());
}//end of loop
}

break;

case 7:
System.out.println("Operations Stooped on
"+nm);
break xyz;

}//end of switch
}//End of InnerLoop
}//end of OuterLoop
}catch(Exception e) {e.printStackTrace();}

thi
i

}//end of try with resource
}
}

----Choice---1.HashMap

Ve
nk
ate
sh

2.LinkedHashMap

Ma

ipa

o/p:

3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
2

Perform operations on LinkedHashMap
====Choice====

1.put(K,V)
2.remove(Object)
3.get(Object)

4.keySet()
5.values()
6.Display-using-entrySet()
7.exit

thi
i

Enter the Choice:
1
****EmployeeDetails****

ipa

Enter the EmpId:

Enter the EmpName:
Raj

Ve
nk
ate
sh

Enter the EmpDesg:

Ma

A001

SE

Enter the bSal:
1200

InValid bsal...

****EmployeeDetails****
Enter the EmpId:
1

Enter the EmpName:
Raj
Enter the EmpDesg:

SE
Enter the bSal:
12000
1

Raj

SE

1200030480.0

thi
i

====Choice====
1.put(K,V)
2.remove(Object)

ipa

3.get(Object)

5.values()
6.Display-using-entrySet()

Ve
nk
ate
sh

7.exit

Ma

4.keySet()

Enter the Choice:
1

****EmployeeDetails****
Enter the EmpId:
2

Enter the EmpName:
Ram

Enter the EmpDesg:
TE
Enter the bSal:

17000
1

Raj

SE

1200030480.0

2

Ram TE

1700043180.0

====Choice====

thi
i

1.put(K,V)
2.remove(Object)
3.get(Object)

ipa

4.keySet()

6.Display-using-entrySet()
7.exit

Ve
nk
ate
sh

Enter the Choice:

Ma

5.values()

7

Operations Stooped on LinkedHashMap
----Choice----

1.HashMap

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
3

Perform operations on TreeMap
====Choice====
1.put(K,V)
2.remove(Object)

thi
i

3.get(Object)
4.keySet()
5.values()

ipa

6.Display-using-entrySet()

Enter the Choice:
1

Ve
nk
ate
sh

****EmployeeDetails****

Ma

7.exit

Enter the EmpId:
E10

Enter the EmpName:
Raj

Enter the EmpDesg:
SE

Enter the bSal:
120000
E10

Raj

SE

====Choice====

120000

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

E5

Ma

1

Enter the EmpName:
Ram

Enter the EmpDesg:
TE

Enter the bSal:
180000
E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)

2.remove(Object)
3.get(Object)
4.keySet()
5.values()

thi
i

6.Display-using-entrySet()
7.exit
Enter the Choice:

ipa

1

Ma

****EmployeeDetails****
Enter the EmpId:
A

Ve
nk
ate
sh

Enter the EmpName:
Rah

Enter the EmpDesg:
TE

Enter the bSal:
16788
A

Rah TE

1678842641.52

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)

2.remove(Object)
3.get(Object)
4.keySet()
5.values()

thi
i

6.Display-using-entrySet()
7.exit
Enter the Choice:

ipa

1

Ma

****EmployeeDetails****
Enter the EmpId:
B34

Ve
nk
ate
sh

Enter the EmpName:
Rkk

Enter the EmpDesg:
TE

Enter the bSal:
19000
A

Rah TE

1678842641.52

B34 Rkk

TE

1900048260.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Ma

1
****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

C23

Enter the EmpName:
Ra

Enter the EmpDesg:
TE

Enter the bSal:
17000
A

Rah TE

1678842641.52

B34 Rkk

TE

1900048260.0

C23

Ra

TE

1700043180.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

====Choice====
1.put(K,V)
2.remove(Object)

thi
i

3.get(Object)
4.keySet()
5.values()

ipa

6.Display-using-entrySet()

Enter the Choice:
1

Ve
nk
ate
sh

****EmployeeDetails****

Ma

7.exit

Enter the EmpId:
D24

Enter the EmpName:
Rt

Enter the EmpDesg:
SE

Enter the bSal:
16000
A

Rah TE

B34 Rkk

TE

1678842641.52
1900048260.0

C23

Ra

TE

1700043180.0

D24 Rt

SE

1600040640.0

E10

Raj

SE

120000

304800.0

E5

Ram TE

180000

457200.0

thi
i

====Choice====
1.put(K,V)
2.remove(Object)

ipa

3.get(Object)

5.values()
6.Display-using-entrySet()

Ve
nk
ate
sh

7.exit

Ma

4.keySet()

Enter the Choice:
7

Operations Stooped on TreeMap
----Choice----

1.HashMap

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit
Enter the Choice:

4
Perform operations on Hashtable
====Choice====
1.put(K,V)

thi
i

2.remove(Object)
3.get(Object)
4.keySet()

ipa

5.values()

Ma

6.Display-using-entrySet()
7.exit
Enter the Choice:

Ve
nk
ate
sh

1

****EmployeeDetails****
Enter the EmpId:
E12

Enter the EmpName:
Raj

Enter the EmpDesg:
SE

Enter the bSal:
120000
E12

Raj

SE

120000

304800.0

====Choice====
1.put(K,V)
2.remove(Object)
3.get(Object)

thi
i

4.keySet()
5.values()
6.Display-using-entrySet()

ipa

7.exit

Ma

Enter the Choice:
1
****EmployeeDetails****

Ve
nk
ate
sh

Enter the EmpId:
A11

Enter the EmpName:
Ram

Enter the EmpDesg:
SE

Enter the bSal:
19000

A11 Ram SE

1900048260.0

E12

120000

Raj

SE

====Choice====

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Ma

1
****EmployeeDetails****
Enter the EmpId:

Ve
nk
ate
sh

Z23

Enter the EmpName:
Ram

Enter the EmpDesg:
SE

Enter the bSal:
18000

A11 Ram SE

1900048260.0

Z23

Ram SE

1800045720.0

E12

Raj

120000

SE

====Choice====

304800.0

1.put(K,V)
2.remove(Object)
3.get(Object)
4.keySet()

thi
i

5.values()
6.Display-using-entrySet()
7.exit

ipa

Enter the Choice:

Operations Stooped on Hashtable
----Choice----

Ve
nk
ate
sh

1.HashMap

Ma

7

2.LinkedHashMap
3.TreeMap

4.Hashtable
5.exit

Enter the Choice:
5

Operations Stopped on Map...

=====================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

Dt : 3/7/2023

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:(Representating Map<K,V>)

=======================================================
faq:

define forEach() method?

=>forEach() method introduced by Java8 version and which is used to
retrieve elements from Collecition<E> and Map<K,V> objects directly.

structure of forEach() on Collection<E>:
public default void forEach(java.util.function.Consumer<? super T>);

structure of forEach() on Map<K,V>:

thi
i

public default void forEach(java.util.function.BiConsumer<? super K,
? super V>);

ipa

faq:

Ma

define Consumer<T>?

=>Consumer<T> is a functional interface from java.util.function package
introduced by Java8 version and which provide abstract method-accept(T) to

Ve
nk
ate
sh

hold LambdaExpression passed as parameter to forEach() method on
Collection<E>

structure of Consumer<T>:

public interface java.util.function.Consumer<T>
{

public abstract void accept(T);
..

}

Ex:
ob.forEach((T)->
{
//statements

--------------------------------------------------------------faq:

ipa

define BiConsumer<T,U>?

thi
i

});

Ma

=>BiConsumer<T,U> is a functional interface from java.util.function package
introduced by Java8 version and which provide abstract method-accept(T,U)

Ve
nk
ate
sh

to hold LambdaExpression passed as parameter to forEach() method on
Map<K,V>

Structure of BiConsumer<T,U>:

public interface java.util.function.BiConsumer<T, U>
{

public abstract void accept(T, U);
...

}

Ex:
ob.forEach((T,U)->

{
//Statements
});
=============================================================

thi
i

faq:
define BiPredicate<T,U>?

=>BiPredicate<T,U> is a functional interface from java.util.function

ipa

package introduced by Java8 version and which is used to perform conditional

Structure of BiPredicate<T,U>:

Ma

operation on Map<K,V> objects

Ve
nk
ate
sh

public interface java.util.function.BiPredicate<T, U>
{

public abstract boolean test(T, U);
...

}

==============================================================
Ex-Program:

DemoMap2.java
package p2;

import java.util.*;
import java.util.function.*;

import p1.*;
public class DemoMap2 {
public static void main(String[] args) {
LinkedHashMap<String,EmpValues> ob=

thi
i

new LinkedHashMap<String,EmpValues>();
ob.put(new String("A001"),

ipa

new
EmpValues("Raj","SE",12000,12000+(0.93F*12000)+(0.63F*12000)));
ob.put(new String("A005"),

ob.put(new String("A003"),

Ma

new
EmpValues("Ram","ME",9000,9000+(0.93F*9000)+(0.63F*9000)));

Ve
nk
ate
sh

new
EmpValues("Alex","TE",8000,8000+(0.93F*8000)+(0.63F*8000)));
ob.put(new String("A006"),

new
EmpValues("AAAA","SE",16000,16000+(0.93F*16000)+(0.63F*16000)));
ob.put(new String("A009"),

new
EmpValues("TRTR","TE",7000,7000+(0.93F*7000)+(0.63F*7000)));
System.out.println("====EmployeeDetails====");
ob.forEach((k,v)->System.out.println(k+"\t"+v));
BiPredicate<String,EmpValues> bp =

(k,v)->v.bSal<10000;
System.out.println("====EmployeeDetails-bSal<10000===");
ob.forEach((k,v)->
{

{
System.out.println(k+"\t"+v);

ipa

}

Ma

});
}

Ve
nk
ate
sh

}

o/p:

====EmployeeDetails====
A001 Raj

thi
i

if(bp.test(k, v))

SE

1200030720.0

A005 Ram ME

9000 23040.0

A003 Alex TE

8000 20480.0

A006 AAAA SE

1600040960.0

A009 TRTR TE

7000 17920.0

====EmployeeDetails-bSal<10000===
A005 Ram ME

9000 23040.0

A003 Alex TE

8000 20480.0

A009 TRTR TE

7000 17920.0

Ve
nk
ate
sh

Ma

ipa

thi
i

==================================================================

Dt : 4/7/2023
faq:
define sort() method in List<E>?
=>sort() method in List<E> introduced by Java8 version and which is used

thi
i

to perform sorting operation based on individual fields.

Method Signature:

Ex-Application:
BookDetails.java

Ma

ipa

public default void sort(java.util.Comparator<? super E>);

Ve
nk
ate
sh

package p1;
public class BookDetails {
public String code,name,author;
public float price;
public int qty;
public BookDetails(String code,String name,String
author,
float price,int qty) {
this.code=code;
this.name=name;
this.author=author;
this.price=price;
this.qty=qty;
}
public String toString() {
return
code+"\t"+name+"\t"+author+"\t"+price+"\t"+qty;
}
}

SortByCode.java

Ve
nk
ate
sh

SortByName.java

Ma

ipa

thi
i

package p1;
import java.util.*;
@SuppressWarnings("rawtypes")
public class SortByCode implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
int z = bd1.code.compareTo(bd2.code);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}

package p1;
import java.util.*;
@SuppressWarnings("rawtypes")
public class SortByName implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
int z = bd1.name.compareTo(bd2.name);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}
SortByAuthor.java

SortByPrice.java

Ma

ipa

thi
i

package p1;
import java.util.*;
@SuppressWarnings("rawtypes")
public class SortByAuthor implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
int z = bd1.author.compareTo(bd2.author);
if(z==0) return 0;
else if(z>0) return 1;
else return -1;
}
}

Ve
nk
ate
sh

package p1;
import java.util.*;
@SuppressWarnings("rawtypes")
public class SortByPrice implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
if(bd1.price==bd2.price) return 0;
else if(bd1.price>bd2.price) return 1;
else return -1;
}
}
SortByQty.java
package p1;
import java.util.*;

ipa

thi
i

@SuppressWarnings("rawtypes")
public class SortByQty implements Comparator
{
@Override
public int compare(Object ob1,Object ob2)
{
BookDetails bd1 = (BookDetails)ob1;
BookDetails bd2 = (BookDetails)ob2;
if(bd1.qty==bd2.qty) return 0;
else if(bd1.qty>bd2.qty) return 1;
else return -1;
}
}

package p2;
import java.util.*;

Ve
nk
ate
sh

import p1.*;

Ma

DemoList4.java(MainClass)

public class DemoList4 {

@SuppressWarnings("unchecked")

public static void main(String[] args) {

Scanner s = new Scanner(System.in);
try(s;){
try {

ArrayList<BookDetails> ob=

new ArrayList<BookDetails>();
ob.add(new BookDetails("A112","C-Lang","B-Swamy",1200,12));
ob.add(new BookDetails("A102","HBT","Abc",1100,10));

ob.add(new BookDetails("A109","AdvJava","Xyz",100,2));
ob.add(new BookDetails("A110","CoreJ","GRT",200,4));
ob.add(new BookDetails("A103","Spring","SHT",1800,9));
ob.add(new BookDetails("A111","Boot","Pqr",1500,11));

ob.forEach((k)->System.out.println(k));
while(true) {

thi
i

System.out.println("====BookDetails=====");

ipa

System.out.println("---Sorting-Choice----");

Ma

System.out.println("\t1.Sort-by-Code"
+ "\n\t2.Sort-by-name"

+ "\n\t3.Sort-by-author"

Ve
nk
ate
sh

+ "\n\t4.Sort-by-price"
+ "\n\t5.Sort-by-Qty"
+ "\n\t6.exit");

System.out.println("Enter the Choice:");
switch(Integer.parseInt(s.nextLine())) {
case 1:

ob.sort(new SortByCode());
System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));
break;
case 2:

ob.sort(new SortByName());
System.out.println("====BookDetails=====");
ob.forEach((k)->System.out.println(k));
break;

ob.sort(new SortByAuthor());

thi
i

case 3:

System.out.println("====BookDetails=====");

ipa

ob.forEach((k)->System.out.println(k));

case 4:

Ma

break;

ob.sort(new SortByPrice());

Ve
nk
ate
sh

System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));
break;

case 5:

ob.sort(new SortByQty());
System.out.println("====BookDetails=====");

ob.forEach((k)->System.out.println(k));
break;

case 6:
System.out.println("Operation Stopped..");
System.exit(0);

default:
System.out.println("Invalid Choice...");
}//end of switch
}//end of loop

thi
i

}catch(Exception e) {e.printStackTrace();}
}//end of try
}

ipa

}

====BookDetails=====

Ma

o/p:

B-Swamy

1200.0

A102 HBT Abc

1100.0

10

A109 AdvJava

Xyz

12

Ve
nk
ate
sh

A112 C-Lang

100.0 2

A110 CoreJ GRT 200.0 4
A103 Spring

SHT 1800.0

A111 Boot Pqr

1500.0

---Sorting-Choice----

1.Sort-by-Code

2.Sort-by-name

3.Sort-by-author
4.Sort-by-price
5.Sort-by-Qty

11

9

6.exit
Enter the Choice:
1
====BookDetails=====
1100.0

10

A103 Spring

SHT 1800.0

A109 AdvJava

Xyz

thi
i

A102 HBT Abc

9

100.0 2

ipa

A110 CoreJ GRT 200.0 4
1500.0

11

A112 C-Lang

B-Swamy

1200.0

---Sorting-Choice----

12

Ve
nk
ate
sh

1.Sort-by-Code

Ma

A111 Boot Pqr

2.Sort-by-name

3.Sort-by-author
4.Sort-by-price
5.Sort-by-Qty
6.exit

Enter the Choice:
6

Operation Stopped..

============================================================

define Comparator<T>?
=>Comparator<T> is an interface from java.util package and which is also
used to perform Sorting process on Collection<E> objects.

thi
i

structure of Comparator<T>:
public interface java.util.Comparator<T>
{

ipa

public abstract int compare(T, T);

}

Ma

...

Ve
nk
ate
sh

=============================================================
Ex-program : Demonstrating some methods of Set<E>

DemoSet4Methods.java

package p2;
import java.util.*;
public class DemoSet4Methods {
@SuppressWarnings("removal")
public static void main(String[] args) {
LinkedHashSet<Integer> ob1 =
new LinkedHashSet<Integer>();
ob1.add(new Integer(11));
ob1.add(new Integer(12));
ob1.add(new Integer(13));
ob1.add(new Integer(14));
System.out.println("ob1 : "+ob1.toString());

Ve
nk
ate
sh

Ma

ipa

thi
i

LinkedHashSet<Integer> ob2 =
new LinkedHashSet<Integer>();
ob2.add(new Integer(21));
ob2.add(new Integer(22));
ob2.add(new Integer(23));
ob2.add(new Integer(24));
System.out.println("ob2 : "+ob2.toString());
System.out.println("****addAll()****");
ob1.addAll(ob2);
System.out.println("ob1 : "+ob1.toString());
System.out.println("****containsAll()*****");
boolean k = ob1.containsAll(ob2);
System.out.println("ob1 contains ob2 : "+k);
System.out.println("****contains(Object)****");
boolean z = ob1.contains(new Integer(13));
System.out.println("ob1 contains 13 : "+z);
System.out.println("****removeAll()****");
ob1.removeAll(ob2);
System.out.println("ob1 : "+ob1.toString());
System.out.println("****retainAll()****");
LinkedHashSet<Integer> ob3 =
new LinkedHashSet<Integer>();
ob3.add(new Integer(1));
ob3.add(new Integer(12));
ob3.add(new Integer(13));
ob3.add(new Integer(4));
ob1.retainAll(ob3);
System.out.println("ob1 : "+ob1.toString());
System.out.println("***Immutable Set<E>
Object***");
Set<Integer> ob4 = Set.of(31,32,33,34);
System.out.println("ob4 : "+ob4.toString());
//ob4.add(new Integer(23));//Error
System.out.println("****clear()****");
ob1.clear();
ob2.clear();
System.out.println("ob1 : "+ob1.toString());
System.out.println("ob2 : "+ob2.toString());
}
}

o/p:
ob1 : [11, 12, 13, 14]
ob2 : [21, 22, 23, 24]

thi
i

****addAll()****
ob1 : [11, 12, 13, 14, 21, 22, 23, 24]
****containsAll()*****

ipa

ob1 contains ob2 : true

ob1 contains 13 : true
****removeAll()****

Ve
nk
ate
sh

ob1 : [11, 12, 13, 14]

Ma

****contains(Object)****

****retainAll()****
ob1 : [12, 13]

***Immutable Set<E> Object***
ob4 : [31, 32, 33, 34]
****clear()****
ob1 : []
ob2 : []

===================================================================
=
Ex-program:(Demonstrating some important methods from List<E>)

DemoList5.java

ipa

thi
i

package p2;
import java.util.*;
public class DemoList5 {
@SuppressWarnings("removal")
public static void main(String[] args) {
ArrayList<Integer> ob1 =
new ArrayList<Integer>();
ob1.add(new Integer(11));
ob1.add(new Integer(12));
ob1.add(new Integer(13));
ob1.add(new Integer(14));
System.out.println("ob1 : "+ob1.toString());

Ve
nk
ate
sh

Ma

ArrayList<Integer> ob2 =
new ArrayList<Integer>();
ob2.add(new Integer(21));
ob2.add(new Integer(22));
ob2.add(new Integer(23));
ob2.add(new Integer(24));
System.out.println("ob2 : "+ob2.toString());
System.out.println("***addAll(index,Collection<E>)***")
;
ob1.addAll(1, ob2);
System.out.println("ob1 : "+ob1.toString());
System.out.println("****indexOf(Object)****");
int i1 = ob1.indexOf(new Integer(13));
System.out.println("index of 13 is : "+i1);
ob1.add(new Integer(11));
System.out.println("****lastIndexOf(Object)****");
System.out.println("ob1 : "+ob1.toString());
int i2 = ob1.lastIndexOf(new Integer(11));
System.out.println("last index of 11 is : "+i2);
System.out.println("****subList(index,index)****");
List<Integer> ob3 = ob1.subList(2, 7);
System.out.println("ob3 : "+ob3.toString());
System.out.println("***listIterator(index)****");
ListIterator<Integer> li = ob1.listIterator(3);

thi
i
ipa

}

}

System.out.print("Forward : ");
while(li.hasNext()) {
System.out.print(li.next()+" ");
}
System.out.print("\nBackward : ");
while(li.hasPrevious()) {
System.out.print(li.previous()+" ");
}

o/p:

ob2 : [21, 22, 23, 24]
***addAll(index,Collection<E>)***

Ma

ob1 : [11, 12, 13, 14]

Ve
nk
ate
sh

ob1 : [11, 21, 22, 23, 24, 12, 13, 14]
****indexOf(Object)****
index of 13 is : 6

****lastIndexOf(Object)****

ob1 : [11, 21, 22, 23, 24, 12, 13, 14, 11]
last index of 11 is : 8

****subList(index,index)****
ob3 : [22, 23, 24, 12, 13]
***listIterator(index)****
Forward : 23 24 12 13 14 11

Backward : 11 14 13 12 24 23 22 21 11

Ve
nk
ate
sh

Ma

ipa

thi
i

===============================================================

Dt : 5/7/2023
faq:
define Function<T,R>?
=>Function<T,R> is an functional interface from java.util.function package

thi
i

introduced by Java8 version and which is used to perform functional operation
on Collection<E> objects.

ipa

Structure of Function<T,R>:

{
public abstract R apply(T);

Ve
nk
ate
sh

...

Ma

public interface java.util.function.Function<T, R>

}

Ex:

Function<T,R> ob = (T)->
{

//body

};

faq:
define BiFunction<T,U,R>?

=>BiFunction<T,U,R> is an functional interface from java.util.function
package introduced by Java8 version and which is used to perform functional
operation on Map<K,V> objects.

public interface java.util.function.BiFunction<T, U, R>
{

ipa

public abstract R apply(T, U);

thi
i

Structure of BiFunction<T,U,R>:

Ma

...
}

Ve
nk
ate
sh

Ex:

BiFunction<T,U,R> ob = (T,U)->
{

//body

};

----------------------------------------------------------------------Ex-program:

DemoFunction.java
package p2;
import java.util.*;

import java.util.function.*;
public class DemoFunction {
@SuppressWarnings("removal")
public static void main(String[] args) {

thi
i

ArrayList<Integer> al = new ArrayList<Integer>();
al.add(new Integer(12));
al.add(new Integer(10));

ipa

al.add(new Integer(9));

Ma

al.add(new Integer(15));
System.out.println("al : "+al.toString());

Function<Integer,Integer> ob1 = (x)->x+10;

Ve
nk
ate
sh

System.out.println("====List<E> by +10====");
al.forEach((k)->
{

System.out.print(ob1.apply(k)+" ");

});

System.out.println("\n====List<E>====");
System.out.println("al : "+al.toString());

System.out.println("\n=====List<E>-replaceAll()====");
al.replaceAll((x)->x*10);
al.forEach((k)->
{

System.out.print(k+" ");
});

System.out.println("\n-----Map<K,V>-Object----");

new LinkedHashMap<String,Float>();
ob2.put(new String("A001"), new Float(123.45F));

ipa

ob2.put(new String("A002"), new Float(113.25F));

thi
i

LinkedHashMap<String,Float> ob2 =

Ma

ob2.put(new String("A005"), new Float(133.15F));
ob2.put(new String("A006"), new Float(103.45F));
ob2.put(new String("A004"), new Float(163.25F));

Ve
nk
ate
sh

ob2.forEach((k,v)->
{

System.out.println(k+"\t"+v);

});

BiFunction<String,Float,Float> ob3 =
(x,y)->y.floatValue()+30;

System.out.println("====BiFunction<T,U,R>====");
ob2.forEach((k,v)->
{
System.out.println(k+"\t"+ob3.apply(k, v));

});
System.out.println("====replaceAll()======");
ob2.replaceAll((x,y)->y.floatValue()+50);
ob2.forEach((k,v)->

System.out.println(k+"\t"+v);
});

ipa

}

al : [12, 10, 9, 15]

Ve
nk
ate
sh

====List<E> by +10====

Ma

}
o/p:

22 20 19 25

====List<E>====

al : [12, 10, 9, 15]

=====List<E>-replaceAll()====
120 100 90 150

-----Map<K,V>-Object---A001 123.45
A002 113.25
A005 133.15

thi
i

{

A006 103.45
A004 163.25
====BiFunction<T,U,R>====
A001 153.45

thi
i

A002 143.25
A005 163.15
A006 133.45

ipa

A004 193.25

Ma

====replaceAll()======
A001 173.45
A002 163.25

Ve
nk
ate
sh

A005 183.15
A006 153.45
A004 213.25

=============================================================
Structures of replaceAll() mnethods

public default void replaceAll(java.util.function.UnaryOperator<E>);
public default void replaceAll(java.util.function.BiFunction<? super K,
? super V, ? extends V>);
============================================================
Note:

=>The following are some important pre-defined functional interfaces
introduced by Java8 version:
1.Consumer<T>
2.BiConsumer<T,U>

thi
i

3.Predicate<T>
4.BiPredicate<T,U>
5.Function<T,R>

ipa

6.BiFunction<T,U,R>

define Enum<E>?

Ma

===================================================================

=>Enum<E> is an abstract class from java.lang package and which is used

Ve
nk
ate
sh

to generate enum-objects.

=>we use the following syntax to create enum-objects:

enum Enum_name
{

//elements
//variables
//methods

}
Enum is a special data type that allows you to define a set of named values, known as enumerators or constants,
that represent a fixed number of possible values for a variable

Ex-program:
Enums are often used to represent a limited set of possible values that are relevant to a specific context in your
program.
Enum - is collection of named constant

ipa

package p1;
public enum Cars {
Figo(900),Alto(500),Dezire(700);
public int price;
private Cars(int price) {
this.price=price;
}
public int getPrice() {
return price;
}
}

import java.util.*;

Ve
nk
ate
sh

import p1.Cars;

Ma

DemoEnum.java(MainClass)
package p2;

public class DemoEnum {

public static void main(String[] args) {

Cars c[] = Cars.values();

System.out.println("===Enum-data====");
Spliterator<Cars> sp = Arrays.spliterator(c);
sp.forEachRemaining((k)->
{

System.out.println(k+" Costs "+k.getPrice()
+" Thousand Dollars");
});

thi
i

Cars.java

}
}
o/p:
===Enum-data====

thi
i

Figo Costs 900 Thousand Dollars
Alto Costs 500 Thousand Dollars

ipa

Dezire Costs 700 Thousand Dollars

Ve
nk
ate
sh

Ma

Diagram:

============================================================
Note:

=>Enum<E> is less used when compared to Classes and Interfaces.
=>Enum<E> can be used to hold defined list of elements like Week-days and
months in year
=>The Constructors which are declared in Enum<E> are automatically

thi
i

private-constructors

Ve
nk
ate
sh

Ma

ipa

==============================================================

Dt : 6/7/2023
*imp
Multi-Threading in Java:
define Application?
=>set-of-programs collected together to perform defined action

thi
Ma
ipa

define Process?

i

is known as Application.

=>According to OperatingSystem,the program under execution is a
process.

=>According to Java Language,the application under execution is a

Ve
nk
ash

process.

define Task?

=>The part-of-process is known as Task.

define Multi Tasking?

=>Executing multiple tasks simultaneously is known as Multi

Tasking.(Simultaneously means at-a-time but not parallel)
=>Multi Tasking is categorized into two types:
(a)Process based Multi-Tasking

(b)Thread based Multi-Tasking

(a)Process based Multi-Tasking:
=>Executing Multiple tasks from multiple processes is known as
Process based Multi-Tasking.

Ma
ipa

(b)Thread based Multi-Tasking:

thi

i

=>Process based Multi-Tasking is used in OperatingSystem designs.

=>Executing multiple tasks from the same application(process)
is known as Thread based Multi-Tasking.

=>Thread Based Multi-Tasking is used in application development.

Ve
nk
ash

--------------------------------------------------------Note:

=>Each program in application is a Task,which means each Servlet

Program is a task.

--------------------------------------------------------faq:

define Thread?

=>The part of task is known as Thread.
=>Thread is a LightWeight and Background process.
LightWeight - means consumes less execution time

Background process - means no separate identification
------------------------------------------------------------faq:
define Multi-threading?
=>Executing multiple threads simultaneously is known as Multi

Ve
nk
ash

Diagrams:

Ma
ipa

-------------------------------------------------------------

thi

i

Thrreading.

i
thi
Ma
ipa

============================================================

Ve
nk
ash

Dt : 7/7/2023

i
thi
Ma
ipa
Ve
nk
ash
Creating and Executing Thread:

=>we use the following process to create and execute threads:
step-1 : The user defined class must be implemented from
java.lang.Runnable interface

Structure of Runnable:

public interface java.lang.Runnable
{
public abstract void run();
}

step-2 : The user defined class must implement "run()" method
(run() method will hold the required logic)

thi

i

step-3 : Create object for User defined class

step-4 : Create object for Pre-defined class "Thread" and

Ma
ipa

while object creation pass user defined class object
reference as parameter.

(Thread-Class Object will hold the reference of User defined
Class-Object)

Ve
nk
ash

step-5 : Execute run() method using start() method

---------------------------------------------------------Ex-Application:
Register.java

package p1;
import java.util.*;
public class Register implements Runnable{
@Override
public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Reg...by Alex.."+new
Date());
try {
Thread.sleep(2000);

//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
}
Login.java

Ve
nk
ash

Ma
ipa

thi

i

package p1;
import java.util.Date;
public class Login implements Runnable{
@Override
public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Log...by Raj.."+new
Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
}
DemoThread1.java(MainClass)

package p2;
import p1.*;
public class DemoThread1 {
public static void main(String[] args) {
Register ob1 = new Register();
Login ob2 = new Login();
Thread t1 = new Thread(ob1);
Thread t2 = new Thread(ob2);
t1.start();

}

}

t2.start();

o/p:
Reg...by Alex..Fri Jul 07 20:06:00 IST 2023

Reg...by Alex..Fri Jul 07 20:06:02 IST 2023

Ma
ipa

Log...by Raj..Fri Jul 07 20:06:02 IST 2023

thi

i

Log...by Raj..Fri Jul 07 20:06:00 IST 2023

Reg...by Alex..Fri Jul 07 20:06:04 IST 2023
Log...by Raj..Fri Jul 07 20:06:04 IST 2023

Reg...by Alex..Fri Jul 07 20:06:06 IST 2023
Log...by Raj..Fri Jul 07 20:06:06 IST 2023

Ve
nk
ash

Reg...by Alex..Fri Jul 07 20:06:08 IST 2023
Log...by Raj..Fri Jul 07 20:06:08 IST 2023
---------------------------------------------

Execution flow of above program:
ClassFiles:

Register.class
Login.class

DemoThread.class(MainClass)

i
thi
Ma
ipa
Ve
nk
ash

===========================================================
*imp

Creating threads using Anonymoys InnerClasses:
=>In this model User defined classes are declared as "Anonymous

InnerClasses as implemententation classes of Runnable"

Ex:
DemoThread2.java

Ve
nk
ash

Ma
ipa

thi

i

package p2;
import java.util.Date;
public class DemoThread2 {
public static void main(String[] args) {
Runnable ob1 = new Runnable()
{
@Override
public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Reg...by
Alex.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
};
Runnable ob2 = new Runnable()
{
@Override
public void run() {
for(int i=1;i<=5;i++) {
System.out.println("Log...by
Raj.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
}
};
Thread t1 = new Thread(ob1);
Thread t2 = new Thread(ob2);
t1.start();
t2.start();

}

}

==================================================
*imp
Creating threads using LambdaExpressions:(Java8)

thi

i

=>In this model run() method is declared without name,which means

Ex:
DemoThread3.java

Ma
ipa

as LambdaExpression.

Ve
nk
ash

package p2;
import java.util.Date;
public class DemoThread3 {
public static void main(String[] args) {
Runnable ob1 = ()->
{
for(int i=1;i<=5;i++) {
System.out.println("Reg...by
Alex.."+new Date());
try {
Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)
{ie.printStackTrace();}
}
};
Runnable ob2 = ()->
{
for(int i=1;i<=5;i++) {
System.out.println("Log...by
Raj.."+new Date());
try {

{ie.printStackTrace();}
}
};

Thread.sleep(2000);
//stop execution for 2000ms
}catch(InterruptedException ie)

thi

t1.start();
t2.start();

Ma
ipa

}

}

i

Thread t1 = new Thread(ob1);
Thread t2 = new Thread(ob2);

Ve
nk
ash

=========================================================

Dt : 8/7/2023
faq:
define start() method?
=>start() is a pre-defined method from java.lang.Thread class

(i)creating separate thread-stack

thi
i

and specify the following:

loaded to separate thread-stack.

ipa

(ii)calling run() method for execution,and this run() method

thread

Ve
nk
ate
sh

faq:

Ma

(iii)Activating Thread Scheduler or Thread Manager to execute

define Thread Scheduler?

=>Thread Scheduler is a pre-defined threading algorithm used to

control thread executions based on the following algorithms:
(i)Time Slicing Algorithm

(ii)Priority based Algorithm

(i)Time Slicing Algorithm:

=>In Time Slicing Algorithm all multiple threads are executed
simultaneously based on defined TimeSlice.

(ii)Priority based Algorithm:
=>In Priority based Algorithm the threads are executed based on
thread priorities.
=========================================================

define sleep() method?

thi
i

faq:

=>sleep() is a pre-defined method from java.lang.Thread class to

ipa

stop the execution process temporarly on some time.

Thread.sleep(milliseconds);

Ma

syntax:

=========================================================

Ve
nk
ate
sh

*imp

Creating Threads using Method references:

=>In this model run() method is attached with the body from a

class,where class is not related to "Runnable" interface.

Ex:

Display1.java

package p1;
public class Display1 {
public static void dis1() {
for(int i=1;i<=5;i++) {
System.out.println("Display1...");
try {
Thread.sleep(2000);

}

}catch(Exception e) {e.printStackTrace();}
}//end of loop

}

Display2.java

Ve
nk
ate
sh

DemoThread4.java(MainClass)

Ma

ipa

thi
i

package p1;
public class Display2 {
public static void dis2() {
for(int i=1;i<=5;i++) {
System.out.println("Display2...");
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}//end of loop
}
}

package p2;
import p1.*;
public class DemoThread4 {
public static void main(String[] args) {
new Thread(Display1 :: dis1).start();
new Thread(Display2 :: dis2).start();

}

}

o/p:
Display1...
Display2...

Display1...
Display2...
Display1...
Display2...

thi
i

Display1...
Display2...

ipa

Diagram:

faq:

Ma

====================================================

define UnSafe state of an application?

Ve
nk
ate
sh

=>The process in which more than one user using the same resource

(Class or Object or Method) is known as UnSafe state of an
application and which generate Wrong results.

Note:

=>We use Thread Synchronization process to convert UnSafe state

application into Safe State application.

=========================================================

*imp
define Thread Synchronization?
=>The process of ordering the threads for execution is known as

Thread Synchronization process.
=>Thread Synchronization process can be performed in two ways:
1.Mutual Exclusion process

thi
i

2.Thread Communication process

1.Mutual Exclusion process:

=>The process of locking the programming resources and ordering

ipa

the threads for execution is known as Mutual Exclusion process.

Ma

=>This Mutual Exclusion process can be perfored in three ways:
(a)Synchronized block - Object Locking process

(b)Synchronized method - Instance method Locking process

Ve
nk
ate
sh

(c)Static synchronization - Static method Locking process

Dt : 10/7/2023
(a)Synchronized block - Object Locking process
=>The process of declaring set-of-statements with "synchronized"
keyword is known as synchronized block.

thi
i

syntax:
synchronized(ref-var)
{

ipa

//set-of-statements

Ma

}

=>This synchronized block process is used to apply the lock on

Ve
nk
ate
sh

the Object

Ex:

Available.java

package p1;
public class Available {
public static int available=1;
}
Selection.java

package p1;
public class Selection {
public void select(int n,String name) {
if(n<=Available.available) {
System.out.println(n+" tickets booked by
"+name);

thi
i

Available.available=Available.available-n;
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}else {
System.out.println("Sorry Tickets not available
for "+name);
}
}
}

ipa

User1.java

Ve
nk
ate
sh

Ma

package p1;
public class User1 implements Runnable{
public Selection ob;
public User1(Selection ob) {
this.ob=ob;
}
public void run() {
synchronized(ob) {
ob.select(1, "Alex");
}
}
}
User2.java

package p1;
public class User2 implements Runnable{
public Selection ob;
public User2(Selection ob) {
this.ob=ob;
}
public void run() {
synchronized(ob) {
ob.select(1, "Raj");
}
}

}
DemoThread5.java(MainClass)

Ve
nk
ate
sh

}

}

Ma

t1.start();
t2.start();

ipa

Thread t1 = new Thread(u1);
Thread t2 = new Thread(u2);

o/p:

1 tickets booked by Alex

Sorry Tickets not available for Raj

Diagram:

thi
i

package p2;
import p1.*;
public class DemoThread5 {
public static void main(String[] args) {
Selection ob = new Selection();
User1 u1 = new User1(ob);
User2 u2 = new User2(ob);

thi
i
ipa
Ma
Ve
nk
ate
sh
-----------------------------------------------------------

Limitation of Object Locking process:

=>In Object Locking process all instance methods within the

object will be under the lock and all methods are available to
one user at-a-time and which is not preferable all the time.
------------------------------------------------------------(b)Synchronized method - Instance method Locking process
=>The process of declaring Instance method with synchronized
keyword is known as synchronized method.
=>These synchronized methods will be under the lock and which are

available to one user at-a-time.

Ex:

ipa

package p1;
public class Available {
public static int available=1;
}

thi
i

Available.java

Selection.java

Ve
nk
ate
sh

Ma

package p1;
public class Selection {
public synchronized void select(int n,String name)
{
if(n<=Available.available) {
System.out.println(n+" tickets booked by
"+name);
Available.available=Available.available-n;
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}
}else {
System.out.println("Sorry Tickets not available
for "+name);
}
}
}
User1.java
package p1;
public class User1 implements Runnable{
public Selection ob;
public User1(Selection ob) {

this.ob=ob;

}
public void run() {
ob.select(1, "Alex");

thi
i

}

}

User2.java

Ma

ipa

package p1;
public class User2 implements Runnable{
public Selection ob;
public User2(Selection ob) {
this.ob=ob;
}
public void run() {

Ve
nk
ate
sh

ob.select(1, "Raj");
}

}

DemoThread6.java(MainClass)

package p2;
import p1.*;
public class DemoThread6 {
public static void main(String[] args) {
Selection ob = new Selection();
User1 u1 = new User1(ob);
User2 u2 = new User2(ob);
Thread t1 = new Thread(u1);
Thread t2 = new Thread(u2);
t1.start();
t2.start();

}

}

-----------------------------------------------------------(c)Static synchronization - Static method Locking process

thi
i

=>The process of declaring static methods with synchronized

keyword is known as static synchronization and in which the class

ipa

is under the lock and members of class are available to one user

Ex:

Ve
nk
ate
sh

Available.java

Ma

at-a-time.

package p1;
public class Available {
public static int available=1;
}
Selection.java

package p1;
public class Selection {
public synchronized static void select(int n,String
name) {
if(n<=Available.available) {
System.out.println(n+" tickets booked by
"+name);
Available.available=Available.available-n;
try {
Thread.sleep(2000);
}catch(Exception e) {e.printStackTrace();}

}else {
System.out.println("Sorry Tickets not available
for "+name);
}
}
}

thi
i

User1.java

}

User2.java

Ma

}

ipa

package p1;
public class User1 implements Runnable{
public void run() {
Selection.select(1, "Alex");

Ve
nk
ate
sh

package p1;
public class User2 implements Runnable{
public void run() {
Selection.select(1, "Raj");
}

}

DemoThread7.java(MainClass)

package p2;
import p1.*;
public class DemoThread7 {
public static void main(String[] args) {
User1 u1 = new User1();
User2 u2 = new User2();
Thread t1 = new Thread(u1);
Thread t2 = new Thread(u2);

t1.start();
t2.start();
}

}

thi
i

===================================================
*imp

ipa

2.Thread Communication process:

=>The process of establishing Communication b/w threads using

Thread Communication process or

Ma

the following methods from java.lang.Object class is known as

Inter Thread Communication process(ITC).

Ve
nk
ate
sh

(a)wait()

(b)notify()

(c)notifyAll()

(a)wait():

=>wait() method will block the thread execution temporarly until

it receives msg in the form of true or false.

(b)notify():
=>notify() method will unlock the resource and send the msg to
next waiting thread.

(c)notifyAll():
=>notifyAll() method also unlock the resource and send the msg
to all multiple waiting threads.

Ve
nk
ate
sh

Ma

ipa

thi
i

----------------------------------------------------

Dt : 11/7/2023
Ex-application:
(Demonstrating Producer-Consumer problem using Thread Communication

thi
i

process)

Ve
nk
ate
sh

Ma

ipa

Diagram:

Ex-Application:

Producer.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package p1;
public class Producer implements Runnable{
public StringBuffer sb = null;
public Producer() {
sb = new StringBuffer();
}
@Override
public void run() {
try {
synchronized(sb) {
for(int i=1;i<=10;i++) {
sb.append(i+" : ");
System.out.println("Producer
Appending data...");
Thread.sleep(2000);
}//end of loop
sb.notify();
//send message to next waiting thread
}//end of lock
}catch(Exception e) {e.printStackTrace();}
}
}
Consumer.java

package p1;
public class Consumer implements Runnable{
public Producer prod=null;
public Consumer(Producer prod) {
this.prod=prod;
}
@Override
public void run() {
try {
synchronized(prod.sb) {
System.out.println("Consumer
started...but blocked..");
prod.sb.wait();

thi
i

//block thread execution until it
receives message
System.out.println("*****Display using
Consumer****");
System.out.println(prod.sb);
}//end of lock
}catch(Exception e) {e.printStackTrace();}
}
}
DemoThread8.java(MainClass)

Ma

ipa

package p2;
import p1.*;
public class DemoThread8 {
public static void main(String[] args) {
Producer p = new Producer();
Consumer c = new Consumer(p);

Ve
nk
ate
sh

Thread t1 = new Thread(p);
Thread t2 = new Thread(c);

t2.setPriority(Thread.MAX_PRIORITY);
t1.setPriority(Thread.MIN_PRIORITY);

}

}

t2.start();
t1.start();

o/p:

Consumer started...but blocked..
Producer Appending data...
Producer Appending data...
Producer Appending data...

Producer Appending data...
Producer Appending data...
Producer Appending data...
Producer Appending data...

thi
i

Producer Appending data...
Producer Appending data...
Producer Appending data...

ipa

*****Display using Consumer****

Ve
nk
ate
sh

Execution flow of above program:

Ma

1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 :

thi
i
ipa
Ma
Ve
nk
ate
sh

==============================================================
*imp

Thread Life-Cycle:

=>Thread Life-Cycle demonstrates different states of thread from

Thread-Creation to Thread-Completion and Thread-Creation to
Thread-Termination

=>The following are different states of thread:
1.Thread Creation(New Thread)
2.Ready-to-run
3.Running(Executing thread)

(i)Thread Completion
(ii)Thread Blocked State
=>DeadLock

Ve
nk
ate
sh

Ma

ipa

thi
i

Diagram:

===============================================================

Dt : 12/7/2023

1.Thread Creation(New Thread)
=>The process of creating new thread using start() method is known as
Thread-Creation process.

2.Ready-to-run:
=>The state of thread where thread is waiting for execution.

thi
i

3.Running(Executing thread):
=>The state in which the thread is executing is known as Running State.

ipa

(i)Thread Completion:

Ma

=>The state in which the thread executed successfully and generated
result is known as Thread Completion.

Ve
nk
ate
sh

(ii)Thread Blocked State:

=>The state in which the thread execution blocked temporarly is known

as Thread Blocked State or Thread Live-Lock

=>The thread will be under blocked state if any one of the following

event is raised:

(a)wait() -method will block the thread execution until it receives msg
(b)sleep()-method will block the thread execution based on time
(c)Blocked on IO - The thread execution is blocked for incomplete
IO operation
(d)Block to Join - In thread dependencies,some threads will for another
to complete is known as "Blocked to Join"

(e)Block to Lock - The thread execution is blocked for incomplete
locking operation.

Note:

thi
i

=>If the raised events are completed from Blocked State then the threads
will join ready-to-run state

ipa

faq:

(i)wait()
(ii)sleep()

Ma

wt is the diff b/w

Ve
nk
ate
sh

=>wait() will block the thread execution until it receives msg,but sleep()
will block the thread executed on some time.
=>wait() will release the locks on the resources,but sleep() will not release
the locks on the resources.

----------------------------------------------------------------

faq:

define DeadLock?

=>The permanent blockage of thread is known as Thread DeadLock

Note:
=>If any raised event occurs permanently then thread is under DeadLock

===================================================================
=
faq:
How can we know the thread is under LiveLock or DeadLock?
=>We use isAlive() method to check the thread is under LiveLock or DeadLock.

thi
i

syntax:

ipa

boolean k = t1.isAlive();

faq:

Ma

Can we distrub the thread which is in wait() or sleep() state?

=>we use interrupt() method to dustrub the thread which is in wait() or

Ve
nk
ate
sh

sleep() state.
syntax:

t1.interrupt();

faq:

define daemon thread?

=>The thread which executes contineously is known as daemon thread
=>All server service threads are daemon threads.

syntax:
t1.setDaemon(true);

Note:
=>isDaemon() method is used to check the thread is daemon thread or not

faq:

thi
i

define join() method?
=>join() method will specify to complete the current thread and executed

ipa

reamining threads

package maccess;
public class DemoThread9 {

Ma

Ex:

Ve
nk
ate
sh

public static void main(String[] args) {

Thread t1 = new Thread(()->
{

for(int i=1;i<=5;i++)
{

System.out.println("Task-1");
try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}
}
});

Thread t2 = new Thread(()->
{
for(int i=1;i<=5;i++)

thi
i

{
System.out.println("Task-2");

Thread.sleep(2000);

ipa

try {

Ma

}catch(Exception e) {e.printStackTrace();}
}

Ve
nk
ate
sh

});

Thread t3 = new Thread(()->
{

for(int i=1;i<=5;i++)
{

System.out.println("Task-3");
try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}
}
});

t1.start();
try {
t1.join();
}catch(Exception e) {e.printStackTrace();}

thi
i

t2.start();
t3.start();

}

define yield() method?

Ma

--------------------------------------------------

ipa

}

=>yield() method will specify to stop the current thread and go for the

Ve
nk
ate
sh

next thread for execution.

=========================================================

Application of Threads:

(i)Threads are used in Gaming Applications
(ii)Threads are used in Server development

(iii)Threads are used in Server Application development
===========================================================

*imp

IO Streams and Files:

define stream?

=>The contineous flow of data is known as Stream

Types of streams:
=>Streams in Java are categorized into two types:

thi
i

1.Byte Stream
2.Character Stream

ipa

1.Byte Stream:

Byte Stream or Binary Stream

Ma

=>The contineous flow of data in the form of 8-bits is known as

=>Byte Stream supports all multimedia data formats like Text,Audio,Video,

Ve
nk
ate
sh

Image and Animation

2.Character Stream:

=>The contineous flow of data in the form of 16-bits is known as Character

Stream

=>Character Stream is preferable for Text data and not preferable for

Audio,Video,Image and Animation data

----------------------------------------------------------------

define File Storage?
=>The smallest permanent storage of ComputerSystem which is controlled and
managed by the OperatingSystem is known as File Storage.

=>In the process of establishing Communication b/w JavaProgram and
File Storage,the Java program must be constructed using classes and Interfaces
available from java.io package.

------------------------------------------------------------------Dt : 13/7/2023

thi
i

Diagram:

ipa

=>The following are some important classes related to Byte Stream or

1.FileInputStream
2.FileOutputStream

Ve
nk
ate
sh

3.DataInputStream

Ma

Binary Stream:

4.DataOutputStream

1.FileInputStream:

=>FileInputStream class is from java.io package and which is used to

find the file and opens the file to read binarystream data.
syntax:

FileInputStream fis = new FileInputStream(fPath&fName);

2.FileOutputStream:
=>FileOutputStream class is from java.io package and which is used to

create a new file and opens the file to write binarystream data.
syntax:
FileOutputStream fos = new FileOutputStream("fPath&fName");

thi
i

3.DataInputStream:
=>DataInputStream class is from java.io package and which is used to
read binarystream data into JavaProgram.

ipa

syntax:

4.DataOutputStream:

Ma

DataInputStream dis = new DataInputStream(Source);

Ve
nk
ate
sh

=>DataOutputStream class is from java.io package and which is used to

send binarystream data outof JavaProgram.
syntax:

DataOutputStream dos = new DataOutputStream(Destination);
------------------------------------------------------------------

Ex-Program:

wap to copy the file from one location to another location?

DemoFile1.java(MainClass)
package maccess;
import java.util.*;

import java.io.*;
public class DemoFile1 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);

thi
i

try(s;){
try {

File f1 = new File(s.nextLine());

Ma

if(f1.exists()) {

ipa

System.out.println("Enter the fPath&fName(Source)");

FileInputStream fis = new FileInputStream(f1);
System.out.println("Enter the fPath&fName(Destination)");

Ve
nk
ate
sh

File f2 = new File(s.nextLine());

FileOutputStream fos = new FileOutputStream(f2);
int k;

while((k=fis.read())!=-1) {
fos.write(k);

}

System.out.println("File Stored Successfully...");
fos.close();
fis.close();

}else {
System.out.println("Invalud file...");

}
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}

thi
i

}
o/p:

C:\Images\IMG_4917.JPG

D:\Images\xyz.jpg

Ve
nk
ate
sh

File Stored Successfully...

Ma

Enter the fPath&fName(Destination)

ipa

Enter the fPath&fName(Source)

Diagram:

==============================================================

*imp

Object State onto File Storage:

=>When we want to store Object State onto file storage,then the object

must be available in the form of Stream(Binary Stream).

define Serialization process?
=>The process of converting Object state into binary stream is known as
Serialization process.

=>we use writeObject() method from java.io.ObjectOutputStream class to
perform Serialization process
syntax:
ObjectOutputStream oos = new ObjectOutputStream(fos);

thi
i

oos.writeObject(objt_ref);

define De-Serialization process?

ipa

=>The process of converting binary Stream into Object-state is known as

Ma

De-Serialization process.

=>we use readObject() method from java.io.ObjectInputStream class to
perform De-Serialization process

Ve
nk
ate
sh

syntax:

ObjectInputStream ois = new ObjectInputStream(fis);
Object ob = ois.readObject();

Note:

=>To perform Serialization and De-Serialization processes,the class must

be implemented from "java.io.Serializable" interface.
=>"Serializable" is a marker interface and which specify Serialization and

De-Serialization.
-------------------------------------------------------------------Ex-Application:

UserRegistration.java
package test;
import java.util.*;
import java.io.*;

thi
i

@SuppressWarnings("serial")
public class UserRegistration extends Object implements

public String uName,pWord,name,mId;

public Date dateTime;

Ma

public long phNo;

ipa

Serializable{

public UserRegistration(String uName,String pWord,String name,

Ve
nk
ate
sh

String mId,long phNo,Date dateTime) {

this.uName=uName;
this.pWord=pWord;
this.name=name;
this.mId=mId;

this.phNo=phNo;

this.dateTime=dateTime;

}

@Override
public String toString() {
return "UserName:"+uName+"\nPassWord:"+pWord

+"\nName:"+name+"\nMailId:"+mId
+"\nPhoneNo:"+phNo+"\nDataTime:"+dateTime;
}
}

thi
i

DemoFile2.java(Serialization-MainClass)
package maccess;
import java.util.*;

ipa

import test.*;

public class DemoFile2 {

Ma

import java.io.*;

public static void main(String[] args) {

Ve
nk
ate
sh

Scanner s = new Scanner(System.in);
try(s;){

try {

System.out.println("Enter the UserName:");
String uN = s.nextLine();

System.out.println("Enter the PassWord:");
String pW = s.nextLine();

System.out.println("Enter the Name:");
String name = s.nextLine();
System.out.println("Enter the MailId:");
String mId = s.nextLine();

System.out.println("Enter the PhoneNo:");
long phNo = s.nextLong();
UserRegistration ob1 =
new UserRegistration(uN,pW,name,mId,phNo,new Date());

thi
i

File f = new File("D:\\Images\\Obj.txt");
FileOutputStream fos = new FileOutputStream(f);

oos.writeObject(ob1);

ipa

ObjectOutputStream oos = new ObjectOutputStream(fos);

oos.close();

Ma

System.out.println("Object Stored Successfully...");

}catch(Exception e) {e.printStackTrace();}

Ve
nk
ate
sh

}

}

}

o/p:

Enter the UserName:
raj

Enter the PassWord:
raj

Enter the Name:
Raj Kumar
Enter the MailId:

raj@gmail.com
Enter the PhoneNo:
98989812345
Object Stored Successfully...

thi
i

=============================================================
DT : 17/7/2023
DemoFile3.java(DeSerialization-MainClass)

ipa

package maccess;

import java.io.*;
public class DemoFile3 {

Ma

import test.*;

Ve
nk
ate
sh

public static void main(String[] args) {

try {

File f = new File("D:\\Images\\Obj.txt");
FileInputStream fis = new FileInputStream(f);
ObjectInputStream ois = new ObjectInputStream(fis);
UserRegistration ob2 = (UserRegistration)ois.readObject();
System.out.println("****UserDetails****");
System.out.println(ob2.toString());
ois.close();

}catch(Exception e) {e.printStackTrace();}
}

}
o/p:
****UserDetails****
UserName:Alex

Name:Alex
MailId:a@gmail.com
PhoneNo:9898981234

Ma

DataTime:Mon Jul 17 20:02:55 IST 2023

ipa

thi
i

PassWord:mzu672

===========================================================
Diagram:

Ve
nk
ate
sh

============================================================
faq:

wt is the advantage of Serialization process?
=>Through Serialization process we can make Objects available in the form
of stream and can move on the network from one location to another
location.

===============================================================
=>Based on Serialization process the objects in Java are categorized into
two types:
(i)Serializable Objects
(ii)Non-Serializable Objects

(i)Serializable Objects:
=>The objects which are generated from the classes which are implemented

thi
i

from "Serializable" interface are known as Serializable Objects.

(ii)Non-Serializable Objects:

=>The Objects which are generated from the classes which are not implemented

ipa

from "Serializable" interface are known as Non-Serializable Objects

Ma

===================================================================
CoreJava Objects:

1.User defined class Objects - Serializable
- Serializable

Ve
nk
ate
sh

2.String Objects

3.WrapperClass Objects
4.Array Objects

- Serializable

- Serializable

5.Collection<E> Objects

- Serializable

6.Map<K,V> Objects

- Serializable

7.Enum<E> Objects

- Serializable

===================================================================
=====
=>The following are some important classes related to Character Stream or
Text Stream:
1.FileReader

2.FileWriter
3.BufferedReader

1.FileReader:

file and opens the file to read Character Stream data.
syntax:

2.FileWriter:

Ma

ipa

FileReader fr = new FileReader("fPath&fName");

thi
i

=>FileReader class is from java.io package and which is used to find the

=>FileWriter class is from java.io package and which is used to create a

Ve
nk
ate
sh

new file and opens the file to write Character Stream data.
syntax:

FileWriter fw = new FileWriter("fpath&fName");

3.BufferedReader:

=>BufferedReader class is from java.io package and which is used to read

character stream into JavaProgram.
syntax:

BufferedReader br = new BufferedReader(new InputStreamReader(Source));

Ex-program:

wap to read data from console and store the data to file?

DemoFile4.java

Ve
nk
ate
sh

Ma

ipa

thi
i

package maccess;
import java.io.*;
public class DemoFile4 {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader
(new InputStreamReader(System.in));
File f = new File("D:\\Images\\Text.txt");
FileWriter fw = new FileWriter(f);
System.out.println("Enter the data(@ at
end):");
char ch1;
while((ch1=(char)br.read())!='@')
{
fw.write(ch1);
}
System.out.println("data stored to file
successfully...");
fw.close();
br.close();

}

System.out.println("=========================");
System.out.println("data from file....");
FileReader fr = new FileReader(f);
int k;
while((k=fr.read())!=-1)
{
System.out.print((char)k);
}
fr.close();
}catch(Exception e) {e.printStackTrace();}
}

o/p:
Enter the data(@ at end):
java is simpl
java is sec

thi
i

tasking
threading
@

ipa

data stored to file successfully...

data from file....
java is simpl

Ve
nk
ate
sh

java is sec

Ma

=========================

tasking

threading

===============================================================
faq:

define File class?

=>"File" class is from java.io package and which is used to find the

properties of file like file_length,file_path,file_exists or not,...
syntax:
File f = new File(fPath&fName);
================================================================

Ve
nk
ate
sh
thi
i

ipa

Ma

7/21/23, 11:21 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

FileStoray.png

1/1

7/21/23, 11:21 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

File2.png

1/1

Dt : 18/7/2023
*imp
Networking in Java:(Socket programming in Java)

thi
i

define Computer N/W?
=>The inter connection of autonomous computers is known as
Computer N/W.

ipa

=>Based on number of nodes in the N/W,the N/Ws are categorized in

(1)LAN - Local Area N/W
(2)MAN - Metropolitan Area N/W

Ve
nk
ate
sh

(3)WAN - Wide Area N/W

Ma

to the following:

(4)WWW - World Wide Web

define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.

-------------------------------------------------------

=>The Computers in the N/w are categorized into two types:
(1)Server Computers
(2)Client Computers

(1)Server Computers:
=>The computers which are holding Server Applications are

known as Server Computers.
=>These Server Computers will accept the request and generate
response.
(2)Client Computers:

thi
i

=>The computers which are holding client applications are
known as Client Computers

ipa

=>These Client Computers will generate request to Servers.

Ve
nk
ate
sh

Ma

Diagrams:

-----------------------------------------------------------

define N/W protocol?:
=>The set-of-rules used by computers in the N/W is known as
N/W protocol.
=>These N/w protocols are categorized into two types:

thi
i

(1)Connection oriented protocols
(2)Connection less Protocols

ipa

(1)Connection oriented protocols:

ack from Receiver.
Ex:

Ve
nk
ate
sh

TCP/IP

Ma

=>In Connection Oriented Protocols the Sender will receive

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive

ack from Receiver.
Ex:

UDP

------------------------------------------------------define IP Address?

=>The Unique identification number used by computer in the
N/W is known as IP Address.
=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified
into the following:
class A - 1.0.0.0 to 126.255.255.254

(16 million)

class B - 128.1.0.1 to 191.255.255.254 (65000)

class D - 224.0.0.0 to 239.255.255.255(multicast)
class E - 240.0.0.0 to 254.255.255.255(future)

ipa

note:

Ma

127.0.0.0 loopback network
255.255.255.255 - default network

thi
i

class C - 192.0.1.1 to 223.255.254.254 (254)

============================================================

Ve
nk
ate
sh

IPv4 Address. . . . . . . . . . . : 192.168.1.162

Subnet Mask . . . . . . . . . . . : 255.255.255.0
Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================
*imp

define Socket?

=>The logical connection established for communication is

known as Socket.

=>we use port number for Socket Connection.
Ex:
portNo : 0 to 65535

The following are the reserved port numbers:
13 - date and time services
21 - FTP which transfers files

thi
i

23 - Telnet,which provides remote login
25 - SMTP,which delivers mails

109 - POP,which access mail boxes

Ma

------------------------------------------------------------

ipa

80 - HTTP,which transfers web pages

The following are the some network classes from "java.net" package:
(1)Socket,ServerSocket - used for TCP/IP connection

Ve
nk
ate
sh

(2)DatagramPacket,DatagramSocket - used for UDP connection
(3)URL,URIConnection - used for read-write data from the
internet

(4)InetAddress - this class is used to get the

IP Address and hostname of the computer.

Note:

The communication b/w two Java Appls running on two diff JVMs
can be established using 'Socket' and 'ServerSocket' classes.
=>The JVMs can be in same ComputerSystem or different
ComputerSystems.

(1)Socket,ServerSocket Classes:
methods of Socket class:
1. InputStream getInputStream()

thi
i

2. OutputStream getOutputStream()
3. synchronized void close()

ipa

methods of ServerSocket class:

2. synchronized void close()

Ma

1. Socket accept()

----------------------------------------------------------------

Ve
nk
ate
sh

Diagram:

===============================================================

Program : Server.java
import java.io.*;

import java.net.*;
class Server
{

public static void main(String args[])
throws IOException

{
ServerSocket ss=new ServerSocket(888);
Socket s=ss.accept();
System.out.println("connection established");

(s.getOutputStream());
DataInputStream br=new DataInputStream

ipa

(s.getInputStream());

while(true)

Ve
nk
ate
sh

{

Ma

DataInputStream kb=
new DataInputStream(System.in);

String str,str1;

while((str=br.readLine())!=null)
{

System.out.println(str);
str1=kb.readLine();
ps.println(str1);
}

ps.close();
br.close();
kb.close();

thi
i

PrintStream ps=new PrintStream

ss.close();
s.close();
System.exit(0);
}

thi
i

}
}

==============================================================

ipa

Program : Client.java

import java.net.*;
class Client

Ve
nk
ate
sh

{

Ma

import java.io.*;

public static void main(String args[])
throws IOException

{

Socket s=new Socket("localhost",888);

DataOutputStream dos=new DataOutputStream
(s.getOutputStream());

DataInputStream br=new DataInputStream
(s.getInputStream());

DataInputStream kb=new DataInputStream
(System.in);

String str,str1;
while(!(str=kb.readLine()).equals("exit"))
{
dos.writeBytes(str+"\n");

thi
i

str1=br.readLine();
System.out.println(str1);
}

ipa

dos.close();

kb.close();
s.close();

Ve
nk
ate
sh

}

Ma

br.close();

}

==========================================================
Note:

=>Execute above two programs in two differnt CommandPrompts.

========================================================
Summary:

1.Socket Programming
2.RPC/RMI
3.CORBA
4.WebServices

thi
i
ipa
Ma
Ve
nk
ate
sh

=============================================================

*imp

"java.lang.Object" class:

=>"java.lang.Object" class is the ParentClass of all the classes declared
in the application
=>The following are some important methods of Object Class:
1.hashCode()

2.toString()
3.clone()
4.equals()
5.wait()

thi
i

6.notify()
7.notifyAll()
8.getClass()

Ve
nk
ate
sh

Ma

ipa

9.finalize()

7/21/23, 11:22 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

File3.png

1/1

Dt : 18/7/2023
*imp
Networking in Java:(Socket programming in Java)

thi
i

define Computer N/W?
=>The inter connection of autonomous computers is known as
Computer N/W.

ipa

=>Based on number of nodes in the N/W,the N/Ws are categorized in

(1)LAN - Local Area N/W
(2)MAN - Metropolitan Area N/W

Ve
nk
ate
sh

(3)WAN - Wide Area N/W

Ma

to the following:

(4)WWW - World Wide Web

define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.

-------------------------------------------------------

=>The Computers in the N/w are categorized into two types:
(1)Server Computers
(2)Client Computers

(1)Server Computers:
=>The computers which are holding Server Applications are

known as Server Computers.
=>These Server Computers will accept the request and generate
response.
(2)Client Computers:

thi
i

=>The computers which are holding client applications are
known as Client Computers

ipa

=>These Client Computers will generate request to Servers.

Ve
nk
ate
sh

Ma

Diagrams:

-----------------------------------------------------------

define N/W protocol?:
=>The set-of-rules used by computers in the N/W is known as
N/W protocol.
=>These N/w protocols are categorized into two types:

thi
i

(1)Connection oriented protocols
(2)Connection less Protocols

ipa

(1)Connection oriented protocols:

ack from Receiver.
Ex:

Ve
nk
ate
sh

TCP/IP

Ma

=>In Connection Oriented Protocols the Sender will receive

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive

ack from Receiver.
Ex:

UDP

------------------------------------------------------define IP Address?

=>The Unique identification number used by computer in the
N/W is known as IP Address.
=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified
into the following:
class A - 1.0.0.0 to 126.255.255.254

(16 million)

class B - 128.1.0.1 to 191.255.255.254 (65000)

class D - 224.0.0.0 to 239.255.255.255(multicast)
class E - 240.0.0.0 to 254.255.255.255(future)

ipa

note:

Ma

127.0.0.0 loopback network
255.255.255.255 - default network

thi
i

class C - 192.0.1.1 to 223.255.254.254 (254)

============================================================

Ve
nk
ate
sh

IPv4 Address. . . . . . . . . . . : 192.168.1.162

Subnet Mask . . . . . . . . . . . : 255.255.255.0
Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================
*imp

define Socket?

=>The logical connection established for communication is

known as Socket.

=>we use port number for Socket Connection.
Ex:
portNo : 0 to 65535

The following are the reserved port numbers:
13 - date and time services
21 - FTP which transfers files

thi
i

23 - Telnet,which provides remote login
25 - SMTP,which delivers mails

109 - POP,which access mail boxes

Ma

------------------------------------------------------------

ipa

80 - HTTP,which transfers web pages

The following are the some network classes from "java.net" package:
(1)Socket,ServerSocket - used for TCP/IP connection

Ve
nk
ate
sh

(2)DatagramPacket,DatagramSocket - used for UDP connection
(3)URL,URIConnection - used for read-write data from the
internet

(4)InetAddress - this class is used to get the

IP Address and hostname of the computer.

Note:

The communication b/w two Java Appls running on two diff JVMs
can be established using 'Socket' and 'ServerSocket' classes.
=>The JVMs can be in same ComputerSystem or different
ComputerSystems.

(1)Socket,ServerSocket Classes:
methods of Socket class:
1. InputStream getInputStream()

thi
i

2. OutputStream getOutputStream()
3. synchronized void close()

ipa

methods of ServerSocket class:

2. synchronized void close()

Ma

1. Socket accept()

----------------------------------------------------------------

Ve
nk
ate
sh

Diagram:

===============================================================

Program : Server.java
import java.io.*;

import java.net.*;
class Server
{

public static void main(String args[])
throws IOException

{
ServerSocket ss=new ServerSocket(888);
Socket s=ss.accept();
System.out.println("connection established");

(s.getOutputStream());
DataInputStream br=new DataInputStream

ipa

(s.getInputStream());

while(true)

Ve
nk
ate
sh

{

Ma

DataInputStream kb=
new DataInputStream(System.in);

String str,str1;

while((str=br.readLine())!=null)
{

System.out.println(str);
str1=kb.readLine();
ps.println(str1);
}

ps.close();
br.close();
kb.close();

thi
i

PrintStream ps=new PrintStream

ss.close();
s.close();
System.exit(0);
}

thi
i

}
}

==============================================================

ipa

Program : Client.java

import java.net.*;
class Client

Ve
nk
ate
sh

{

Ma

import java.io.*;

public static void main(String args[])
throws IOException

{

Socket s=new Socket("localhost",888);

DataOutputStream dos=new DataOutputStream
(s.getOutputStream());

DataInputStream br=new DataInputStream
(s.getInputStream());

DataInputStream kb=new DataInputStream
(System.in);

String str,str1;
while(!(str=kb.readLine()).equals("exit"))
{
dos.writeBytes(str+"\n");

thi
i

str1=br.readLine();
System.out.println(str1);
}

ipa

dos.close();

kb.close();
s.close();

Ve
nk
ate
sh

}

Ma

br.close();

}

==========================================================
Note:

=>Execute above two programs in two differnt CommandPrompts.

========================================================
Summary:

1.Socket Programming
2.RPC/RMI
3.CORBA
4.WebServices

thi
i
ipa
Ma
Ve
nk
ate
sh

=============================================================

*imp

"java.lang.Object" class:

=>"java.lang.Object" class is the ParentClass of all the classes declared
in the application
=>The following are some important methods of Object Class:
1.hashCode()

2.toString()
3.clone()
4.equals()
5.wait()

thi
i

6.notify()
7.notifyAll()
8.getClass()

Ve
nk
ate
sh

Ma

ipa

9.finalize()

Dt : 11/7/2023
Ex-application:
(Demonstrating Producer-Consumer problem using Thread Communication

ii

process)

Ve

nk
ate
s

hM
aip

ath

Diagram:

Ex-Application:

Producer.java

nk
ate
s

hM
aip

ath

ii

package p1;
public class Producer implements Runnable{
public StringBuffer sb = null;
public Producer() {
sb = new StringBuffer();
}
@Override
public void run() {
try {
synchronized(sb) {
for(int i=1;i<=10;i++) {
sb.append(i+" : ");
System.out.println("Producer
Appending data...");
Thread.sleep(2000);
}//end of loop
sb.notify();
//send message to next waiting thread
}//end of lock
}catch(Exception e) {e.printStackTrace();}
}
}
Consumer.java

Ve

package p1;
public class Consumer implements Runnable{
public Producer prod=null;
public Consumer(Producer prod) {
this.prod=prod;
}
@Override
public void run() {
try {
synchronized(prod.sb) {
System.out.println("Consumer
started...but blocked..");
prod.sb.wait();

DemoThread8.java(MainClass)

ath

ii

//block thread execution until it
receives message
System.out.println("*****Display using
Consumer****");
System.out.println(prod.sb);
}//end of lock
}catch(Exception e) {e.printStackTrace();}
}
}

hM
aip

package p2;
import p1.*;
public class DemoThread8 {
public static void main(String[] args) {
Producer p = new Producer();
Consumer c = new Consumer(p);
Thread t1 = new Thread(p);
Thread t2 = new Thread(c);

}

t2.start();
t1.start();

Ve

}

nk
ate
s

t2.setPriority(Thread.MAX_PRIORITY);
t1.setPriority(Thread.MIN_PRIORITY);

o/p:

Consumer started...but blocked..
Producer Appending data...
Producer Appending data...
Producer Appending data...

Producer Appending data...
Producer Appending data...
Producer Appending data...
Producer Appending data...

ii

Producer Appending data...

Producer Appending data...

hM
aip

*****Display using Consumer****

ath

Producer Appending data...

1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 :

Ve

nk
ate
s

Execution flow of above program:

ii
ath
hM
aip

*imp

nk
ate
s

==============================================================

Thread Life-Cycle:

=>Thread Life-Cycle demonstrates different states of thread from

Ve

Thread-Creation to Thread-Completion and Thread-Creation to
Thread-Termination
=>The following are different states of thread:
1.Thread Creation(New Thread)
2.Ready-to-run
3.Running(Executing thread)

(i)Thread Completion
(ii)Thread Blocked State
=>DeadLock

Ve

nk
ate
s

hM
aip

ath

ii

Diagram:

===============================================================

Dt : 12/7/2023

1.Thread Creation(New Thread)
=>The process of creating new thread using start() method is known as
Thread-Creation process.

2.Ready-to-run:
=>The state of thread where thread is waiting for execution.

ii

3.Running(Executing thread):

ath

=>The state in which the thread is executing is known as Running State.

hM
aip

(i)Thread Completion:

=>The state in which the thread executed successfully and generated
result is known as Thread Completion.

(ii)Thread Blocked State:

nk
ate
s

=>The state in which the thread execution blocked temporarly is known
as Thread Blocked State or Thread Live-Lock
=>The thread will be under blocked state if any one of the following
event is raised:

Ve

(a)wait() -method will block the thread execution until it receives msg
(b)sleep()-method will block the thread execution based on time
(c)Blocked on IO - The thread execution is blocked for incomplete
IO operation
(d)Block to Join - In thread dependencies,some threads will for another
to complete is known as "Blocked to Join"

(e)Block to Lock - The thread execution is blocked for incomplete
locking operation.

Note:

ii

=>If the raised events are completed from Blocked State then the threads

ath

will join ready-to-run state

wt is the diff b/w
(i)wait()
(ii)sleep()

hM
aip

faq:

=>wait() will block the thread execution until it receives msg,but sleep()

nk
ate
s

will block the thread executed on some time.

=>wait() will release the locks on the resources,but sleep() will not release
the locks on the resources.

----------------------------------------------------------------

Ve

faq:

define DeadLock?

=>The permanent blockage of thread is known as Thread DeadLock

Note:
=>If any raised event occurs permanently then thread is under DeadLock

===================================================================
=
faq:
How can we know the thread is under LiveLock or DeadLock?
=>We use isAlive() method to check the thread is under LiveLock or DeadLock.

ath

ii

syntax:

faq:

hM
aip

boolean k = t1.isAlive();

Can we distrub the thread which is in wait() or sleep() state?

=>we use interrupt() method to dustrub the thread which is in wait() or
sleep() state.

nk
ate
s

syntax:
t1.interrupt();

faq:

Ve

define daemon thread?

=>The thread which executes contineously is known as daemon thread
=>All server service threads are daemon threads.

syntax:
t1.setDaemon(true);

Note:
=>isDaemon() method is used to check the thread is daemon thread or not

faq:

ii

define join() method?

ath

=>join() method will specify to complete the current thread and executed

Ex:
package maccess;
public class DemoThread9 {

hM
aip

reamining threads

public static void main(String[] args) {

{

nk
ate
s

Thread t1 = new Thread(()->

for(int i=1;i<=5;i++)
{

Ve

System.out.println("Task-1");
try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}
}
});

Thread t2 = new Thread(()->
{
for(int i=1;i<=5;i++)

ii

{

try {

hM
aip

Thread.sleep(2000);

ath

System.out.println("Task-2");

}catch(Exception e) {e.printStackTrace();}
}
});

{

nk
ate
s

Thread t3 = new Thread(()->

for(int i=1;i<=5;i++)
{

Ve

System.out.println("Task-3");
try {

Thread.sleep(2000);

}catch(Exception e) {e.printStackTrace();}
}
});

t1.start();
try {
t1.join();
}catch(Exception e) {e.printStackTrace();}

ii

t2.start();

ath

t3.start();
}

hM
aip

}
-------------------------------------------------define yield() method?

=>yield() method will specify to stop the current thread and go for the
next thread for execution.

nk
ate
s

=========================================================
Application of Threads:

(i)Threads are used in Gaming Applications
(ii)Threads are used in Server development

Ve

(iii)Threads are used in Server Application development
===========================================================

*imp

IO Streams and Files:

define stream?

=>The contineous flow of data is known as Stream

Types of streams:
=>Streams in Java are categorized into two types:

ii

1.Byte Stream

ath

2.Character Stream

hM
aip

1.Byte Stream:

=>The contineous flow of data in the form of 8-bits is known as
Byte Stream or Binary Stream

=>Byte Stream supports all multimedia data formats like Text,Audio,Video,

nk
ate
s

Image and Animation

2.Character Stream:

=>The contineous flow of data in the form of 16-bits is known as Character
Stream

Ve

=>Character Stream is preferable for Text data and not preferable for
Audio,Video,Image and Animation data
----------------------------------------------------------------

define File Storage?
=>The smallest permanent storage of ComputerSystem which is controlled and
managed by the OperatingSystem is known as File Storage.

=>In the process of establishing Communication b/w JavaProgram and
File Storage,the Java program must be constructed using classes and Interfaces
available from java.io package.

ii

Diagram:

ath

------------------------------------------------------------------Dt : 13/7/2023

Binary Stream:
1.FileInputStream
2.FileOutputStream
3.DataInputStream

nk
ate
s

4.DataOutputStream

hM
aip

=>The following are some important classes related to Byte Stream or

1.FileInputStream:

=>FileInputStream class is from java.io package and which is used to

Ve

find the file and opens the file to read binarystream data.
syntax:

FileInputStream fis = new FileInputStream(fPath&fName);

2.FileOutputStream:
=>FileOutputStream class is from java.io package and which is used to

create a new file and opens the file to write binarystream data.
syntax:
FileOutputStream fos = new FileOutputStream("fPath&fName");

ii

3.DataInputStream:

read binarystream data into JavaProgram.

hM
aip

syntax:

ath

=>DataInputStream class is from java.io package and which is used to

DataInputStream dis = new DataInputStream(Source);

4.DataOutputStream:

=>DataOutputStream class is from java.io package and which is used to

syntax:

nk
ate
s

send binarystream data outof JavaProgram.

DataOutputStream dos = new DataOutputStream(Destination);
------------------------------------------------------------------

Ve

Ex-Program:

wap to copy the file from one location to another location?

DemoFile1.java(MainClass)
package maccess;
import java.util.*;

import java.io.*;
public class DemoFile1 {
public static void main(String[] args) {
Scanner s = new Scanner(System.in);

ii

try(s;){

ath

try {

System.out.println("Enter the fPath&fName(Source)");

if(f1.exists()) {

hM
aip

File f1 = new File(s.nextLine());

FileInputStream fis = new FileInputStream(f1);
System.out.println("Enter the fPath&fName(Destination)");
File f2 = new File(s.nextLine());

nk
ate
s

FileOutputStream fos = new FileOutputStream(f2);
int k;

while((k=fis.read())!=-1) {
fos.write(k);

Ve

}

System.out.println("File Stored Successfully...");
fos.close();
fis.close();

}else {
System.out.println("Invalud file...");

}
}catch(Exception e) {e.printStackTrace();}
}//end of try with resource
}

ii

}

Enter the fPath&fName(Source)

hM
aip

C:\Images\IMG_4917.JPG

ath

o/p:

Enter the fPath&fName(Destination)
D:\Images\xyz.jpg
File Stored Successfully...

nk
ate
s

Diagram:

==============================================================
*imp

Object State onto File Storage:

Ve

=>When we want to store Object State onto file storage,then the object
must be available in the form of Stream(Binary Stream).

define Serialization process?
=>The process of converting Object state into binary stream is known as
Serialization process.

=>we use writeObject() method from java.io.ObjectOutputStream class to
perform Serialization process
syntax:
ObjectOutputStream oos = new ObjectOutputStream(fos);

define De-Serialization process?

ath

ii

oos.writeObject(objt_ref);

De-Serialization process.

hM
aip

=>The process of converting binary Stream into Object-state is known as

=>we use readObject() method from java.io.ObjectInputStream class to
perform De-Serialization process
syntax:

nk
ate
s

ObjectInputStream ois = new ObjectInputStream(fis);
Object ob = ois.readObject();

Note:

Ve

=>To perform Serialization and De-Serialization processes,the class must
be implemented from "java.io.Serializable" interface.
=>"Serializable" is a marker interface and which specify Serialization and

De-Serialization.
-------------------------------------------------------------------Ex-Application:

UserRegistration.java
package test;
import java.util.*;
import java.io.*;

Serializable{

public long phNo;
public Date dateTime;

hM
aip

public String uName,pWord,name,mId;

ath

public class UserRegistration extends Object implements

ii

@SuppressWarnings("serial")

public UserRegistration(String uName,String pWord,String name,
String mId,long phNo,Date dateTime) {

nk
ate
s

this.uName=uName;
this.pWord=pWord;
this.name=name;
this.mId=mId;

Ve

this.phNo=phNo;

this.dateTime=dateTime;

}

@Override
public String toString() {
return "UserName:"+uName+"\nPassWord:"+pWord

+"\nName:"+name+"\nMailId:"+mId
+"\nPhoneNo:"+phNo+"\nDataTime:"+dateTime;
}
}

ii

DemoFile2.java(Serialization-MainClass)

ath

package maccess;
import java.util.*;

import java.io.*;
public class DemoFile2 {

hM
aip

import test.*;

public static void main(String[] args) {
Scanner s = new Scanner(System.in);

nk
ate
s

try(s;){

try {

System.out.println("Enter the UserName:");
String uN = s.nextLine();

Ve

System.out.println("Enter the PassWord:");
String pW = s.nextLine();
System.out.println("Enter the Name:");
String name = s.nextLine();
System.out.println("Enter the MailId:");
String mId = s.nextLine();

System.out.println("Enter the PhoneNo:");
long phNo = s.nextLong();
UserRegistration ob1 =
new UserRegistration(uN,pW,name,mId,phNo,new Date());

ath

FileOutputStream fos = new FileOutputStream(f);

ii

File f = new File("D:\\Images\\Obj.txt");

ObjectOutputStream oos = new ObjectOutputStream(fos);

hM
aip

oos.writeObject(ob1);

System.out.println("Object Stored Successfully...");
oos.close();

}catch(Exception e) {e.printStackTrace();}

}
}
o/p:

nk
ate
s

}

Enter the UserName:

Ve

raj

Enter the PassWord:
raj

Enter the Name:
Raj Kumar
Enter the MailId:

raj@gmail.com
Enter the PhoneNo:
98989812345
Object Stored Successfully...

ii

=============================================================

DemoFile3.java(DeSerialization-MainClass)

import test.*;
import java.io.*;
public class DemoFile3 {

hM
aip

package maccess;

ath

DT : 17/7/2023

public static void main(String[] args) {

nk
ate
s

try {

File f = new File("D:\\Images\\Obj.txt");
FileInputStream fis = new FileInputStream(f);
ObjectInputStream ois = new ObjectInputStream(fis);

Ve

UserRegistration ob2 = (UserRegistration)ois.readObject();
System.out.println("****UserDetails****");
System.out.println(ob2.toString());
ois.close();
}catch(Exception e) {e.printStackTrace();}
}

}
o/p:
****UserDetails****
UserName:Alex

ii

PassWord:mzu672

ath

Name:Alex
MailId:a@gmail.com

hM
aip

PhoneNo:9898981234
DataTime:Mon Jul 17 20:02:55 IST 2023

===========================================================
Diagram:

faq:

nk
ate
s

============================================================

wt is the advantage of Serialization process?
=>Through Serialization process we can make Objects available in the form
of stream and can move on the network from one location to another

Ve

location.

===============================================================
=>Based on Serialization process the objects in Java are categorized into
two types:
(i)Serializable Objects
(ii)Non-Serializable Objects

(i)Serializable Objects:
=>The objects which are generated from the classes which are implemented

ii

from "Serializable" interface are known as Serializable Objects.

ath

(ii)Non-Serializable Objects:

=>The Objects which are generated from the classes which are not implemented

hM
aip

from "Serializable" interface are known as Non-Serializable Objects

===================================================================
CoreJava Objects:

1.User defined class Objects - Serializable
2.String Objects

- Serializable

- Serializable

nk
ate
s

3.WrapperClass Objects
4.Array Objects

- Serializable

- Serializable

6.Map<K,V> Objects

- Serializable

7.Enum<E> Objects

- Serializable

Ve

5.Collection<E> Objects

===================================================================
=====
=>The following are some important classes related to Character Stream or
Text Stream:
1.FileReader

2.FileWriter
3.BufferedReader

1.FileReader:

syntax:

2.FileWriter:

hM
aip

FileReader fr = new FileReader("fPath&fName");

ath

file and opens the file to read Character Stream data.

ii

=>FileReader class is from java.io package and which is used to find the

=>FileWriter class is from java.io package and which is used to create a

syntax:

nk
ate
s

new file and opens the file to write Character Stream data.

FileWriter fw = new FileWriter("fpath&fName");

3.BufferedReader:

Ve

=>BufferedReader class is from java.io package and which is used to read
character stream into JavaProgram.
syntax:

BufferedReader br = new BufferedReader(new InputStreamReader(Source));

Ex-program:

wap to read data from console and store the data to file?

DemoFile4.java

nk
ate
s

hM
aip

ath

ii

package maccess;
import java.io.*;
public class DemoFile4 {
public static void main(String[] args) {
try {
BufferedReader br = new BufferedReader
(new InputStreamReader(System.in));
File f = new File("D:\\Images\\Text.txt");
FileWriter fw = new FileWriter(f);
System.out.println("Enter the data(@ at
end):");
char ch1;
while((ch1=(char)br.read())!='@')
{
fw.write(ch1);
}
System.out.println("data stored to file
successfully...");
fw.close();
br.close();

Ve

System.out.println("=========================");
System.out.println("data from file....");
FileReader fr = new FileReader(f);
int k;
while((k=fr.read())!=-1)
{
System.out.print((char)k);
}
fr.close();
}catch(Exception e) {e.printStackTrace();}
}

}

o/p:
Enter the data(@ at end):
java is simpl
java is sec

ii

tasking

@

hM
aip

data stored to file successfully...

ath

threading

=========================
data from file....
java is simpl

tasking

nk
ate
s

java is sec

threading

===============================================================
faq:

Ve

define File class?

=>"File" class is from java.io package and which is used to find the

properties of file like file_length,file_path,file_exists or not,...
syntax:
File f = new File(fPath&fName);
================================================================

ii

ath

hM
aip

nk
ate
s

Ve

7/21/23, 11:21 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

FileStoray.png

1/1

7/21/23, 11:22 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

File3.png

1/1

7/21/23, 11:21 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

File2.png

1/1

7/21/23, 11:22 AM

https://classroom.google.com/w/NjAyNDU2MTk5MTI4/t/all

File3.png

1/1

Dt : 18/7/2023
*imp
Networking in Java:(Socket programming in Java)

ii

define Computer N/W?

ath

=>The inter connection of autonomous computers is known as
Computer N/W.

to the following:
(1)LAN - Local Area N/W

hM
aip

=>Based on number of nodes in the N/W,the N/Ws are categorized in

(2)MAN - Metropolitan Area N/W
(3)WAN - Wide Area N/W

nk
ate
s

(4)WWW - World Wide Web
define WWW?

=>WWW is an UnLimited N/W holding UnLimited Nodes.
-------------------------------------------------------

Ve

=>The Computers in the N/w are categorized into two types:
(1)Server Computers
(2)Client Computers

(1)Server Computers:
=>The computers which are holding Server Applications are

known as Server Computers.
=>These Server Computers will accept the request and generate
response.
(2)Client Computers:

ii

=>The computers which are holding client applications are

ath

known as Client Computers

Ve

nk
ate
s

Diagrams:

hM
aip

=>These Client Computers will generate request to Servers.

-----------------------------------------------------------

define N/W protocol?:
=>The set-of-rules used by computers in the N/W is known as
N/W protocol.
=>These N/w protocols are categorized into two types:

ii

(1)Connection oriented protocols

hM
aip

(1)Connection oriented protocols:

ath

(2)Connection less Protocols

=>In Connection Oriented Protocols the Sender will receive
ack from Receiver.
Ex:
TCP/IP

nk
ate
s

(2)Connection less Protocols:

=>In Connection less protocols the Sender will not receive
ack from Receiver.
Ex:

Ve

UDP

------------------------------------------------------define IP Address?

=>The Unique identification number used by computer in the
N/W is known as IP Address.
=>we use this IP Address to identify the computer in the N/W.

=>Based on the range of IP Addresses the N/Ws are Classified
into the following:
class A - 1.0.0.0 to 126.255.255.254

(16 million)

class B - 128.1.0.1 to 191.255.255.254 (65000)

ii

class C - 192.0.1.1 to 223.255.254.254 (254)

class E - 240.0.0.0 to 254.255.255.255(future)

127.0.0.0 loopback network

hM
aip

note:

ath

class D - 224.0.0.0 to 239.255.255.255(multicast)

255.255.255.255 - default network

============================================================
IPv4 Address. . . . . . . . . . . : 192.168.1.162

nk
ate
s

Subnet Mask . . . . . . . . . . . : 255.255.255.0
Default Gateway . . . . . . . . . : 192.168.1.1

===========================================================
*imp

Ve

define Socket?

=>The logical connection established for communication is

known as Socket.

=>we use port number for Socket Connection.
Ex:
portNo : 0 to 65535

The following are the reserved port numbers:
13 - date and time services
21 - FTP which transfers files

ii

23 - Telnet,which provides remote login

80 - HTTP,which transfers web pages

hM
aip

109 - POP,which access mail boxes

ath

25 - SMTP,which delivers mails

------------------------------------------------------------

The following are the some network classes from "java.net" package:
(1)Socket,ServerSocket - used for TCP/IP connection

(2)DatagramPacket,DatagramSocket - used for UDP connection

nk
ate
s

(3)URL,URIConnection - used for read-write data from the
internet

(4)InetAddress - this class is used to get the

Ve

IP Address and hostname of the computer.

Note:

The communication b/w two Java Appls running on two diff JVMs
can be established using 'Socket' and 'ServerSocket' classes.
=>The JVMs can be in same ComputerSystem or different
ComputerSystems.

(1)Socket,ServerSocket Classes:
methods of Socket class:
1. InputStream getInputStream()

ii

2. OutputStream getOutputStream()

1. Socket accept()
2. synchronized void close()

hM
aip

methods of ServerSocket class:

ath

3. synchronized void close()

----------------------------------------------------------------

nk
ate
s

Diagram:

===============================================================

Program : Server.java

Ve

import java.io.*;

import java.net.*;
class Server
{

public static void main(String args[])
throws IOException

{
ServerSocket ss=new ServerSocket(888);
Socket s=ss.accept();
System.out.println("connection established");

ii

PrintStream ps=new PrintStream

DataInputStream br=new DataInputStream

DataInputStream kb=

hM
aip

(s.getInputStream());

new DataInputStream(System.in);
while(true)
{

nk
ate
s

String str,str1;

while((str=br.readLine())!=null)
{

System.out.println(str);

Ve

str1=kb.readLine();
ps.println(str1);
}

ps.close();
br.close();
kb.close();

ath

(s.getOutputStream());

ss.close();
s.close();
System.exit(0);
}

ii

}

ath

}

==============================================================

import java.io.*;
import java.net.*;
class Client
{

hM
aip

Program : Client.java

nk
ate
s

public static void main(String args[])
throws IOException

{

Socket s=new Socket("localhost",888);

Ve

DataOutputStream dos=new DataOutputStream
(s.getOutputStream());

DataInputStream br=new DataInputStream
(s.getInputStream());
DataInputStream kb=new DataInputStream
(System.in);

String str,str1;
while(!(str=kb.readLine()).equals("exit"))
{
dos.writeBytes(str+"\n");

ii

str1=br.readLine();

ath

System.out.println(str1);
}

br.close();
kb.close();
s.close();

}

nk
ate
s

}

hM
aip

dos.close();

==========================================================
Note:

=>Execute above two programs in two differnt CommandPrompts.

Ve

========================================================
Summary:

1.Socket Programming
2.RPC/RMI
3.CORBA
4.WebServices

ii
ath
hM
aip
nk
ate
s

=============================================================

Ve

*imp

"java.lang.Object" class:
=>"java.lang.Object" class is the ParentClass of all the classes declared
in the application
=>The following are some important methods of Object Class:
1.hashCode()

2.toString()
3.clone()
4.equals()
5.wait()

ii

6.notify()

ath

7.notifyAll()
8.getClass()

Ve

nk
ate
s

hM
aip

9.finalize()

Dt : 19/7/2023
1.hashCode():
=>The unique numeric number which is generated while object creation
process is known as hashCode.

ii

=>we use hashCode() method to display the hashCode on an Object.

ath

syntax:

2.toString():

hM
aip

int hc = obj.hashCode();

=>toString() method is used to display the content from the object and
this method is executed automatically when we display object reference.
syntax:

*imp

nk
ate
s

String dt = obj.toString();

3.clone():

Ve

=>The process of creating the duplicate copy of an Object is known as
Cloning process.

=>we use clone() method to perform cloning process.

Method signature of clone():
protected native java.lang.Object clone()

throws java.lang.CloneNotSupportedException;

syntax:

Ve

nk
ate
s

hM
aip

ath

ii

Object ob = obj.clone();

=>we use the following steps to perform cloning process:
Step-1 : The user defined class must be implemented from "Cloneable"
interface.

Step-2 : The user defined class must be declared with one user defined
Object-return-type method
Step-3 : This user defined Object-return-type method must call "clone()"
method to perform cloning process

ii

Step-4 : Call User defined Object-return-type method to start cloning

-----------------------------------------------------------

hM
aip

Types of Cloning process:

ath

process.

=>Cloning process in Java can be perfomed in two ways:
(a)Shallow Cloning process
(b)Deep Cloning process

nk
ate
s

(a)Shallow Cloning process:

=>The process of cloning only Outer-Objects is known as Shallow Cloning.

(b)Deep Cloning process:

Ve

=>The process of cloning Outer-Objects and reffered-Objects is known as
Deep Cloning process.

===================================================================
=
Ex-program-1:(Demonstrating Shallow Cloning process)

Address1.java

Employee1.java

hM
aip

ath

ii

package p1;
public class Address1 extends Object
{
public String city,state;
public int pinCode;
@Override
public String toString()
{
return
"City:"+city+"\nState:"+state+"\nPinCode:"+pinCode;
}
}

Ve

nk
ate
s

package p1;
public class Employee1 extends Object implements
Cloneable
{
public String id,name;
public Address1 ad = new Address1();
@Override
public String toString()
{
return "EmpId:"+id+"\nName:"+name;
}
public Object getRef1()
{
Object ob=null;
try {
ob = super.clone();
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}
}

DemoClone1.java(MainClass)
package p2;
import java.util.*;
import p1.*;

ii

public class DemoClone1 {

Scanner s = new Scanner(System.in);

hM
aip

try(s;){

ath

public static void main(String[] args) {

try {

//Original Object

Employee1 ob1 = new Employee1();

System.out.println("Enter the EmpId:");

nk
ate
s

ob1.id = s.nextLine();

System.out.println("Enter the EmpName:");
ob1.name = s.nextLine();

System.out.println("Enter the EmpCity:");

Ve

ob1.ad.city = s.nextLine();

System.out.println("Enter the EmpState:");
ob1.ad.state = s.nextLine();
System.out.println("Enter the EmpPinCode:");
ob1.ad.pinCode = s.nextInt();
System.out.println("****Original Object*****");

System.out.println(ob1.toString());
System.out.println(ob1.ad.toString());
System.out.println("----hashCodes----");
System.out.println("ob1 : "+ob1.hashCode());

ii

System.out.println("ob1.ad : "+ob1.ad.hashCode());

ath

//Cloned Object
Employee1 ob2 = (Employee1)ob1.getRef1();

hM
aip

//Specialization process

System.out.println("****Cloned Object*****");
System.out.println(ob2.toString());

System.out.println(ob2.ad.toString());

System.out.println("----hashCodes----");

nk
ate
s

System.out.println("ob2 : "+ob2.hashCode());

System.out.println("ob2.ad : "+ob2.ad.hashCode());

}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

Ve

}
}

o/p:

Enter the EmpId:
A121
Enter the EmpName:

Alex
Enter the EmpCity:
Hyd
Enter the EmpState:

ii

TS

ath

Enter the EmpPinCode:
612345

EmpId:A121
Name:Alex
City:Hyd
State:TS

nk
ate
s

PinCode:612345

hM
aip

****Original Object*****

----hashCodes----

ob1 : 2074407503

ob1.ad : 999966131

Ve

****Cloned Object*****
EmpId:A121
Name:Alex
City:Hyd
State:TS
PinCode:612345

----hashCodes---ob2 : 1989780873
ob2.ad : 999966131

nk
ate
s

hM
aip

ath

ii

Diagram:

===================================================================
=
Ex-program-2:(Demonstrating Deep Cloning Process)
Note:

Ve

=>To perform Deep Cloning process,the reffered classes must be implemented

from "Cloneable" interface and the classes must be declared with user defined
Object-return-type method to call "clone()" method to perform cloning process.

Address2.java

nk
ate
s

hM
aip

ath

ii

package p1;
public class Address2 extends Object implements
Cloneable
{
public String city,state;
public int pinCode;
@Override
public String toString()
{
return
"City:"+city+"\nState:"+state+"\nPinCode:"+pinCode;
}
public Object getRef2()
{
Object ob = null;
try {
ob = super.clone();
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}
}
Employee2.java

Ve

package p1;
public class Employee2 extends Object implements
Cloneable
{
public String id,name;
public Address2 ad = new Address2();
@Override
public String toString()
{
return "EmpId:"+id+"\nName:"+name;
}
public Object getRef1()
{
Employee2 ob=null;
try {

ii

ob = (Employee2)super.clone(); //Employee2 object
ob.ad = (Address2)ob.ad.getRef2();//Reference of
Address2
}catch(CloneNotSupportedException cnse)
{cnse.printStackTrace();}
return ob;
}
}

ath

DemoClone2.java(MainClass)
package p2;

import p1.*;
public class DemoClone2 {

hM
aip

import java.util.*;

public static void main(String[] args) {

nk
ate
s

Scanner s = new Scanner(System.in);
try(s;){

try {

//Original Object

Employee2 ob1 = new Employee2();

Ve

System.out.println("Enter the EmpId:");
ob1.id = s.nextLine();
System.out.println("Enter the EmpName:");
ob1.name = s.nextLine();
System.out.println("Enter the EmpCity:");

ob1.ad.city = s.nextLine();
System.out.println("Enter the EmpState:");
ob1.ad.state = s.nextLine();
System.out.println("Enter the EmpPinCode:");

System.out.println(ob1.toString());

hM
aip

System.out.println(ob1.ad.toString());

ath

System.out.println("****Original Object*****");

ii

ob1.ad.pinCode = s.nextInt();

System.out.println("----hashCodes----");

System.out.println("ob1 : "+ob1.hashCode());

System.out.println("ob1.ad : "+ob1.ad.hashCode());
//Cloned Object

nk
ate
s

Employee2 ob2 = (Employee2)ob1.getRef1();
//Specialization process

System.out.println("****Cloned Object*****");
System.out.println(ob2.toString());

Ve

System.out.println(ob2.ad.toString());
System.out.println("----hashCodes----");
System.out.println("ob2 : "+ob2.hashCode());
System.out.println("ob2.ad : "+ob2.ad.hashCode());

}catch(Exception e) {e.printStackTrace();}
}//end of try with resource

}
}
o/p:
Enter the EmpId:

ii

A345

ath

Enter the EmpName:
Ram

Hyd
Enter the EmpState:
TS

675634

nk
ate
s

Enter the EmpPinCode:

hM
aip

Enter the EmpCity:

****Original Object*****
EmpId:A345
Name:Ram

Ve

City:Hyd
State:TS

PinCode:675634

----hashCodes---ob1 : 2074407503
ob1.ad : 999966131

****Cloned Object*****
EmpId:A345
Name:Ram
City:Hyd

ii

State:TS

ath

PinCode:675634
----hashCodes----

ob2.ad : 1480010240

hM
aip

ob2 : 1989780873

Ve

nk
ate
s

===================================================================
===

===================================================================
===
Dt : 20/7/2023

Ve

nk

ate

sh

Ma
ip

ath

ii

Diagram:

===================================================================
faq:
define Cloneable?

=>Cloneable is an interface from java.lang package and which is marker
interface
or Empty interface.
=>This Cloneable interface will initiate Cloning process.

faq:
wt is the advantage of Cloning process?

ath

ii

===================================================================
===

Ma
ip

=>Through Cloning process we can take the backup of Objects part of
Protection
and Security.

sh

===================================================================
===
4.equals():

ate

=>equals() method is used to compare two objects and generate boolean
result.

nk

syntax:

Ve

booleab k = ob1.equals(ob2);

5.wait()

6.notify()
7.notifyAll():
=>These methods are used to perform thread communication process.

8.getClass():
=>getClass() method is used to display the class name of an Object.
syntax:

ath

ii

Class nm = obj.getClass();

9.finalize():

Ma
ip

=>finalize() method is used to finalize the objects are eligible for garbage
Collection process or not.

===================================================================
=======

sh

faq:
define Garbage Collection Process?

ate

=>The process of identifying the anonymous objects and destroying is known as
Garbage Collection Process.

nk

=>To perform Garbage Collection process,the ExecutionEngine internally uses
"gc()"

Ve

method.

=>This gc() method will identify all anonymous objects and calls finalize()
method
to finalize objects for garbage colection and they are destroyed.
=>This gc() method is available from "System" and "Runtime" classes.
=>This gc() method is executed like daemon-thread.

===================================================================
========
Note:(Components of JVM)
PC Register Area:
=>Program Counter(PC) registers will hold the status of method executions in

ath

ii

JavaStackArea.

=>Every method which is executing in Java Stack Area will have its own
Program

Ma
ip

Counter Register(PCR)

=>All Program Counter Registers are opened in a Separate memory block
known as

ate

Native method Area:

sh

PC-Register Area.

=>The methods from the JavaLib which are declared with "native" keyword are
known

nk

as native methods

Ve

=>These native methods internally having c/c++ codes.
=>when Native methods are used in the application,then Class Loader
SubSystem will
identify the Native methods and loads onto a separate location known as
Native
method Area.
=>ExecutionEngine internally uses JNI(Java Native method Interface) to execute

Native methods.
---------------------------------------------------------------------Execution Engine:
=>Execution Engine is executor or processor of JVM and which starts execution

ath

=>This Execution Engine internally having two translators:
(i)Interpreter

Ma
ip

(ii)JIT Compiler

nk

ate

sh

Diagram:

Ve

ii

with main() method available in Java Stack Area.

Ve

nk

ate

sh

Ma
ip

ath

ii

===================================================================
======


